import { Results, AnyDocument, SearchParams, AnyOrama, Nullable } from '@orama/orama';

type Context = Results<AnyDocument>['hits'];
type Message = {
    role: 'user' | 'assistant';
    content: string;
};
type InferenceType = 'documentation';
type AnswerParams<M extends boolean, UserContext = unknown> = {
    initialMessages: Message[];
    inferenceType: InferenceType;
    oramaClient: OramaClient<M>;
    userContext?: UserContext;
    events?: {
        onMessageChange?: (messages: Message[]) => void;
        onMessageLoading?: (receivingMessage: boolean) => void;
        onAnswerAborted?: (aborted: true) => void;
        onSourceChange?: <T = AnyDocument>(sources: Results<T>) => void;
        onQueryTranslated?: (query: SearchParams<AnyOrama>) => void;
        onRelatedQueries?: (relatedQueries: string[]) => void;
        onNewInteractionStarted?: (interactionId: string) => void;
        onStateChange?: (state: Interaction[]) => void;
        onInteractionDone?: (interaction: Interaction) => void;
    };
    systemPrompts?: string[];
};
type Interaction<T = AnyDocument> = {
    interactionId: string;
    query: string;
    response: string;
    relatedQueries: Nullable<string[]>;
    sources: Nullable<Results<T>>;
    translatedQuery: Nullable<SearchParams<AnyOrama>>;
    segment: Nullable<string>;
    trigger: Nullable<string>;
    aborted: boolean;
    loading: boolean;
    error: boolean;
    errorMessage: string | null;
};
type AskParams = SearchParams<AnyOrama> & {
    userData?: unknown;
    related?: {
        howMany?: 1 | 2 | 3 | 4 | 5;
        format?: 'question' | 'query';
    };
};
declare class AnswerSession<M extends boolean> {
    private messages;
    private inferenceType;
    private oramaClient;
    private endpoint;
    private abortController?;
    private events;
    private userContext?;
    private conversationID;
    private lastInteractionParams?;
    state: Interaction[];
    private systemPrompts?;
    constructor(params: AnswerParams<M>);
    askStream(params: AskParams): Promise<AsyncGenerator<string>>;
    ask(params: AskParams): Promise<string>;
    getMessages(): Message[];
    clearSession(): void;
    abortAnswer(): void;
    regenerateLast({ stream }?: {
        stream?: boolean | undefined;
    }): Promise<string | AsyncGenerator<string>>;
    private addNewEmptyAssistantMessage;
    private fetchAnswer;
    /**
     * Methods associated with custom system prompts
     */
    setSystemPromptConfiguration(config: {
        systemPrompts: string[];
    }): this;
    getSystemPromptConfiguration(): string[] | undefined;
}

type Optional<T = unknown> = T | undefined;
type Override<T extends object, K extends {
    [P in keyof T]?: unknown;
}> = Omit<T, keyof K> & K;
interface SearchEvent {
    rawSearchString?: string;
    query: ClientSearchParams;
    resultsCount: number;
    roundTripTime: number;
    searchedAt: Date;
    userId: string;
    cached?: boolean;
    identity?: string;
    alias?: string;
}
interface ICollector {
    endpoint: string;
    deploymentID: string;
    index: string;
}
interface OramaInitResponse {
    deploymentID: string;
    deploymentDatetime: string;
    collectUrl: string;
    index: string;
    pop: string;
    searchSession?: {
        token: string;
        maxAge: number;
    } | {
        required: true;
    };
}
interface IOramaClient {
    api_key: string;
    endpoint: string;
    answersApiBaseURL?: string;
    telemetry?: Partial<TelemetryConfig> | false;
    cache?: Partial<CacheConfig> | false;
}
interface IOramaClientMultiSearch<M extends boolean> extends Omit<IOramaClient, 'api_key' | 'endpoint'> {
    mergeResults?: M;
    indexes: {
        api_key: string;
        endpoint: string;
    }[];
}
interface TelemetryConfig {
    flushInterval: number;
    flushSize: number;
}
interface CacheConfig {
}
interface HeartBeatConfig {
    frequency: number;
}
type Endpoint$1 = 'search' | 'init' | 'info' | 'health' | 'vector-search2' | 'multi_search' | 'init_multi_search';
type Method = 'GET' | 'POST';
interface OramaError extends Error {
    httpResponse?: Response;
}

interface SearchConfig {
    abortController?: AbortController;
    abortSignal?: AbortSignal;
    fresh?: boolean;
    debounce?: number;
}
type SearchMode = 'fulltext' | 'vector' | 'hybrid';
type AdditionalSearchParams = {
    mode?: SearchMode;
    returning?: string[];
    mergeResults?: boolean;
};
type SortByClauseUnion = SortByClause | SortByClause[];
type Order = 'ASC' | 'DESC' | 'asc' | 'desc';
type SortByClause = {
    property: string;
    order?: Order;
};
type ClientSearchParams = Override<SearchParams<AnyOrama>, {
    sortBy?: SortByClauseUnion;
}> & AdditionalSearchParams;
type OramaClientSearchResult<M> = M extends true ? Results<AnyDocument> : Results<AnyDocument>[];
type AnswerSessionParams = {
    inferenceType?: InferenceType;
    initialMessages?: Message[];
    userContext?: unknown;
    events?: {
        onMessageChange?: (messages: Message[]) => void;
        onMessageLoading?: (receivingMessage: boolean) => void;
        onAnswerAborted?: (aborted: true) => void;
        onSourceChange?: <T = AnyDocument>(sources: Results<T>) => void;
        onQueryTranslated?: (query: SearchParams<AnyOrama>) => void;
        onRelatedQueries?: (relatedQueries: string[]) => void;
        onNewInteractionStarted?: (interactionId: string) => void;
        onStateChange?: (state: Interaction[]) => void;
    };
    systemPrompts?: string[];
};

declare class OramaClient<M extends boolean = true> {
    private readonly id;
    private readonly api_key;
    private readonly endpoint;
    private readonly multiIndexSearch;
    private readonly mergeResults;
    private readonly multiIndexIndexes?;
    private readonly answersApiBaseURL;
    private readonly collector?;
    private readonly cache?;
    private readonly profile;
    private searchDebounceTimer?;
    private searchRequestCounter;
    private blockSearchTillAuth;
    private heartbeat?;
    private initPromise?;
    constructor(params: IOramaClient | IOramaClientMultiSearch<M>);
    private customerUserToken;
    private searchToken;
    setAuthToken(customerAuthToken: string | null): void;
    private onAuthTokenExpired?;
    setOnAuthTokenExpired(onAuthTokenExpired: (token: string) => void): void;
    private addSearchResultsToCollector;
    search(query: ClientSearchParams, config?: SearchConfig): Promise<Nullable<OramaClientSearchResult<M>>>;
    vectorSearch(query: ClientSearchParams, config?: SearchConfig): Promise<Pick<Results<AnyDocument>, 'hits' | 'elapsed'>>;
    createAnswerSession(params?: AnswerSessionParams): AnswerSession<M>;
    startHeartBeat(config: HeartBeatConfig): void;
    stopHeartBeat(): void;
    getPop(): Promise<string>;
    private expirationTimer;
    private init;
    private fetch;
    /**
     * Methods associated with profile tracking
     */
    getIdentity(): string | undefined;
    getUserId(): string;
    getAlias(): string | undefined;
    identify(identity: string): Promise<void>;
    alias(alias: string): Promise<void>;
    reset(): void;
}

declare const ENDPOINT_SNAPSHOT = "snapshot";
declare const ENDPOINT_NOTIFY = "notify";
declare const ENDPOINT_DEPLOY = "deploy";
declare const ENDPOINT_HAS_DATA = "has-data";
declare const ENDPOINT_UPDATE_SCHEMA = "update-schema";

type EndpointSnapshot = typeof ENDPOINT_SNAPSHOT;
type EndpointNotify = typeof ENDPOINT_NOTIFY;
type EndpointDeploy = typeof ENDPOINT_DEPLOY;
type EndpointHasData = typeof ENDPOINT_HAS_DATA;
type EndpointUpdateSchema = typeof ENDPOINT_UPDATE_SCHEMA;
type Endpoint = EndpointSnapshot | EndpointNotify | EndpointDeploy | EndpointHasData | EndpointUpdateSchema;

type IndexManagerParams = {
    manager: CloudManager;
    indexID: string;
};
type SnapshotData = any[] | object | unknown;
type CallWebhookPayload<E extends Endpoint> = E extends EndpointSnapshot ? SnapshotData : E extends EndpointNotify ? any[] : E extends EndpointDeploy ? undefined : E extends EndpointUpdateSchema ? {
    schema: {
        [key: string]: any;
    };
    embeddings?: any;
} : never;
declare class IndexManager {
    private manager;
    private indexId;
    constructor(params: IndexManagerParams);
    empty(): Promise<boolean>;
    snapshot(data: CallWebhookPayload<EndpointSnapshot>): Promise<boolean>;
    insert(data: CallWebhookPayload<EndpointNotify>): Promise<boolean>;
    update(data: CallWebhookPayload<EndpointNotify>): Promise<boolean>;
    delete(data: CallWebhookPayload<EndpointNotify>): Promise<boolean>;
    updateSchema(schema: CallWebhookPayload<EndpointUpdateSchema>): Promise<boolean>;
    deploy(): Promise<boolean>;
    hasPendingOperations(): Promise<boolean>;
    private checkIndexID;
    private callIndexWebhook;
}

type CloudManagerConfig = {
    api_key: string;
    baseURL?: string;
};
declare class CloudManager {
    private indexId;
    private apiKey;
    private baseURL;
    constructor(config: CloudManagerConfig);
    index(indexId: string): IndexManager;
    setIndexID(id: string): void;
    callIndexWebhook<T = unknown>(endpoint: Endpoint, payload?: T): Promise<Response>;
}

export { type AnswerParams, AnswerSession, type AnswerSessionParams, type AskParams, type CacheConfig, type ClientSearchParams, CloudManager, type Context, type Endpoint$1 as Endpoint, type HeartBeatConfig, type ICollector, type IOramaClient, type IOramaClientMultiSearch, type InferenceType, type Interaction, type Message, type Method, type Optional, OramaClient, type OramaClientSearchResult, type OramaError, type OramaInitResponse, type Override, type SearchConfig, type SearchEvent, type SearchMode, type SortByClauseUnion, type TelemetryConfig };
