{"version":3,"file":"load-matches.cjs","sources":["../../src/load-matches.ts"],"sourcesContent":["import { batch } from '@tanstack/store'\nimport invariant from 'tiny-invariant'\nimport { createControlledPromise, isPromise } from './utils'\nimport { isNotFound } from './not-found'\nimport { rootRouteId } from './root'\nimport { isRedirect } from './redirect'\nimport type { NotFoundError } from './not-found'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyRoute,\n  BeforeLoadContextOptions,\n  LoaderFnContext,\n  SsrContextOptions,\n} from './route'\nimport type { AnyRouteMatch, MakeRouteMatch } from './Matches'\nimport type { AnyRouter, UpdateMatchFn } from './router'\n\n/**\n * An object of this shape is created when calling `loadMatches`.\n * It contains everything we need for all other functions in this file\n * to work. (It's basically the function's argument, plus a few mutable states)\n */\ntype InnerLoadContext = {\n  /** the calling router instance */\n  router: AnyRouter\n  location: ParsedLocation\n  /** mutable state, scoped to a `loadMatches` call */\n  firstBadMatchIndex?: number\n  /** mutable state, scoped to a `loadMatches` call */\n  rendered?: boolean\n  updateMatch: UpdateMatchFn\n  matches: Array<AnyRouteMatch>\n  preload?: boolean\n  onReady?: () => Promise<void>\n  sync?: boolean\n  /** mutable state, scoped to a `loadMatches` call */\n  matchPromises: Array<Promise<AnyRouteMatch>>\n}\n\nconst triggerOnReady = (inner: InnerLoadContext): void | Promise<void> => {\n  if (!inner.rendered) {\n    inner.rendered = true\n    return inner.onReady?.()\n  }\n}\n\nconst resolvePreload = (inner: InnerLoadContext, matchId: string): boolean => {\n  return !!(\n    inner.preload && !inner.router.state.matches.some((d) => d.id === matchId)\n  )\n}\n\nconst _handleNotFound = (inner: InnerLoadContext, err: NotFoundError) => {\n  // Find the route that should handle the not found error\n  // First check if a specific route is requested to show the error\n  const routeCursor =\n    inner.router.routesById[err.routeId ?? ''] ?? inner.router.routeTree\n\n  // Ensure a NotFoundComponent exists on the route\n  if (\n    !routeCursor.options.notFoundComponent &&\n    (inner.router.options as any)?.defaultNotFoundComponent\n  ) {\n    routeCursor.options.notFoundComponent = (\n      inner.router.options as any\n    ).defaultNotFoundComponent\n  }\n\n  // Ensure we have a notFoundComponent\n  invariant(\n    routeCursor.options.notFoundComponent,\n    'No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.',\n  )\n\n  // Find the match for this route\n  const matchForRoute = inner.matches.find((m) => m.routeId === routeCursor.id)\n\n  invariant(matchForRoute, 'Could not find match for route: ' + routeCursor.id)\n\n  // Assign the error to the match - using non-null assertion since we've checked with invariant\n  inner.updateMatch(matchForRoute.id, (prev) => ({\n    ...prev,\n    status: 'notFound',\n    error: err,\n    isFetching: false,\n  }))\n\n  if ((err as any).routerCode === 'BEFORE_LOAD' && routeCursor.parentRoute) {\n    err.routeId = routeCursor.parentRoute.id\n    _handleNotFound(inner, err)\n  }\n}\n\nconst handleRedirectAndNotFound = (\n  inner: InnerLoadContext,\n  match: AnyRouteMatch | undefined,\n  err: unknown,\n): void => {\n  if (!isRedirect(err) && !isNotFound(err)) return\n\n  if (isRedirect(err) && err.redirectHandled && !err.options.reloadDocument) {\n    throw err\n  }\n\n  // in case of a redirecting match during preload, the match does not exist\n  if (match) {\n    match._nonReactive.beforeLoadPromise?.resolve()\n    match._nonReactive.loaderPromise?.resolve()\n    match._nonReactive.beforeLoadPromise = undefined\n    match._nonReactive.loaderPromise = undefined\n\n    const status = isRedirect(err) ? 'redirected' : 'notFound'\n\n    inner.updateMatch(match.id, (prev) => ({\n      ...prev,\n      status,\n      isFetching: false,\n      error: err,\n    }))\n\n    if (isNotFound(err) && !err.routeId) {\n      err.routeId = match.routeId\n    }\n\n    match._nonReactive.loadPromise?.resolve()\n  }\n\n  if (isRedirect(err)) {\n    inner.rendered = true\n    err.options._fromLocation = inner.location\n    err.redirectHandled = true\n    err = inner.router.resolveRedirect(err)\n    throw err\n  } else {\n    _handleNotFound(inner, err)\n    throw err\n  }\n}\n\nconst shouldSkipLoader = (\n  inner: InnerLoadContext,\n  matchId: string,\n): boolean => {\n  const match = inner.router.getMatch(matchId)!\n  // upon hydration, we skip the loader if the match has been dehydrated on the server\n  if (!inner.router.isServer && match._nonReactive.dehydrated) {\n    return true\n  }\n\n  if (inner.router.isServer && match.ssr === false) {\n    return true\n  }\n\n  return false\n}\n\nconst handleSerialError = (\n  inner: InnerLoadContext,\n  index: number,\n  err: any,\n  routerCode: string,\n): void => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  const route = inner.router.looseRoutesById[routeId]!\n\n  // Much like suspense, we use a promise here to know if\n  // we've been outdated by a new loadMatches call and\n  // should abort the current async operation\n  if (err instanceof Promise) {\n    throw err\n  }\n\n  err.routerCode = routerCode\n  inner.firstBadMatchIndex ??= index\n  handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err)\n\n  try {\n    route.options.onError?.(err)\n  } catch (errorHandlerErr) {\n    err = errorHandlerErr\n    handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err)\n  }\n\n  inner.updateMatch(matchId, (prev) => {\n    prev._nonReactive.beforeLoadPromise?.resolve()\n    prev._nonReactive.beforeLoadPromise = undefined\n    prev._nonReactive.loadPromise?.resolve()\n\n    return {\n      ...prev,\n      error: err,\n      status: 'error',\n      isFetching: false,\n      updatedAt: Date.now(),\n      abortController: new AbortController(),\n    }\n  })\n}\n\nconst isBeforeLoadSsr = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const existingMatch = inner.router.getMatch(matchId)!\n  const parentMatchId = inner.matches[index - 1]?.id\n  const parentMatch = parentMatchId\n    ? inner.router.getMatch(parentMatchId)!\n    : undefined\n\n  // in SPA mode, only SSR the root route\n  if (inner.router.isShell()) {\n    existingMatch.ssr = matchId === rootRouteId\n    return\n  }\n\n  if (parentMatch?.ssr === false) {\n    existingMatch.ssr = false\n    return\n  }\n\n  const parentOverride = (tempSsr: boolean | 'data-only') => {\n    if (tempSsr === true && parentMatch?.ssr === 'data-only') {\n      return 'data-only'\n    }\n    return tempSsr\n  }\n\n  const defaultSsr = inner.router.options.defaultSsr ?? true\n\n  if (route.options.ssr === undefined) {\n    existingMatch.ssr = parentOverride(defaultSsr)\n    return\n  }\n\n  if (typeof route.options.ssr !== 'function') {\n    existingMatch.ssr = parentOverride(route.options.ssr)\n    return\n  }\n  const { search, params } = existingMatch\n\n  const ssrFnContext: SsrContextOptions<any, any, any> = {\n    search: makeMaybe(search, existingMatch.searchError),\n    params: makeMaybe(params, existingMatch.paramsError),\n    location: inner.location,\n    matches: inner.matches.map((match) => ({\n      index: match.index,\n      pathname: match.pathname,\n      fullPath: match.fullPath,\n      staticData: match.staticData,\n      id: match.id,\n      routeId: match.routeId,\n      search: makeMaybe(match.search, match.searchError),\n      params: makeMaybe(match.params, match.paramsError),\n      ssr: match.ssr,\n    })),\n  }\n\n  const tempSsr = route.options.ssr(ssrFnContext)\n  if (isPromise(tempSsr)) {\n    return tempSsr.then((ssr) => {\n      existingMatch.ssr = parentOverride(ssr ?? defaultSsr)\n    })\n  }\n\n  existingMatch.ssr = parentOverride(tempSsr ?? defaultSsr)\n  return\n}\n\nconst setupPendingTimeout = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n  match: AnyRouteMatch,\n): void => {\n  if (match._nonReactive.pendingTimeout !== undefined) return\n\n  const pendingMs =\n    route.options.pendingMs ?? inner.router.options.defaultPendingMs\n  const shouldPending = !!(\n    inner.onReady &&\n    !inner.router.isServer &&\n    !resolvePreload(inner, matchId) &&\n    (route.options.loader ||\n      route.options.beforeLoad ||\n      routeNeedsPreload(route)) &&\n    typeof pendingMs === 'number' &&\n    pendingMs !== Infinity &&\n    (route.options.pendingComponent ??\n      (inner.router.options as any)?.defaultPendingComponent)\n  )\n\n  if (shouldPending) {\n    const pendingTimeout = setTimeout(() => {\n      // Update the match and prematurely resolve the loadMatches promise so that\n      // the pending component can start rendering\n      triggerOnReady(inner)\n    }, pendingMs)\n    match._nonReactive.pendingTimeout = pendingTimeout\n  }\n}\n\nconst preBeforeLoadSetup = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const existingMatch = inner.router.getMatch(matchId)!\n\n  // If we are in the middle of a load, either of these will be present\n  // (not to be confused with `loadPromise`, which is always defined)\n  if (\n    !existingMatch._nonReactive.beforeLoadPromise &&\n    !existingMatch._nonReactive.loaderPromise\n  )\n    return\n\n  setupPendingTimeout(inner, matchId, route, existingMatch)\n\n  const then = () => {\n    const match = inner.router.getMatch(matchId)!\n    if (\n      match.preload &&\n      (match.status === 'redirected' || match.status === 'notFound')\n    ) {\n      handleRedirectAndNotFound(inner, match, match.error)\n    }\n  }\n\n  // Wait for the previous beforeLoad to resolve before we continue\n  return existingMatch._nonReactive.beforeLoadPromise\n    ? existingMatch._nonReactive.beforeLoadPromise.then(then)\n    : then()\n}\n\nconst executeBeforeLoad = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): void | Promise<void> => {\n  const match = inner.router.getMatch(matchId)!\n\n  // explicitly capture the previous loadPromise\n  const prevLoadPromise = match._nonReactive.loadPromise\n  match._nonReactive.loadPromise = createControlledPromise<void>(() => {\n    prevLoadPromise?.resolve()\n  })\n\n  const { paramsError, searchError } = match\n\n  if (paramsError) {\n    handleSerialError(inner, index, paramsError, 'PARSE_PARAMS')\n  }\n\n  if (searchError) {\n    handleSerialError(inner, index, searchError, 'VALIDATE_SEARCH')\n  }\n\n  setupPendingTimeout(inner, matchId, route, match)\n\n  const abortController = new AbortController()\n\n  const parentMatchId = inner.matches[index - 1]?.id\n  const parentMatch = parentMatchId\n    ? inner.router.getMatch(parentMatchId)!\n    : undefined\n  const parentMatchContext =\n    parentMatch?.context ?? inner.router.options.context ?? undefined\n\n  const context = { ...parentMatchContext, ...match.__routeContext }\n\n  let isPending = false\n  const pending = () => {\n    if (isPending) return\n    isPending = true\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: 'beforeLoad',\n      fetchCount: prev.fetchCount + 1,\n      abortController,\n      context,\n    }))\n  }\n\n  const resolve = () => {\n    match._nonReactive.beforeLoadPromise?.resolve()\n    match._nonReactive.beforeLoadPromise = undefined\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: false,\n    }))\n  }\n\n  // if there is no `beforeLoad` option, skip everything, batch update the store, return early\n  if (!route.options.beforeLoad) {\n    batch(() => {\n      pending()\n      resolve()\n    })\n    return\n  }\n\n  match._nonReactive.beforeLoadPromise = createControlledPromise<void>()\n\n  const { search, params, cause } = match\n  const preload = resolvePreload(inner, matchId)\n  const beforeLoadFnContext: BeforeLoadContextOptions<any, any, any, any, any> =\n    {\n      search,\n      abortController,\n      params,\n      preload,\n      context,\n      location: inner.location,\n      navigate: (opts: any) =>\n        inner.router.navigate({\n          ...opts,\n          _fromLocation: inner.location,\n        }),\n      buildLocation: inner.router.buildLocation,\n      cause: preload ? 'preload' : cause,\n      matches: inner.matches,\n    }\n\n  const updateContext = (beforeLoadContext: any) => {\n    if (beforeLoadContext === undefined) {\n      batch(() => {\n        pending()\n        resolve()\n      })\n      return\n    }\n    if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {\n      pending()\n      handleSerialError(inner, index, beforeLoadContext, 'BEFORE_LOAD')\n    }\n\n    batch(() => {\n      pending()\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        __beforeLoadContext: beforeLoadContext,\n        context: {\n          ...prev.context,\n          ...beforeLoadContext,\n        },\n      }))\n      resolve()\n    })\n  }\n\n  let beforeLoadContext\n  try {\n    beforeLoadContext = route.options.beforeLoad(beforeLoadFnContext)\n    if (isPromise(beforeLoadContext)) {\n      pending()\n      return beforeLoadContext\n        .catch((err) => {\n          handleSerialError(inner, index, err, 'BEFORE_LOAD')\n        })\n        .then(updateContext)\n    }\n  } catch (err) {\n    pending()\n    handleSerialError(inner, index, err, 'BEFORE_LOAD')\n  }\n\n  updateContext(beforeLoadContext)\n  return\n}\n\nconst handleBeforeLoad = (\n  inner: InnerLoadContext,\n  index: number,\n): void | Promise<void> => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  const route = inner.router.looseRoutesById[routeId]!\n\n  const serverSsr = () => {\n    // on the server, determine whether SSR the current match or not\n    if (inner.router.isServer) {\n      const maybePromise = isBeforeLoadSsr(inner, matchId, index, route)\n      if (isPromise(maybePromise)) return maybePromise.then(queueExecution)\n    }\n    return queueExecution()\n  }\n\n  const queueExecution = () => {\n    if (shouldSkipLoader(inner, matchId)) return\n    const result = preBeforeLoadSetup(inner, matchId, route)\n    return isPromise(result) ? result.then(execute) : execute()\n  }\n\n  const execute = () => executeBeforeLoad(inner, matchId, index, route)\n\n  return serverSsr()\n}\n\nconst executeHead = (\n  inner: InnerLoadContext,\n  matchId: string,\n  route: AnyRoute,\n): void | Promise<\n  Pick<\n    AnyRouteMatch,\n    'meta' | 'links' | 'headScripts' | 'headers' | 'scripts' | 'styles'\n  >\n> => {\n  const match = inner.router.getMatch(matchId)\n  // in case of a redirecting match during preload, the match does not exist\n  if (!match) {\n    return\n  }\n  if (!route.options.head && !route.options.scripts && !route.options.headers) {\n    return\n  }\n  const assetContext = {\n    matches: inner.matches,\n    match,\n    params: match.params,\n    loaderData: match.loaderData,\n  }\n\n  return Promise.all([\n    route.options.head?.(assetContext),\n    route.options.scripts?.(assetContext),\n    route.options.headers?.(assetContext),\n  ]).then(([headFnContent, scripts, headers]) => {\n    const meta = headFnContent?.meta\n    const links = headFnContent?.links\n    const headScripts = headFnContent?.scripts\n    const styles = headFnContent?.styles\n\n    return {\n      meta,\n      links,\n      headScripts,\n      headers,\n      scripts,\n      styles,\n    }\n  })\n}\n\nconst getLoaderContext = (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): LoaderFnContext => {\n  const parentMatchPromise = inner.matchPromises[index - 1] as any\n  const { params, loaderDeps, abortController, context, cause } =\n    inner.router.getMatch(matchId)!\n\n  const preload = resolvePreload(inner, matchId)\n\n  return {\n    params,\n    deps: loaderDeps,\n    preload: !!preload,\n    parentMatchPromise,\n    abortController,\n    context,\n    location: inner.location,\n    navigate: (opts) =>\n      inner.router.navigate({\n        ...opts,\n        _fromLocation: inner.location,\n      }),\n    cause: preload ? 'preload' : cause,\n    route,\n  }\n}\n\nconst runLoader = async (\n  inner: InnerLoadContext,\n  matchId: string,\n  index: number,\n  route: AnyRoute,\n): Promise<void> => {\n  try {\n    // If the Matches component rendered\n    // the pending component and needs to show it for\n    // a minimum duration, we''ll wait for it to resolve\n    // before committing to the match and resolving\n    // the loadPromise\n\n    const match = inner.router.getMatch(matchId)!\n\n    // Actually run the loader and handle the result\n    try {\n      if (!inner.router.isServer || match.ssr === true) {\n        loadRouteChunk(route)\n      }\n\n      // Kick off the loader!\n      const loaderResult = route.options.loader?.(\n        getLoaderContext(inner, matchId, index, route),\n      )\n      const loaderResultIsPromise =\n        route.options.loader && isPromise(loaderResult)\n\n      const willLoadSomething = !!(\n        loaderResultIsPromise ||\n        route._lazyPromise ||\n        route._componentsPromise ||\n        route.options.head ||\n        route.options.scripts ||\n        route.options.headers ||\n        match._nonReactive.minPendingPromise\n      )\n\n      if (willLoadSomething) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          isFetching: 'loader',\n        }))\n      }\n\n      if (route.options.loader) {\n        const loaderData = loaderResultIsPromise\n          ? await loaderResult\n          : loaderResult\n\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          loaderData,\n        )\n        if (loaderData !== undefined) {\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            loaderData,\n          }))\n        }\n      }\n\n      // Lazy option can modify the route options,\n      // so we need to wait for it to resolve before\n      // we can use the options\n      if (route._lazyPromise) await route._lazyPromise\n      const headResult = executeHead(inner, matchId, route)\n      const head = headResult ? await headResult : undefined\n      const pendingPromise = match._nonReactive.minPendingPromise\n      if (pendingPromise) await pendingPromise\n\n      // Last but not least, wait for the the components\n      // to be preloaded before we resolve the match\n      if (route._componentsPromise) await route._componentsPromise\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error: undefined,\n        status: 'success',\n        isFetching: false,\n        updatedAt: Date.now(),\n        ...head,\n      }))\n    } catch (e) {\n      let error = e\n\n      const pendingPromise = match._nonReactive.minPendingPromise\n      if (pendingPromise) await pendingPromise\n\n      handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), e)\n\n      try {\n        route.options.onError?.(e)\n      } catch (onErrorError) {\n        error = onErrorError\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          onErrorError,\n        )\n      }\n      const headResult = executeHead(inner, matchId, route)\n      const head = headResult ? await headResult : undefined\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error,\n        status: 'error',\n        isFetching: false,\n        ...head,\n      }))\n    }\n  } catch (err) {\n    const match = inner.router.getMatch(matchId)\n    // in case of a redirecting match during preload, the match does not exist\n    if (match) {\n      const headResult = executeHead(inner, matchId, route)\n      if (headResult) {\n        const head = await headResult\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head,\n        }))\n      }\n      match._nonReactive.loaderPromise = undefined\n    }\n    handleRedirectAndNotFound(inner, match, err)\n  }\n}\n\nconst loadRouteMatch = async (\n  inner: InnerLoadContext,\n  index: number,\n): Promise<AnyRouteMatch> => {\n  const { id: matchId, routeId } = inner.matches[index]!\n  let loaderShouldRunAsync = false\n  let loaderIsRunningAsync = false\n  const route = inner.router.looseRoutesById[routeId]!\n\n  if (shouldSkipLoader(inner, matchId)) {\n    if (inner.router.isServer) {\n      const headResult = executeHead(inner, matchId, route)\n      if (headResult) {\n        const head = await headResult\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head,\n        }))\n      }\n      return inner.router.getMatch(matchId)!\n    }\n  } else {\n    const prevMatch = inner.router.getMatch(matchId)!\n    // there is a loaderPromise, so we are in the middle of a load\n    if (prevMatch._nonReactive.loaderPromise) {\n      // do not block if we already have stale data we can show\n      // but only if the ongoing load is not a preload since error handling is different for preloads\n      // and we don't want to swallow errors\n      if (prevMatch.status === 'success' && !inner.sync && !prevMatch.preload) {\n        return prevMatch\n      }\n      await prevMatch._nonReactive.loaderPromise\n      const match = inner.router.getMatch(matchId)!\n      if (match.error) {\n        handleRedirectAndNotFound(inner, match, match.error)\n      }\n    } else {\n      // This is where all of the stale-while-revalidate magic happens\n      const age = Date.now() - prevMatch.updatedAt\n\n      const preload = resolvePreload(inner, matchId)\n\n      const staleAge = preload\n        ? (route.options.preloadStaleTime ??\n          inner.router.options.defaultPreloadStaleTime ??\n          30_000) // 30 seconds for preloads by default\n        : (route.options.staleTime ??\n          inner.router.options.defaultStaleTime ??\n          0)\n\n      const shouldReloadOption = route.options.shouldReload\n\n      // Default to reloading the route all the time\n      // Allow shouldReload to get the last say,\n      // if provided.\n      const shouldReload =\n        typeof shouldReloadOption === 'function'\n          ? shouldReloadOption(getLoaderContext(inner, matchId, index, route))\n          : shouldReloadOption\n\n      const nextPreload =\n        !!preload && !inner.router.state.matches.some((d) => d.id === matchId)\n      const match = inner.router.getMatch(matchId)!\n      match._nonReactive.loaderPromise = createControlledPromise<void>()\n      if (nextPreload !== match.preload) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          preload: nextPreload,\n        }))\n      }\n\n      // If the route is successful and still fresh, just resolve\n      const { status, invalid } = match\n      loaderShouldRunAsync =\n        status === 'success' && (invalid || (shouldReload ?? age > staleAge))\n      if (preload && route.options.preload === false) {\n        // Do nothing\n      } else if (loaderShouldRunAsync && !inner.sync) {\n        loaderIsRunningAsync = true\n        ;(async () => {\n          try {\n            await runLoader(inner, matchId, index, route)\n            const match = inner.router.getMatch(matchId)!\n            match._nonReactive.loaderPromise?.resolve()\n            match._nonReactive.loadPromise?.resolve()\n            match._nonReactive.loaderPromise = undefined\n          } catch (err) {\n            if (isRedirect(err)) {\n              await inner.router.navigate(err.options)\n            }\n          }\n        })()\n      } else if (status !== 'success' || (loaderShouldRunAsync && inner.sync)) {\n        await runLoader(inner, matchId, index, route)\n      } else {\n        // if the loader did not run, still update head.\n        // reason: parent's beforeLoad may have changed the route context\n        // and only now do we know the route context (and that the loader would not run)\n        const headResult = executeHead(inner, matchId, route)\n        if (headResult) {\n          const head = await headResult\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            ...head,\n          }))\n        }\n      }\n    }\n  }\n  const match = inner.router.getMatch(matchId)!\n  if (!loaderIsRunningAsync) {\n    match._nonReactive.loaderPromise?.resolve()\n    match._nonReactive.loadPromise?.resolve()\n  }\n\n  clearTimeout(match._nonReactive.pendingTimeout)\n  match._nonReactive.pendingTimeout = undefined\n  if (!loaderIsRunningAsync) match._nonReactive.loaderPromise = undefined\n  match._nonReactive.dehydrated = undefined\n  const nextIsFetching = loaderIsRunningAsync ? match.isFetching : false\n  if (nextIsFetching !== match.isFetching || match.invalid !== false) {\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: nextIsFetching,\n      invalid: false,\n    }))\n    return inner.router.getMatch(matchId)!\n  } else {\n    return match\n  }\n}\n\nexport async function loadMatches(arg: {\n  router: AnyRouter\n  location: ParsedLocation\n  matches: Array<AnyRouteMatch>\n  preload?: boolean\n  onReady?: () => Promise<void>\n  updateMatch: UpdateMatchFn\n  sync?: boolean\n}): Promise<Array<MakeRouteMatch>> {\n  const inner: InnerLoadContext = Object.assign(arg, {\n    matchPromises: [],\n  })\n\n  // make sure the pending component is immediately rendered when hydrating a match that is not SSRed\n  // the pending component was already rendered on the server and we want to keep it shown on the client until minPendingMs is reached\n  if (\n    !inner.router.isServer &&\n    inner.router.state.matches.some((d) => d._forcePending)\n  ) {\n    triggerOnReady(inner)\n  }\n\n  try {\n    // Execute all beforeLoads one by one\n    for (let i = 0; i < inner.matches.length; i++) {\n      const beforeLoad = handleBeforeLoad(inner, i)\n      if (isPromise(beforeLoad)) await beforeLoad\n    }\n\n    // Execute all loaders in parallel\n    const max = inner.firstBadMatchIndex ?? inner.matches.length\n    for (let i = 0; i < max; i++) {\n      inner.matchPromises.push(loadRouteMatch(inner, i))\n    }\n    await Promise.all(inner.matchPromises)\n\n    const readyPromise = triggerOnReady(inner)\n    if (isPromise(readyPromise)) await readyPromise\n  } catch (err) {\n    if (isNotFound(err) && !inner.preload) {\n      const readyPromise = triggerOnReady(inner)\n      if (isPromise(readyPromise)) await readyPromise\n      throw err\n    }\n    if (isRedirect(err)) {\n      throw err\n    }\n  }\n\n  return inner.matches\n}\n\nexport async function loadRouteChunk(route: AnyRoute) {\n  if (!route._lazyLoaded && route._lazyPromise === undefined) {\n    if (route.lazyFn) {\n      route._lazyPromise = route.lazyFn().then((lazyRoute) => {\n        // explicitly don't copy over the lazy route's id\n        const { id: _id, ...options } = lazyRoute.options\n        Object.assign(route.options, options)\n        route._lazyLoaded = true\n        route._lazyPromise = undefined // gc promise, we won't need it anymore\n      })\n    } else {\n      route._lazyLoaded = true\n    }\n  }\n\n  // If for some reason lazy resolves more lazy components...\n  // We'll wait for that before we attempt to preload the\n  // components themselves.\n  if (!route._componentsLoaded && route._componentsPromise === undefined) {\n    const loadComponents = () => {\n      const preloads = []\n      for (const type of componentTypes) {\n        const preload = (route.options[type] as any)?.preload\n        if (preload) preloads.push(preload())\n      }\n      if (preloads.length)\n        return Promise.all(preloads).then(() => {\n          route._componentsLoaded = true\n          route._componentsPromise = undefined // gc promise, we won't need it anymore\n        })\n      route._componentsLoaded = true\n      route._componentsPromise = undefined // gc promise, we won't need it anymore\n      return\n    }\n    route._componentsPromise = route._lazyPromise\n      ? route._lazyPromise.then(loadComponents)\n      : loadComponents()\n  }\n  return route._componentsPromise\n}\n\nfunction makeMaybe<TValue, TError>(\n  value: TValue,\n  error: TError,\n): { status: 'success'; value: TValue } | { status: 'error'; error: TError } {\n  if (error) {\n    return { status: 'error' as const, error }\n  }\n  return { status: 'success' as const, value }\n}\n\nexport function routeNeedsPreload(route: AnyRoute) {\n  for (const componentType of componentTypes) {\n    if ((route.options[componentType] as any)?.preload) {\n      return true\n    }\n  }\n  return false\n}\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n"],"names":["isRedirect","isNotFound","_a","_b","rootRouteId","tempSsr","isPromise","createControlledPromise","batch","beforeLoadContext","match"],"mappings":";;;;;;;;AAuCA,MAAM,iBAAiB,CAAC,UAAkD;;AACpE,MAAA,CAAC,MAAM,UAAU;AACnB,UAAM,WAAW;AACjB,YAAO,WAAM,YAAN;AAAA,EAAgB;AAE3B;AAEA,MAAM,iBAAiB,CAAC,OAAyB,YAA6B;AAC5E,SAAO,CAAC,EACN,MAAM,WAAW,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AAE7E;AAEA,MAAM,kBAAkB,CAAC,OAAyB,QAAuB;;AAGjE,QAAA,cACJ,MAAM,OAAO,WAAW,IAAI,WAAW,EAAE,KAAK,MAAM,OAAO;AAG7D,MACE,CAAC,YAAY,QAAQ,uBACpB,WAAM,OAAO,YAAb,mBAA8B,2BAC/B;AACA,gBAAY,QAAQ,oBAClB,MAAM,OAAO,QACb;AAAA,EAAA;AAIJ;AAAA,IACE,YAAY,QAAQ;AAAA,IACpB;AAAA,EACF;AAGM,QAAA,gBAAgB,MAAM,QAAQ,KAAK,CAAC,MAAM,EAAE,YAAY,YAAY,EAAE;AAElE,YAAA,eAAe,qCAAqC,YAAY,EAAE;AAG5E,QAAM,YAAY,cAAc,IAAI,CAAC,UAAU;AAAA,IAC7C,GAAG;AAAA,IACH,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,YAAY;AAAA,EAAA,EACZ;AAEF,MAAK,IAAY,eAAe,iBAAiB,YAAY,aAAa;AACpE,QAAA,UAAU,YAAY,YAAY;AACtC,oBAAgB,OAAO,GAAG;AAAA,EAAA;AAE9B;AAEA,MAAM,4BAA4B,CAChC,OACA,OACA,QACS;;AACT,MAAI,CAACA,SAAW,WAAA,GAAG,KAAK,CAACC,SAAA,WAAW,GAAG,EAAG;AAEtC,MAAAD,SAAA,WAAW,GAAG,KAAK,IAAI,mBAAmB,CAAC,IAAI,QAAQ,gBAAgB;AACnE,UAAA;AAAA,EAAA;AAIR,MAAI,OAAO;AACH,gBAAA,aAAa,sBAAb,mBAAgC;AAChC,gBAAA,aAAa,kBAAb,mBAA4B;AAClC,UAAM,aAAa,oBAAoB;AACvC,UAAM,aAAa,gBAAgB;AAEnC,UAAM,SAASA,SAAA,WAAW,GAAG,IAAI,eAAe;AAEhD,UAAM,YAAY,MAAM,IAAI,CAAC,UAAU;AAAA,MACrC,GAAG;AAAA,MACH;AAAA,MACA,YAAY;AAAA,MACZ,OAAO;AAAA,IAAA,EACP;AAEF,QAAIC,SAAW,WAAA,GAAG,KAAK,CAAC,IAAI,SAAS;AACnC,UAAI,UAAU,MAAM;AAAA,IAAA;AAGhB,gBAAA,aAAa,gBAAb,mBAA0B;AAAA,EAAQ;AAGtC,MAAAD,SAAAA,WAAW,GAAG,GAAG;AACnB,UAAM,WAAW;AACb,QAAA,QAAQ,gBAAgB,MAAM;AAClC,QAAI,kBAAkB;AAChB,UAAA,MAAM,OAAO,gBAAgB,GAAG;AAChC,UAAA;AAAA,EAAA,OACD;AACL,oBAAgB,OAAO,GAAG;AACpB,UAAA;AAAA,EAAA;AAEV;AAEA,MAAM,mBAAmB,CACvB,OACA,YACY;AACZ,QAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAE3C,MAAI,CAAC,MAAM,OAAO,YAAY,MAAM,aAAa,YAAY;AACpD,WAAA;AAAA,EAAA;AAGT,MAAI,MAAM,OAAO,YAAY,MAAM,QAAQ,OAAO;AACzC,WAAA;AAAA,EAAA;AAGF,SAAA;AACT;AAEA,MAAM,oBAAoB,CACxB,OACA,OACA,KACA,eACS;;AACT,QAAM,EAAE,IAAI,SAAS,QAAY,IAAA,MAAM,QAAQ,KAAK;AACpD,QAAM,QAAQ,MAAM,OAAO,gBAAgB,OAAO;AAKlD,MAAI,eAAe,SAAS;AACpB,UAAA;AAAA,EAAA;AAGR,MAAI,aAAa;AACjB,QAAM,uBAAN,MAAM,qBAAuB;AAC7B,4BAA0B,OAAO,MAAM,OAAO,SAAS,OAAO,GAAG,GAAG;AAEhE,MAAA;AACI,sBAAA,SAAQ,YAAR,4BAAkB;AAAA,WACjB,iBAAiB;AAClB,UAAA;AACN,8BAA0B,OAAO,MAAM,OAAO,SAAS,OAAO,GAAG,GAAG;AAAA,EAAA;AAGhE,QAAA,YAAY,SAAS,CAAC,SAAS;;AAC9B,KAAAE,MAAA,KAAA,aAAa,sBAAb,gBAAAA,IAAgC;AACrC,SAAK,aAAa,oBAAoB;AACjC,KAAAC,MAAA,KAAA,aAAa,gBAAb,gBAAAA,IAA0B;AAExB,WAAA;AAAA,MACL,GAAG;AAAA,MACH,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,YAAY;AAAA,MACZ,WAAW,KAAK,IAAI;AAAA,MACpB,iBAAiB,IAAI,gBAAgB;AAAA,IACvC;AAAA,EAAA,CACD;AACH;AAEA,MAAM,kBAAkB,CACtB,OACA,SACA,OACA,UACyB;;AACzB,QAAM,gBAAgB,MAAM,OAAO,SAAS,OAAO;AACnD,QAAM,iBAAgB,WAAM,QAAQ,QAAQ,CAAC,MAAvB,mBAA0B;AAChD,QAAM,cAAc,gBAChB,MAAM,OAAO,SAAS,aAAa,IACnC;AAGA,MAAA,MAAM,OAAO,WAAW;AAC1B,kBAAc,MAAM,YAAYC,KAAA;AAChC;AAAA,EAAA;AAGE,OAAA,2CAAa,SAAQ,OAAO;AAC9B,kBAAc,MAAM;AACpB;AAAA,EAAA;AAGI,QAAA,iBAAiB,CAACC,aAAmC;AACzD,QAAIA,aAAY,SAAQ,2CAAa,SAAQ,aAAa;AACjD,aAAA;AAAA,IAAA;AAEFA,WAAAA;AAAAA,EACT;AAEA,QAAM,aAAa,MAAM,OAAO,QAAQ,cAAc;AAElD,MAAA,MAAM,QAAQ,QAAQ,QAAW;AACrB,kBAAA,MAAM,eAAe,UAAU;AAC7C;AAAA,EAAA;AAGF,MAAI,OAAO,MAAM,QAAQ,QAAQ,YAAY;AAC3C,kBAAc,MAAM,eAAe,MAAM,QAAQ,GAAG;AACpD;AAAA,EAAA;AAEI,QAAA,EAAE,QAAQ,OAAA,IAAW;AAE3B,QAAM,eAAiD;AAAA,IACrD,QAAQ,UAAU,QAAQ,cAAc,WAAW;AAAA,IACnD,QAAQ,UAAU,QAAQ,cAAc,WAAW;AAAA,IACnD,UAAU,MAAM;AAAA,IAChB,SAAS,MAAM,QAAQ,IAAI,CAAC,WAAW;AAAA,MACrC,OAAO,MAAM;AAAA,MACb,UAAU,MAAM;AAAA,MAChB,UAAU,MAAM;AAAA,MAChB,YAAY,MAAM;AAAA,MAClB,IAAI,MAAM;AAAA,MACV,SAAS,MAAM;AAAA,MACf,QAAQ,UAAU,MAAM,QAAQ,MAAM,WAAW;AAAA,MACjD,QAAQ,UAAU,MAAM,QAAQ,MAAM,WAAW;AAAA,MACjD,KAAK,MAAM;AAAA,IAAA,EACX;AAAA,EACJ;AAEA,QAAM,UAAU,MAAM,QAAQ,IAAI,YAAY;AAC1C,MAAAC,MAAAA,UAAU,OAAO,GAAG;AACf,WAAA,QAAQ,KAAK,CAAC,QAAQ;AACb,oBAAA,MAAM,eAAe,OAAO,UAAU;AAAA,IAAA,CACrD;AAAA,EAAA;AAGW,gBAAA,MAAM,eAAe,WAAW,UAAU;AACxD;AACF;AAEA,MAAM,sBAAsB,CAC1B,OACA,SACA,OACA,UACS;;AACL,MAAA,MAAM,aAAa,mBAAmB,OAAW;AAErD,QAAM,YACJ,MAAM,QAAQ,aAAa,MAAM,OAAO,QAAQ;AAClD,QAAM,gBAAgB,CAAC,EACrB,MAAM,WACN,CAAC,MAAM,OAAO,YACd,CAAC,eAAe,OAAO,OAAO,MAC7B,MAAM,QAAQ,UACb,MAAM,QAAQ,cACd,kBAAkB,KAAK,MACzB,OAAO,cAAc,YACrB,cAAc,aACb,MAAM,QAAQ,sBACZ,WAAM,OAAO,YAAb,mBAA8B;AAGnC,MAAI,eAAe;AACX,UAAA,iBAAiB,WAAW,MAAM;AAGtC,qBAAe,KAAK;AAAA,OACnB,SAAS;AACZ,UAAM,aAAa,iBAAiB;AAAA,EAAA;AAExC;AAEA,MAAM,qBAAqB,CACzB,OACA,SACA,UACyB;AACzB,QAAM,gBAAgB,MAAM,OAAO,SAAS,OAAO;AAInD,MACE,CAAC,cAAc,aAAa,qBAC5B,CAAC,cAAc,aAAa;AAE5B;AAEkB,sBAAA,OAAO,SAAS,OAAO,aAAa;AAExD,QAAM,OAAO,MAAM;AACjB,UAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAC3C,QACE,MAAM,YACL,MAAM,WAAW,gBAAgB,MAAM,WAAW,aACnD;AAC0B,gCAAA,OAAO,OAAO,MAAM,KAAK;AAAA,IAAA;AAAA,EAEvD;AAGO,SAAA,cAAc,aAAa,oBAC9B,cAAc,aAAa,kBAAkB,KAAK,IAAI,IACtD,KAAK;AACX;AAEA,MAAM,oBAAoB,CACxB,OACA,SACA,OACA,UACyB;;AACzB,QAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAGrC,QAAA,kBAAkB,MAAM,aAAa;AACrC,QAAA,aAAa,cAAcC,MAAAA,wBAA8B,MAAM;AACnE,uDAAiB;AAAA,EAAQ,CAC1B;AAEK,QAAA,EAAE,aAAa,YAAA,IAAgB;AAErC,MAAI,aAAa;AACG,sBAAA,OAAO,OAAO,aAAa,cAAc;AAAA,EAAA;AAG7D,MAAI,aAAa;AACG,sBAAA,OAAO,OAAO,aAAa,iBAAiB;AAAA,EAAA;AAG5C,sBAAA,OAAO,SAAS,OAAO,KAAK;AAE1C,QAAA,kBAAkB,IAAI,gBAAgB;AAE5C,QAAM,iBAAgB,WAAM,QAAQ,QAAQ,CAAC,MAAvB,mBAA0B;AAChD,QAAM,cAAc,gBAChB,MAAM,OAAO,SAAS,aAAa,IACnC;AACJ,QAAM,sBACJ,2CAAa,YAAW,MAAM,OAAO,QAAQ,WAAW;AAE1D,QAAM,UAAU,EAAE,GAAG,oBAAoB,GAAG,MAAM,eAAe;AAEjE,MAAI,YAAY;AAChB,QAAM,UAAU,MAAM;AACpB,QAAI,UAAW;AACH,gBAAA;AACN,UAAA,YAAY,SAAS,CAAC,UAAU;AAAA,MACpC,GAAG;AAAA,MACH,YAAY;AAAA,MACZ,YAAY,KAAK,aAAa;AAAA,MAC9B;AAAA,MACA;AAAA,IAAA,EACA;AAAA,EACJ;AAEA,QAAM,UAAU,MAAM;;AACd,KAAAL,MAAA,MAAA,aAAa,sBAAb,gBAAAA,IAAgC;AACtC,UAAM,aAAa,oBAAoB;AACjC,UAAA,YAAY,SAAS,CAAC,UAAU;AAAA,MACpC,GAAG;AAAA,MACH,YAAY;AAAA,IAAA,EACZ;AAAA,EACJ;AAGI,MAAA,CAAC,MAAM,QAAQ,YAAY;AAC7BM,UAAAA,MAAM,MAAM;AACF,cAAA;AACA,cAAA;AAAA,IAAA,CACT;AACD;AAAA,EAAA;AAGI,QAAA,aAAa,oBAAoBD,8BAA8B;AAErE,QAAM,EAAE,QAAQ,QAAQ,MAAU,IAAA;AAC5B,QAAA,UAAU,eAAe,OAAO,OAAO;AAC7C,QAAM,sBACJ;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,MAAM;AAAA,IAChB,UAAU,CAAC,SACT,MAAM,OAAO,SAAS;AAAA,MACpB,GAAG;AAAA,MACH,eAAe,MAAM;AAAA,IAAA,CACtB;AAAA,IACH,eAAe,MAAM,OAAO;AAAA,IAC5B,OAAO,UAAU,YAAY;AAAA,IAC7B,SAAS,MAAM;AAAA,EACjB;AAEI,QAAA,gBAAgB,CAACE,uBAA2B;AAChD,QAAIA,uBAAsB,QAAW;AACnCD,YAAAA,MAAM,MAAM;AACF,gBAAA;AACA,gBAAA;AAAA,MAAA,CACT;AACD;AAAA,IAAA;AAEF,QAAIR,SAAWS,WAAAA,kBAAiB,KAAKR,SAAA,WAAWQ,kBAAiB,GAAG;AAC1D,cAAA;AACU,wBAAA,OAAO,OAAOA,oBAAmB,aAAa;AAAA,IAAA;AAGlED,UAAAA,MAAM,MAAM;AACF,cAAA;AACF,YAAA,YAAY,SAAS,CAAC,UAAU;AAAA,QACpC,GAAG;AAAA,QACH,qBAAqBC;AAAAA,QACrB,SAAS;AAAA,UACP,GAAG,KAAK;AAAA,UACR,GAAGA;AAAAA,QAAA;AAAA,MACL,EACA;AACM,cAAA;AAAA,IAAA,CACT;AAAA,EACH;AAEI,MAAA;AACA,MAAA;AACkB,wBAAA,MAAM,QAAQ,WAAW,mBAAmB;AAC5D,QAAAH,MAAAA,UAAU,iBAAiB,GAAG;AACxB,cAAA;AACD,aAAA,kBACJ,MAAM,CAAC,QAAQ;AACI,0BAAA,OAAO,OAAO,KAAK,aAAa;AAAA,MAAA,CACnD,EACA,KAAK,aAAa;AAAA,IAAA;AAAA,WAEhB,KAAK;AACJ,YAAA;AACU,sBAAA,OAAO,OAAO,KAAK,aAAa;AAAA,EAAA;AAGpD,gBAAc,iBAAiB;AAC/B;AACF;AAEA,MAAM,mBAAmB,CACvB,OACA,UACyB;AACzB,QAAM,EAAE,IAAI,SAAS,QAAY,IAAA,MAAM,QAAQ,KAAK;AACpD,QAAM,QAAQ,MAAM,OAAO,gBAAgB,OAAO;AAElD,QAAM,YAAY,MAAM;AAElB,QAAA,MAAM,OAAO,UAAU;AACzB,YAAM,eAAe,gBAAgB,OAAO,SAAS,OAAO,KAAK;AACjE,UAAIA,MAAAA,UAAU,YAAY,EAAU,QAAA,aAAa,KAAK,cAAc;AAAA,IAAA;AAEtE,WAAO,eAAe;AAAA,EACxB;AAEA,QAAM,iBAAiB,MAAM;AACvB,QAAA,iBAAiB,OAAO,OAAO,EAAG;AACtC,UAAM,SAAS,mBAAmB,OAAO,SAAS,KAAK;AACvD,WAAOA,MAAAA,UAAU,MAAM,IAAI,OAAO,KAAK,OAAO,IAAI,QAAQ;AAAA,EAC5D;AAEA,QAAM,UAAU,MAAM,kBAAkB,OAAO,SAAS,OAAO,KAAK;AAEpE,SAAO,UAAU;AACnB;AAEA,MAAM,cAAc,CAClB,OACA,SACA,UAMG;;AACH,QAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAE3C,MAAI,CAAC,OAAO;AACV;AAAA,EAAA;AAEE,MAAA,CAAC,MAAM,QAAQ,QAAQ,CAAC,MAAM,QAAQ,WAAW,CAAC,MAAM,QAAQ,SAAS;AAC3E;AAAA,EAAA;AAEF,QAAM,eAAe;AAAA,IACnB,SAAS,MAAM;AAAA,IACf;AAAA,IACA,QAAQ,MAAM;AAAA,IACd,YAAY,MAAM;AAAA,EACpB;AAEA,SAAO,QAAQ,IAAI;AAAA,KACjB,iBAAM,SAAQ,SAAd,4BAAqB;AAAA,KACrB,iBAAM,SAAQ,YAAd,4BAAwB;AAAA,KACxB,iBAAM,SAAQ,YAAd,4BAAwB;AAAA,EAAY,CACrC,EAAE,KAAK,CAAC,CAAC,eAAe,SAAS,OAAO,MAAM;AAC7C,UAAM,OAAO,+CAAe;AAC5B,UAAM,QAAQ,+CAAe;AAC7B,UAAM,cAAc,+CAAe;AACnC,UAAM,SAAS,+CAAe;AAEvB,WAAA;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EAAA,CACD;AACH;AAEA,MAAM,mBAAmB,CACvB,OACA,SACA,OACA,UACoB;AACpB,QAAM,qBAAqB,MAAM,cAAc,QAAQ,CAAC;AAClD,QAAA,EAAE,QAAQ,YAAY,iBAAiB,SAAS,MACpD,IAAA,MAAM,OAAO,SAAS,OAAO;AAEzB,QAAA,UAAU,eAAe,OAAO,OAAO;AAEtC,SAAA;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN,SAAS,CAAC,CAAC;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,MAAM;AAAA,IAChB,UAAU,CAAC,SACT,MAAM,OAAO,SAAS;AAAA,MACpB,GAAG;AAAA,MACH,eAAe,MAAM;AAAA,IAAA,CACtB;AAAA,IACH,OAAO,UAAU,YAAY;AAAA,IAC7B;AAAA,EACF;AACF;AAEA,MAAM,YAAY,OAChB,OACA,SACA,OACA,UACkB;;AACd,MAAA;AAOF,UAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAGvC,QAAA;AACF,UAAI,CAAC,MAAM,OAAO,YAAY,MAAM,QAAQ,MAAM;AAChD,uBAAe,KAAK;AAAA,MAAA;AAIhB,YAAA,gBAAe,iBAAM,SAAQ,WAAd;AAAA;AAAA,QACnB,iBAAiB,OAAO,SAAS,OAAO,KAAK;AAAA;AAE/C,YAAM,wBACJ,MAAM,QAAQ,UAAUA,MAAAA,UAAU,YAAY;AAEhD,YAAM,oBAAoB,CAAC,EACzB,yBACA,MAAM,gBACN,MAAM,sBACN,MAAM,QAAQ,QACd,MAAM,QAAQ,WACd,MAAM,QAAQ,WACd,MAAM,aAAa;AAGrB,UAAI,mBAAmB;AACf,cAAA,YAAY,SAAS,CAAC,UAAU;AAAA,UACpC,GAAG;AAAA,UACH,YAAY;AAAA,QAAA,EACZ;AAAA,MAAA;AAGA,UAAA,MAAM,QAAQ,QAAQ;AAClB,cAAA,aAAa,wBACf,MAAM,eACN;AAEJ;AAAA,UACE;AAAA,UACA,MAAM,OAAO,SAAS,OAAO;AAAA,UAC7B;AAAA,QACF;AACA,YAAI,eAAe,QAAW;AACtB,gBAAA,YAAY,SAAS,CAAC,UAAU;AAAA,YACpC,GAAG;AAAA,YACH;AAAA,UAAA,EACA;AAAA,QAAA;AAAA,MACJ;AAME,UAAA,MAAM,aAAc,OAAM,MAAM;AACpC,YAAM,aAAa,YAAY,OAAO,SAAS,KAAK;AAC9C,YAAA,OAAO,aAAa,MAAM,aAAa;AACvC,YAAA,iBAAiB,MAAM,aAAa;AAC1C,UAAI,eAAsB,OAAA;AAItB,UAAA,MAAM,mBAAoB,OAAM,MAAM;AACpC,YAAA,YAAY,SAAS,CAAC,UAAU;AAAA,QACpC,GAAG;AAAA,QACH,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,WAAW,KAAK,IAAI;AAAA,QACpB,GAAG;AAAA,MAAA,EACH;AAAA,aACK,GAAG;AACV,UAAI,QAAQ;AAEN,YAAA,iBAAiB,MAAM,aAAa;AAC1C,UAAI,eAAsB,OAAA;AAE1B,gCAA0B,OAAO,MAAM,OAAO,SAAS,OAAO,GAAG,CAAC;AAE9D,UAAA;AACI,0BAAA,SAAQ,YAAR,4BAAkB;AAAA,eACjB,cAAc;AACb,gBAAA;AACR;AAAA,UACE;AAAA,UACA,MAAM,OAAO,SAAS,OAAO;AAAA,UAC7B;AAAA,QACF;AAAA,MAAA;AAEF,YAAM,aAAa,YAAY,OAAO,SAAS,KAAK;AAC9C,YAAA,OAAO,aAAa,MAAM,aAAa;AACvC,YAAA,YAAY,SAAS,CAAC,UAAU;AAAA,QACpC,GAAG;AAAA,QACH;AAAA,QACA,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,GAAG;AAAA,MAAA,EACH;AAAA,IAAA;AAAA,WAEG,KAAK;AACZ,UAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAE3C,QAAI,OAAO;AACT,YAAM,aAAa,YAAY,OAAO,SAAS,KAAK;AACpD,UAAI,YAAY;AACd,cAAM,OAAO,MAAM;AACb,cAAA,YAAY,SAAS,CAAC,UAAU;AAAA,UACpC,GAAG;AAAA,UACH,GAAG;AAAA,QAAA,EACH;AAAA,MAAA;AAEJ,YAAM,aAAa,gBAAgB;AAAA,IAAA;AAEX,8BAAA,OAAO,OAAO,GAAG;AAAA,EAAA;AAE/C;AAEA,MAAM,iBAAiB,OACrB,OACA,UAC2B;;AAC3B,QAAM,EAAE,IAAI,SAAS,QAAY,IAAA,MAAM,QAAQ,KAAK;AACpD,MAAI,uBAAuB;AAC3B,MAAI,uBAAuB;AAC3B,QAAM,QAAQ,MAAM,OAAO,gBAAgB,OAAO;AAE9C,MAAA,iBAAiB,OAAO,OAAO,GAAG;AAChC,QAAA,MAAM,OAAO,UAAU;AACzB,YAAM,aAAa,YAAY,OAAO,SAAS,KAAK;AACpD,UAAI,YAAY;AACd,cAAM,OAAO,MAAM;AACb,cAAA,YAAY,SAAS,CAAC,UAAU;AAAA,UACpC,GAAG;AAAA,UACH,GAAG;AAAA,QAAA,EACH;AAAA,MAAA;AAEG,aAAA,MAAM,OAAO,SAAS,OAAO;AAAA,IAAA;AAAA,EACtC,OACK;AACL,UAAM,YAAY,MAAM,OAAO,SAAS,OAAO;AAE3C,QAAA,UAAU,aAAa,eAAe;AAIpC,UAAA,UAAU,WAAW,aAAa,CAAC,MAAM,QAAQ,CAAC,UAAU,SAAS;AAChE,eAAA;AAAA,MAAA;AAET,YAAM,UAAU,aAAa;AAC7B,YAAMI,SAAQ,MAAM,OAAO,SAAS,OAAO;AAC3C,UAAIA,OAAM,OAAO;AACW,kCAAA,OAAOA,QAAOA,OAAM,KAAK;AAAA,MAAA;AAAA,IACrD,OACK;AAEL,YAAM,MAAM,KAAK,IAAI,IAAI,UAAU;AAE7B,YAAA,UAAU,eAAe,OAAO,OAAO;AAE7C,YAAM,WAAW,UACZ,MAAM,QAAQ,oBACf,MAAM,OAAO,QAAQ,2BACrB,MACC,MAAM,QAAQ,aACf,MAAM,OAAO,QAAQ,oBACrB;AAEE,YAAA,qBAAqB,MAAM,QAAQ;AAKnC,YAAA,eACJ,OAAO,uBAAuB,aAC1B,mBAAmB,iBAAiB,OAAO,SAAS,OAAO,KAAK,CAAC,IACjE;AAEN,YAAM,cACJ,CAAC,CAAC,WAAW,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,CAAC,MAAM,EAAE,OAAO,OAAO;AACvE,YAAMA,SAAQ,MAAM,OAAO,SAAS,OAAO;AAC3CA,aAAM,aAAa,gBAAgBH,8BAA8B;AAC7D,UAAA,gBAAgBG,OAAM,SAAS;AAC3B,cAAA,YAAY,SAAS,CAAC,UAAU;AAAA,UACpC,GAAG;AAAA,UACH,SAAS;AAAA,QAAA,EACT;AAAA,MAAA;AAIE,YAAA,EAAE,QAAQ,QAAA,IAAYA;AAC5B,6BACE,WAAW,cAAc,YAAY,gBAAgB,MAAM;AAC7D,UAAI,WAAW,MAAM,QAAQ,YAAY,MAAO;AAAA,eAErC,wBAAwB,CAAC,MAAM,MAAM;AACvB,+BAAA;AACtB,SAAC,YAAY;;AACR,cAAA;AACF,kBAAM,UAAU,OAAO,SAAS,OAAO,KAAK;AAC5C,kBAAMA,SAAQ,MAAM,OAAO,SAAS,OAAO;AAC3CA,aAAAA,MAAAA,OAAM,aAAa,kBAAnBA,gBAAAA,IAAkC;AAClCA,aAAAA,MAAAA,OAAM,aAAa,gBAAnBA,gBAAAA,IAAgC;AAChCA,mBAAM,aAAa,gBAAgB;AAAA,mBAC5B,KAAK;AACR,gBAAAV,SAAAA,WAAW,GAAG,GAAG;AACnB,oBAAM,MAAM,OAAO,SAAS,IAAI,OAAO;AAAA,YAAA;AAAA,UACzC;AAAA,QACF,GACC;AAAA,MACM,WAAA,WAAW,aAAc,wBAAwB,MAAM,MAAO;AACvE,cAAM,UAAU,OAAO,SAAS,OAAO,KAAK;AAAA,MAAA,OACvC;AAIL,cAAM,aAAa,YAAY,OAAO,SAAS,KAAK;AACpD,YAAI,YAAY;AACd,gBAAM,OAAO,MAAM;AACb,gBAAA,YAAY,SAAS,CAAC,UAAU;AAAA,YACpC,GAAG;AAAA,YACH,GAAG;AAAA,UAAA,EACH;AAAA,QAAA;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAEF,QAAM,QAAQ,MAAM,OAAO,SAAS,OAAO;AAC3C,MAAI,CAAC,sBAAsB;AACnB,gBAAA,aAAa,kBAAb,mBAA4B;AAC5B,gBAAA,aAAa,gBAAb,mBAA0B;AAAA,EAAQ;AAG7B,eAAA,MAAM,aAAa,cAAc;AAC9C,QAAM,aAAa,iBAAiB;AACpC,MAAI,CAAC,qBAA4B,OAAA,aAAa,gBAAgB;AAC9D,QAAM,aAAa,aAAa;AAC1B,QAAA,iBAAiB,uBAAuB,MAAM,aAAa;AACjE,MAAI,mBAAmB,MAAM,cAAc,MAAM,YAAY,OAAO;AAC5D,UAAA,YAAY,SAAS,CAAC,UAAU;AAAA,MACpC,GAAG;AAAA,MACH,YAAY;AAAA,MACZ,SAAS;AAAA,IAAA,EACT;AACK,WAAA,MAAM,OAAO,SAAS,OAAO;AAAA,EAAA,OAC/B;AACE,WAAA;AAAA,EAAA;AAEX;AAEA,eAAsB,YAAY,KAQC;AAC3B,QAAA,QAA0B,OAAO,OAAO,KAAK;AAAA,IACjD,eAAe,CAAA;AAAA,EAAC,CACjB;AAID,MACE,CAAC,MAAM,OAAO,YACd,MAAM,OAAO,MAAM,QAAQ,KAAK,CAAC,MAAM,EAAE,aAAa,GACtD;AACA,mBAAe,KAAK;AAAA,EAAA;AAGlB,MAAA;AAEF,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,QAAQ,KAAK;AACvC,YAAA,aAAa,iBAAiB,OAAO,CAAC;AACxC,UAAAM,MAAA,UAAU,UAAU,EAAS,OAAA;AAAA,IAAA;AAInC,UAAM,MAAM,MAAM,sBAAsB,MAAM,QAAQ;AACtD,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,YAAM,cAAc,KAAK,eAAe,OAAO,CAAC,CAAC;AAAA,IAAA;AAE7C,UAAA,QAAQ,IAAI,MAAM,aAAa;AAE/B,UAAA,eAAe,eAAe,KAAK;AACrC,QAAAA,MAAA,UAAU,YAAY,EAAS,OAAA;AAAA,WAC5B,KAAK;AACZ,QAAIL,SAAW,WAAA,GAAG,KAAK,CAAC,MAAM,SAAS;AAC/B,YAAA,eAAe,eAAe,KAAK;AACrC,UAAAK,MAAA,UAAU,YAAY,EAAS,OAAA;AAC7B,YAAA;AAAA,IAAA;AAEJ,QAAAN,SAAAA,WAAW,GAAG,GAAG;AACb,YAAA;AAAA,IAAA;AAAA,EACR;AAGF,SAAO,MAAM;AACf;AAEA,eAAsB,eAAe,OAAiB;AACpD,MAAI,CAAC,MAAM,eAAe,MAAM,iBAAiB,QAAW;AAC1D,QAAI,MAAM,QAAQ;AAChB,YAAM,eAAe,MAAM,OAAA,EAAS,KAAK,CAAC,cAAc;AAEtD,cAAM,EAAE,IAAI,KAAK,GAAG,YAAY,UAAU;AACnC,eAAA,OAAO,MAAM,SAAS,OAAO;AACpC,cAAM,cAAc;AACpB,cAAM,eAAe;AAAA,MAAA,CACtB;AAAA,IAAA,OACI;AACL,YAAM,cAAc;AAAA,IAAA;AAAA,EACtB;AAMF,MAAI,CAAC,MAAM,qBAAqB,MAAM,uBAAuB,QAAW;AACtE,UAAM,iBAAiB,MAAM;;AAC3B,YAAM,WAAW,CAAC;AAClB,iBAAW,QAAQ,gBAAgB;AACjC,cAAM,WAAW,WAAM,QAAQ,IAAI,MAAlB,mBAA6B;AAC9C,YAAI,QAAS,UAAS,KAAK,QAAA,CAAS;AAAA,MAAA;AAEtC,UAAI,SAAS;AACX,eAAO,QAAQ,IAAI,QAAQ,EAAE,KAAK,MAAM;AACtC,gBAAM,oBAAoB;AAC1B,gBAAM,qBAAqB;AAAA,QAAA,CAC5B;AACH,YAAM,oBAAoB;AAC1B,YAAM,qBAAqB;AAC3B;AAAA,IACF;AACM,UAAA,qBAAqB,MAAM,eAC7B,MAAM,aAAa,KAAK,cAAc,IACtC,eAAe;AAAA,EAAA;AAErB,SAAO,MAAM;AACf;AAEA,SAAS,UACP,OACA,OAC2E;AAC3E,MAAI,OAAO;AACF,WAAA,EAAE,QAAQ,SAAkB,MAAM;AAAA,EAAA;AAEpC,SAAA,EAAE,QAAQ,WAAoB,MAAM;AAC7C;AAEO,SAAS,kBAAkB,OAAiB;;AACjD,aAAW,iBAAiB,gBAAgB;AAC1C,SAAK,WAAM,QAAQ,aAAa,MAA3B,mBAAsC,SAAS;AAC3C,aAAA;AAAA,IAAA;AAAA,EACT;AAEK,SAAA;AACT;AAEO,MAAM,iBAAiB;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;;;"}