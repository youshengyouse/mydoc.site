{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-create.js"],"sourcesContent":["/**\n * @import {Node} from 'estree-jsx'\n */\n\n// Fix to show references to above types in VS Code.\n''\n\n/**\n * @param {Readonly<Node>} from\n *   Node to take from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nexport function create(from, to) {\n  /** @type {Array<keyof Node>} */\n  const fields = ['start', 'end', 'loc', 'range']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n\n    if (field in from) {\n      // @ts-expect-error: assume they’re settable.\n      to[field] = from[field]\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED,oDAAoD;;;;;AACpD;AAUO,SAAS,OAAO,IAAI,EAAE,EAAE;IAC7B,8BAA8B,GAC9B,MAAM,SAAS;QAAC;QAAS;QAAO;QAAO;KAAQ;IAC/C,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;QAC9B,MAAM,QAAQ,MAAM,CAAC,MAAM;QAE3B,IAAI,SAAS,MAAM;YACjB,6CAA6C;YAC7C,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;QACzB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 32, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-specifiers-to-declarations.js"],"sourcesContent":["/**\n * @import {\n      AssignmentProperty,\n      ExportSpecifier,\n      Expression,\n      Identifier,\n      ImportDefaultSpecifier,\n      ImportNamespaceSpecifier,\n      ImportSpecifier,\n      Literal,\n      VariableDeclarator\n * } from 'estree-jsx'\n */\n\nimport {ok as assert} from 'devlop'\nimport {create} from './estree-util-create.js'\n\n/**\n * @param {ReadonlyArray<Readonly<ExportSpecifier> | Readonly<ImportDefaultSpecifier> | Readonly<ImportNamespaceSpecifier> | Readonly<ImportSpecifier>>} specifiers\n *   Specifiers.\n * @param {Readonly<Expression>} init\n *   Initializer.\n * @returns {Array<VariableDeclarator>}\n *   Declarations.\n */\nexport function specifiersToDeclarations(specifiers, init) {\n  let index = -1\n  /** @type {Array<VariableDeclarator>} */\n  const declarations = []\n  /** @type {Array<ExportSpecifier | ImportDefaultSpecifier | ImportSpecifier>} */\n  const otherSpecifiers = []\n  // Can only be one according to JS syntax.\n  /** @type {ImportNamespaceSpecifier | undefined} */\n  let importNamespaceSpecifier\n\n  while (++index < specifiers.length) {\n    const specifier = specifiers[index]\n\n    if (specifier.type === 'ImportNamespaceSpecifier') {\n      importNamespaceSpecifier = specifier\n    } else {\n      otherSpecifiers.push(specifier)\n    }\n  }\n\n  if (importNamespaceSpecifier) {\n    /** @type {VariableDeclarator} */\n    const declarator = {\n      type: 'VariableDeclarator',\n      id: importNamespaceSpecifier.local,\n      init\n    }\n    create(importNamespaceSpecifier, declarator)\n    declarations.push(declarator)\n  }\n\n  declarations.push({\n    type: 'VariableDeclarator',\n    id: {\n      type: 'ObjectPattern',\n      properties: otherSpecifiers.map(function (specifier) {\n        /** @type {Identifier | Literal} */\n        let key =\n          specifier.type === 'ImportSpecifier'\n            ? specifier.imported\n            : specifier.type === 'ExportSpecifier'\n              ? specifier.exported\n              : {type: 'Identifier', name: 'default'}\n        let value = specifier.local\n\n        // Switch them around if we’re exporting.\n        if (specifier.type === 'ExportSpecifier') {\n          value = key\n          key = specifier.local\n        }\n\n        // To do: what to do about literals?\n        // `const { a: 'b' } = c()` does not work?\n        assert(value.type === 'Identifier')\n\n        /** @type {AssignmentProperty} */\n        const property = {\n          type: 'Property',\n          kind: 'init',\n          shorthand:\n            key.type === 'Identifier' &&\n            value.type === 'Identifier' &&\n            key.name === value.name,\n          method: false,\n          computed: false,\n          key,\n          value\n        }\n        create(specifier, property)\n        return property\n      })\n    },\n    init: importNamespaceSpecifier\n      ? {type: 'Identifier', name: importNamespaceSpecifier.local.name}\n      : init\n  })\n\n  return declarations\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;CAYC;;;;AAED;AACA;;;AAUO,SAAS,yBAAyB,UAAU,EAAE,IAAI;IACvD,IAAI,QAAQ,CAAC;IACb,sCAAsC,GACtC,MAAM,eAAe,EAAE;IACvB,8EAA8E,GAC9E,MAAM,kBAAkB,EAAE;IAC1B,0CAA0C;IAC1C,iDAAiD,GACjD,IAAI;IAEJ,MAAO,EAAE,QAAQ,WAAW,MAAM,CAAE;QAClC,MAAM,YAAY,UAAU,CAAC,MAAM;QAEnC,IAAI,UAAU,IAAI,KAAK,4BAA4B;YACjD,2BAA2B;QAC7B,OAAO;YACL,gBAAgB,IAAI,CAAC;QACvB;IACF;IAEA,IAAI,0BAA0B;QAC5B,+BAA+B,GAC/B,MAAM,aAAa;YACjB,MAAM;YACN,IAAI,yBAAyB,KAAK;YAClC;QACF;QACA,IAAA,4QAAM,EAAC,0BAA0B;QACjC,aAAa,IAAI,CAAC;IACpB;IAEA,aAAa,IAAI,CAAC;QAChB,MAAM;QACN,IAAI;YACF,MAAM;YACN,YAAY,gBAAgB,GAAG,CAAC,SAAU,SAAS;gBACjD,iCAAiC,GACjC,IAAI,MACF,UAAU,IAAI,KAAK,oBACf,UAAU,QAAQ,GAClB,UAAU,IAAI,KAAK,oBACjB,UAAU,QAAQ,GAClB;oBAAC,MAAM;oBAAc,MAAM;gBAAS;gBAC5C,IAAI,QAAQ,UAAU,KAAK;gBAE3B,yCAAyC;gBACzC,IAAI,UAAU,IAAI,KAAK,mBAAmB;oBACxC,QAAQ;oBACR,MAAM,UAAU,KAAK;gBACvB;gBAEA,oCAAoC;gBACpC,0CAA0C;gBAC1C,IAAA,qMAAM,EAAC,MAAM,IAAI,KAAK;gBAEtB,+BAA+B,GAC/B,MAAM,WAAW;oBACf,MAAM;oBACN,MAAM;oBACN,WACE,IAAI,IAAI,KAAK,gBACb,MAAM,IAAI,KAAK,gBACf,IAAI,IAAI,KAAK,MAAM,IAAI;oBACzB,QAAQ;oBACR,UAAU;oBACV;oBACA;gBACF;gBACA,IAAA,4QAAM,EAAC,WAAW;gBAClB,OAAO;YACT;QACF;QACA,MAAM,2BACF;YAAC,MAAM;YAAc,MAAM,yBAAyB,KAAK,CAAC,IAAI;QAAA,IAC9D;IACN;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-to-id-or-member-expression.js"],"sourcesContent":["/**\n * @import {\n      Identifier,\n      JSXIdentifier,\n      JSXMemberExpression,\n      Literal,\n      MemberExpression\n * } from 'estree-jsx'\n */\n\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\n\n/**\n * @param {ReadonlyArray<number | string>} ids\n *   Identifiers (example: `['list', 0]).\n * @returns {Identifier | MemberExpression}\n *   Identifier or member expression.\n */\nexport function toIdOrMemberExpression(ids) {\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let object\n\n  while (++index < ids.length) {\n    const name = ids[index]\n    /** @type {Identifier | Literal} */\n    const id =\n      typeof name === 'string' && isIdentifierName(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n    object = object\n      ? {\n          type: 'MemberExpression',\n          object,\n          property: id,\n          computed: id.type === 'Literal',\n          optional: false\n        }\n      : id\n  }\n\n  assert(object, 'expected non-empty `ids` to be passed')\n  assert(object.type !== 'Literal', 'expected identifier as left-most value')\n  return object\n}\n\n/**\n * @param {ReadonlyArray<number | string>} ids\n *   Identifiers (example: `['list', 0]).\n * @returns {JSXIdentifier | JSXMemberExpression}\n *   Identifier or member expression.\n */\nexport function toJsxIdOrMemberExpression(ids) {\n  let index = -1\n  /** @type {JSXIdentifier | JSXMemberExpression | undefined} */\n  let object\n\n  while (++index < ids.length) {\n    const name = ids[index]\n    assert(\n      typeof name === 'string' && isIdentifierName(name, {jsx: true}),\n      'expected valid jsx identifier, not `' + name + '`'\n    )\n\n    /** @type {JSXIdentifier} */\n    const id = {type: 'JSXIdentifier', name}\n    object = object ? {type: 'JSXMemberExpression', object, property: id} : id\n  }\n\n  assert(object, 'expected non-empty `ids` to be passed')\n  return object\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC;;;;;;AAED;AACA;;;AAQO,SAAS,uBAAuB,GAAG;IACxC,IAAI,QAAQ,CAAC;IACb,gEAAgE,GAChE,IAAI;IAEJ,MAAO,EAAE,QAAQ,IAAI,MAAM,CAAE;QAC3B,MAAM,OAAO,GAAG,CAAC,MAAM;QACvB,iCAAiC,GACjC,MAAM,KACJ,OAAO,SAAS,YAAY,IAAA,yQAAgB,EAAC,QACzC;YAAC,MAAM;YAAc;QAAI,IACzB;YAAC,MAAM;YAAW,OAAO;QAAI;QACnC,SAAS,SACL;YACE,MAAM;YACN;YACA,UAAU;YACV,UAAU,GAAG,IAAI,KAAK;YACtB,UAAU;QACZ,IACA;IACN;IAEA,IAAA,qMAAM,EAAC,QAAQ;IACf,IAAA,qMAAM,EAAC,OAAO,IAAI,KAAK,WAAW;IAClC,OAAO;AACT;AAQO,SAAS,0BAA0B,GAAG;IAC3C,IAAI,QAAQ,CAAC;IACb,4DAA4D,GAC5D,IAAI;IAEJ,MAAO,EAAE,QAAQ,IAAI,MAAM,CAAE;QAC3B,MAAM,OAAO,GAAG,CAAC,MAAM;QACvB,IAAA,qMAAM,EACJ,OAAO,SAAS,YAAY,IAAA,yQAAgB,EAAC,MAAM;YAAC,KAAK;QAAI,IAC7D,yCAAyC,OAAO;QAGlD,0BAA0B,GAC1B,MAAM,KAAK;YAAC,MAAM;YAAiB;QAAI;QACvC,SAAS,SAAS;YAAC,MAAM;YAAuB;YAAQ,UAAU;QAAE,IAAI;IAC1E;IAEA,IAAA,qMAAM,EAAC,QAAQ;IACf,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/plugin/recma-build-jsx-transform.js"],"sourcesContent":["/**\n * @import {Program} from 'estree-jsx'\n */\n\n/**\n * @typedef Options\n *   Configuration for internal plugin `recma-build-jsx-transform`.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Whether to keep the import of the automatic runtime or get it from\n *   `arguments[0]` instead (default: `'program'`).\n */\n\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toIdOrMemberExpression} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * Plugin to change the tree after compiling JSX away.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport function recmaBuildJsxTransform(options) {\n  /* c8 ignore next -- always given in `@mdx-js/mdx` */\n  const {outputFormat} = options || {}\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    // Remove the pragma comment that we injected ourselves as it is no longer\n    // needed.\n    if (tree.comments) {\n      tree.comments = tree.comments.filter(function (d) {\n        return !d.data?._mdxIsPragmaComment\n      })\n    }\n\n    // When compiling to a function body, replace the import that was just\n    // generated, and get `jsx`, `jsxs`, and `Fragment` from `arguments[0]`\n    // instead.\n    if (outputFormat === 'function-body') {\n      let index = 0\n\n      // Skip directives: JS currently only has `use strict`, but Acorn allows\n      // arbitrary ones.\n      // Practically things like `use client` could be used?\n      while (index < tree.body.length) {\n        const child = tree.body[index]\n        if ('directive' in child && child.directive) {\n          index++\n        } else {\n          break\n        }\n      }\n\n      const declaration = tree.body[index]\n\n      if (\n        declaration &&\n        declaration.type === 'ImportDeclaration' &&\n        typeof declaration.source.value === 'string' &&\n        /\\/jsx-(dev-)?runtime$/.test(declaration.source.value)\n      ) {\n        tree.body[index] = {\n          type: 'VariableDeclaration',\n          kind: 'const',\n          declarations: specifiersToDeclarations(\n            declaration.specifiers,\n            toIdOrMemberExpression(['arguments', 0])\n          )\n        }\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;CAMC;;;;AAED;AACA;;;AAUO,SAAS,uBAAuB,OAAO;IAC5C,mDAAmD,GACnD,MAAM,EAAC,YAAY,EAAC,GAAG,WAAW,CAAC;IAEnC;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,0EAA0E;QAC1E,UAAU;QACV,IAAI,KAAK,QAAQ,EAAE;YACjB,KAAK,QAAQ,GAAG,KAAK,QAAQ,CAAC,MAAM,CAAC,SAAU,CAAC;gBAC9C,OAAO,CAAC,EAAE,IAAI,EAAE;YAClB;QACF;QAEA,sEAAsE;QACtE,uEAAuE;QACvE,WAAW;QACX,IAAI,iBAAiB,iBAAiB;YACpC,IAAI,QAAQ;YAEZ,wEAAwE;YACxE,kBAAkB;YAClB,sDAAsD;YACtD,MAAO,QAAQ,KAAK,IAAI,CAAC,MAAM,CAAE;gBAC/B,MAAM,QAAQ,KAAK,IAAI,CAAC,MAAM;gBAC9B,IAAI,eAAe,SAAS,MAAM,SAAS,EAAE;oBAC3C;gBACF,OAAO;oBACL;gBACF;YACF;YAEA,MAAM,cAAc,KAAK,IAAI,CAAC,MAAM;YAEpC,IACE,eACA,YAAY,IAAI,KAAK,uBACrB,OAAO,YAAY,MAAM,CAAC,KAAK,KAAK,YACpC,wBAAwB,IAAI,CAAC,YAAY,MAAM,CAAC,KAAK,GACrD;gBACA,KAAK,IAAI,CAAC,MAAM,GAAG;oBACjB,MAAM;oBACN,MAAM;oBACN,cAAc,IAAA,wTAAwB,EACpC,YAAY,UAAU,EACtB,IAAA,4TAAsB,EAAC;wBAAC;wBAAa;qBAAE;gBAE3C;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-declaration-to-expression.js"],"sourcesContent":["/**\n * @import {\n      Declaration,\n      Expression,\n      MaybeNamedClassDeclaration,\n      MaybeNamedFunctionDeclaration\n * } from 'estree-jsx'\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Turn a declaration into an expression.\n *\n * Doesn’t work for variable declarations, but that’s fine for our use case\n * because currently we’re using this utility for export default declarations,\n * which can’t contain variable declarations.\n *\n * @param {Readonly<Declaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration>} declaration\n *   Declaration.\n * @returns {Expression}\n *   Expression.\n */\nexport function declarationToExpression(declaration) {\n  if (declaration.type === 'FunctionDeclaration') {\n    return {...declaration, type: 'FunctionExpression'}\n  }\n\n  // This is currently an internal utility so the next shouldn’t happen or a\n  // maintainer is making a mistake.\n  assert(declaration.type === 'ClassDeclaration', 'unexpected node type')\n  return {...declaration, type: 'ClassExpression'}\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;AAED;;AAcO,SAAS,wBAAwB,WAAW;IACjD,IAAI,YAAY,IAAI,KAAK,uBAAuB;QAC9C,OAAO;YAAC,GAAG,WAAW;YAAE,MAAM;QAAoB;IACpD;IAEA,0EAA0E;IAC1E,kCAAkC;IAClC,IAAA,qMAAM,EAAC,YAAY,IAAI,KAAK,oBAAoB;IAChD,OAAO;QAAC,GAAG,WAAW;QAAE,MAAM;IAAiB;AACjD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-is-declaration.js"],"sourcesContent":["/**\n * @import {\n      Declaration,\n      MaybeNamedClassDeclaration,\n      MaybeNamedFunctionDeclaration,\n      Node\n * } from 'estree-jsx'\n */\n\n// Fix to show references to above types in VS Code.\n''\n\n/**\n * Check if `node` is a declaration.\n *\n * @param {Readonly<MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration | Node>} node\n *   Node to check.\n * @returns {node is Declaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration}\n *   Whether `node` is a declaration.\n */\nexport function isDeclaration(node) {\n  return Boolean(\n    node.type === 'FunctionDeclaration' ||\n      node.type === 'ClassDeclaration' ||\n      node.type === 'VariableDeclaration'\n  )\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC,GAED,oDAAoD;;;;;AACpD;AAUO,SAAS,cAAc,IAAI;IAChC,OAAO,QACL,KAAK,IAAI,KAAK,yBACZ,KAAK,IAAI,KAAK,sBACd,KAAK,IAAI,KAAK;AAEpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/plugin/recma-document.js"],"sourcesContent":["/**\n * @import {\n      CallExpression,\n      Directive,\n      ExportAllDeclaration,\n      ExportDefaultDeclaration,\n      ExportNamedDeclaration,\n      ExportSpecifier,\n      Expression,\n      FunctionDeclaration,\n      Identifier,\n      ImportDeclaration,\n      ImportDefaultSpecifier,\n      ImportExpression,\n      ImportSpecifier,\n      JSXElement,\n      JSXFragment,\n      Literal,\n      ModuleDeclaration,\n      Node,\n      Program,\n      Property,\n      SimpleLiteral,\n      SpreadElement,\n      Statement,\n      VariableDeclarator\n * } from 'estree-jsx'\n * @import {VFile} from 'vfile'\n * @import {ProcessorOptions} from '../core.js'\n */\n\nimport {ok as assert} from 'devlop'\nimport {createVisitors} from 'estree-util-scope'\nimport {walk} from 'estree-walker'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {create} from '../util/estree-util-create.js'\nimport {declarationToExpression} from '../util/estree-util-declaration-to-expression.js'\nimport {isDeclaration} from '../util/estree-util-is-declaration.js'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toIdOrMemberExpression} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * Wrap the estree in `MDXContent`.\n *\n * @param {Readonly<ProcessorOptions>} options\n *   Configuration.\n * @returns\n *   Transform.\n */\nexport function recmaDocument(options) {\n  const baseUrl = options.baseUrl || undefined\n  const baseHref = typeof baseUrl === 'object' ? baseUrl.href : baseUrl\n  const outputFormat = options.outputFormat || 'program'\n  const pragma =\n    options.pragma === undefined ? 'React.createElement' : options.pragma\n  const pragmaFrag =\n    options.pragmaFrag === undefined ? 'React.Fragment' : options.pragmaFrag\n  const pragmaImportSource = options.pragmaImportSource || 'react'\n  const jsxImportSource = options.jsxImportSource || 'react'\n  const jsxRuntime = options.jsxRuntime || 'automatic'\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    /** @type {Array<[string, string] | string>} */\n    const exportedValues = []\n    /** @type {Array<Directive | ModuleDeclaration | Statement>} */\n    const replacement = []\n    let exportAllCount = 0\n    /** @type {ExportDefaultDeclaration | ExportSpecifier | undefined} */\n    let layout\n    /** @type {boolean | undefined} */\n    let content\n    /** @type {Node} */\n    let child\n\n    if (jsxRuntime === 'classic' && pragmaFrag) {\n      injectPragma(tree, '@jsxFrag', pragmaFrag)\n    }\n\n    if (jsxRuntime === 'classic' && pragma) {\n      injectPragma(tree, '@jsx', pragma)\n    }\n\n    if (jsxRuntime === 'automatic' && jsxImportSource) {\n      injectPragma(tree, '@jsxImportSource', jsxImportSource)\n    }\n\n    if (jsxRuntime) {\n      injectPragma(tree, '@jsxRuntime', jsxRuntime)\n    }\n\n    if (jsxRuntime === 'classic' && pragmaImportSource) {\n      if (!pragma) {\n        throw new Error(\n          'Missing `pragma` in classic runtime with `pragmaImportSource`'\n        )\n      }\n\n      handleEsm({\n        type: 'ImportDeclaration',\n        specifiers: [\n          {\n            type: 'ImportDefaultSpecifier',\n            local: {type: 'Identifier', name: pragma.split('.')[0]}\n          }\n        ],\n        source: {type: 'Literal', value: pragmaImportSource}\n      })\n    }\n\n    // Find the `export default`, the JSX expression, and leave the rest\n    // (import/exports) as they are.\n    for (child of tree.body) {\n      // ```tsx\n      // export default properties => <>{properties.children}</>\n      // ```\n      //\n      // Treat it as an inline layout declaration.\n      if (child.type === 'ExportDefaultDeclaration') {\n        if (layout) {\n          file.fail(\n            'Unexpected duplicate layout, expected a single layout (previous: ' +\n              stringifyPosition(positionFromEstree(layout)) +\n              ')',\n            {\n              ancestors: [tree, child],\n              place: positionFromEstree(child),\n              ruleId: 'duplicate-layout',\n              source: 'recma-document'\n            }\n          )\n        }\n\n        layout = child\n        replacement.push({\n          type: 'VariableDeclaration',\n          kind: 'const',\n          declarations: [\n            {\n              type: 'VariableDeclarator',\n              id: {type: 'Identifier', name: 'MDXLayout'},\n              init: isDeclaration(child.declaration)\n                ? declarationToExpression(child.declaration)\n                : child.declaration\n            }\n          ]\n        })\n      }\n      // ```tsx\n      // export {a, b as c} from 'd'\n      // ```\n      else if (child.type === 'ExportNamedDeclaration' && child.source) {\n        // Cast because always simple.\n        const source = /** @type {SimpleLiteral} */ (child.source)\n\n        // Remove `default` or `as default`, but not `default as`, specifier.\n        child.specifiers = child.specifiers.filter(function (specifier) {\n          if (\n            specifier.exported.type === 'Identifier' &&\n            specifier.exported.name === 'default'\n          ) {\n            if (layout) {\n              file.fail(\n                'Unexpected duplicate layout, expected a single layout (previous: ' +\n                  stringifyPosition(positionFromEstree(layout)) +\n                  ')',\n                {\n                  ancestors: [tree, child, specifier],\n                  place: positionFromEstree(child),\n                  ruleId: 'duplicate-layout',\n                  source: 'recma-document'\n                }\n              )\n            }\n\n            layout = specifier\n\n            // Make it just an import: `import MDXLayout from '…'`.\n            /** @type {Array<ImportDefaultSpecifier | ImportSpecifier>} */\n            const specifiers = []\n\n            // Default as default / something else as default.\n            if (\n              specifier.local.type === 'Identifier' &&\n              specifier.local.name === 'default'\n            ) {\n              specifiers.push({\n                type: 'ImportDefaultSpecifier',\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              })\n            } else {\n              /** @type {ImportSpecifier} */\n              const importSpecifier = {\n                type: 'ImportSpecifier',\n                imported: specifier.local,\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              }\n              create(specifier.local, importSpecifier)\n              specifiers.push(importSpecifier)\n            }\n\n            /** @type {Literal} */\n            const from = {type: 'Literal', value: source.value}\n            create(source, from)\n\n            /** @type {ImportDeclaration} */\n            const declaration = {\n              type: 'ImportDeclaration',\n              specifiers,\n              source: from\n            }\n            create(specifier, declaration)\n            handleEsm(declaration)\n\n            return false\n          }\n\n          return true\n        })\n\n        // If there are other things imported, keep it.\n        if (child.specifiers.length > 0) {\n          handleExport(child)\n        }\n      }\n      // ```tsx\n      // export {a, b as c}\n      // export * from 'a'\n      // ```\n      else if (\n        child.type === 'ExportNamedDeclaration' ||\n        child.type === 'ExportAllDeclaration'\n      ) {\n        handleExport(child)\n      } else if (child.type === 'ImportDeclaration') {\n        handleEsm(child)\n      } else if (\n        child.type === 'ExpressionStatement' &&\n        (child.expression.type === 'JSXElement' ||\n          child.expression.type === 'JSXFragment')\n      ) {\n        content = true\n        replacement.push(\n          ...createMdxContent(child.expression, outputFormat, Boolean(layout))\n        )\n      } else {\n        // This catch-all branch is because plugins might add other things.\n        // Normally, we only have import/export/jsx, but just add whatever’s\n        // there.\n        replacement.push(child)\n      }\n    }\n\n    // If there was no JSX content at all, add an empty function.\n    if (!content) {\n      replacement.push(\n        ...createMdxContent(undefined, outputFormat, Boolean(layout))\n      )\n    }\n\n    exportedValues.push(['MDXContent', 'default'])\n\n    if (outputFormat === 'function-body') {\n      replacement.push({\n        type: 'ReturnStatement',\n        argument: {\n          type: 'ObjectExpression',\n          properties: [\n            ...Array.from({length: exportAllCount}).map(\n              /**\n               * @param {undefined} _\n               *   Nothing.\n               * @param {number} index\n               *   Index.\n               * @returns {SpreadElement}\n               *   Node.\n               */\n              function (_, index) {\n                return {\n                  type: 'SpreadElement',\n                  argument: {\n                    type: 'Identifier',\n                    name: '_exportAll' + (index + 1)\n                  }\n                }\n              }\n            ),\n            ...exportedValues.map(function (d) {\n              /** @type {Property} */\n              const property = {\n                type: 'Property',\n                kind: 'init',\n                method: false,\n                computed: false,\n                shorthand: typeof d === 'string',\n                key: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[1]\n                },\n                value: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[0]\n                }\n              }\n\n              return property\n            })\n          ]\n        }\n      })\n    }\n\n    tree.body = replacement\n\n    let usesImportMetaUrlVariable = false\n    let usesResolveDynamicHelper = false\n\n    if (baseHref || outputFormat === 'function-body') {\n      walk(tree, {\n        enter(node) {\n          if (\n            (node.type === 'ExportAllDeclaration' ||\n              node.type === 'ExportNamedDeclaration' ||\n              node.type === 'ImportDeclaration') &&\n            node.source\n          ) {\n            // We never hit this branch when generating function bodies, as\n            // statements are already compiled away into import expressions.\n            assert(baseHref, 'unexpected missing `baseHref` in branch')\n\n            let value = node.source.value\n            // The literal source for statements can only be string.\n            assert(typeof value === 'string', 'expected string source')\n\n            // Resolve a specifier.\n            // This is the same as `_resolveDynamicMdxSpecifier`, which has to\n            // be injected to work with expressions at runtime, but as we have\n            // `baseHref` at compile time here and statements are static\n            // strings, we can do it now.\n            try {\n              // To do: next major: use `URL.canParse`.\n              // eslint-disable-next-line no-new\n              new URL(value)\n              // Fine: a full URL.\n            } catch {\n              if (\n                value.startsWith('/') ||\n                value.startsWith('./') ||\n                value.startsWith('../')\n              ) {\n                value = new URL(value, baseHref).href\n              } else {\n                // Fine: are bare specifier.\n              }\n            }\n\n            /** @type {SimpleLiteral} */\n            const replacement = {type: 'Literal', value}\n            create(node.source, replacement)\n            node.source = replacement\n            return\n          }\n\n          if (node.type === 'ImportExpression') {\n            usesResolveDynamicHelper = true\n            /** @type {CallExpression} */\n            const replacement = {\n              type: 'CallExpression',\n              callee: {type: 'Identifier', name: '_resolveDynamicMdxSpecifier'},\n              arguments: [node.source],\n              optional: false\n            }\n            node.source = replacement\n            return\n          }\n\n          // To do: add support for `import.meta.resolve`.\n\n          if (\n            node.type === 'MemberExpression' &&\n            'object' in node &&\n            node.object.type === 'MetaProperty' &&\n            node.property.type === 'Identifier' &&\n            node.object.meta.name === 'import' &&\n            node.object.property.name === 'meta' &&\n            node.property.name === 'url'\n          ) {\n            usesImportMetaUrlVariable = true\n            /** @type {Identifier} */\n            const replacement = {type: 'Identifier', name: '_importMetaUrl'}\n            create(node, replacement)\n            this.replace(replacement)\n          }\n        }\n      })\n    }\n\n    if (usesResolveDynamicHelper) {\n      if (!baseHref) {\n        usesImportMetaUrlVariable = true\n      }\n\n      tree.body.push(\n        resolveDynamicMdxSpecifier(\n          baseHref\n            ? {type: 'Literal', value: baseHref}\n            : {type: 'Identifier', name: '_importMetaUrl'}\n        )\n      )\n    }\n\n    if (usesImportMetaUrlVariable) {\n      assert(\n        outputFormat === 'function-body',\n        'expected `function-body` when using dynamic url injection'\n      )\n      tree.body.unshift(...createImportMetaUrlVariable())\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration} node\n     *   Export node.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function handleExport(node) {\n      if (node.type === 'ExportNamedDeclaration') {\n        // ```tsx\n        // export function a() {}\n        // export class A {}\n        // export var a = 1\n        // ```\n        if (node.declaration) {\n          const visitors = createVisitors()\n          // Walk the top-level scope.\n          walk(node, {\n            enter(node) {\n              visitors.enter(node)\n\n              if (\n                node.type === 'ArrowFunctionExpression' ||\n                node.type === 'FunctionDeclaration' ||\n                node.type === 'FunctionExpression'\n              ) {\n                this.skip()\n                visitors.exit(node)\n              }\n            },\n            leave: visitors.exit\n          })\n          exportedValues.push(...visitors.scopes[0].defined)\n        }\n\n        // ```tsx\n        // export {a, b as c}\n        // export {a, b as c} from 'd'\n        // ```\n        for (child of node.specifiers) {\n          if (child.exported.type === 'Identifier') {\n            exportedValues.push(child.exported.name)\n            /* c8 ignore next 5 -- to do: <https://github.com/mdx-js/mdx/issues/2536> */\n          } else {\n            // Must be string.\n            assert(typeof child.exported.value === 'string')\n            exportedValues.push(child.exported.value)\n          }\n        }\n      }\n\n      handleEsm(node)\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration | ImportDeclaration} node\n     *   Export or import node.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function handleEsm(node) {\n      /** @type {ModuleDeclaration | Statement | undefined} */\n      let replace\n      /** @type {Expression} */\n      let init\n\n      if (outputFormat === 'function-body') {\n        if (\n          // Always have a source:\n          node.type === 'ImportDeclaration' ||\n          node.type === 'ExportAllDeclaration' ||\n          // Source optional:\n          (node.type === 'ExportNamedDeclaration' && node.source)\n        ) {\n          // We always have a source, but types say they can be missing.\n          assert(node.source, 'expected `node.source` to be defined')\n\n          // ```\n          // import 'a'\n          // //=> await import('a')\n          // import a from 'b'\n          // //=> const {default: a} = await import('b')\n          // export {a, b as c} from 'd'\n          // //=> const {a, c: b} = await import('d')\n          // export * from 'a'\n          // //=> const _exportAll0 = await import('a')\n          // ```\n          /** @type {ImportExpression} */\n          const argument = {type: 'ImportExpression', source: node.source}\n          create(node, argument)\n          init = {type: 'AwaitExpression', argument}\n\n          if (\n            (node.type === 'ImportDeclaration' ||\n              node.type === 'ExportNamedDeclaration') &&\n            node.specifiers.length === 0\n          ) {\n            replace = {type: 'ExpressionStatement', expression: init}\n          } else {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations:\n                node.type === 'ExportAllDeclaration'\n                  ? [\n                      {\n                        type: 'VariableDeclarator',\n                        id: {\n                          type: 'Identifier',\n                          name: '_exportAll' + ++exportAllCount\n                        },\n                        init\n                      }\n                    ]\n                  : specifiersToDeclarations(node.specifiers, init)\n            }\n          }\n        } else if (node.declaration) {\n          replace = node.declaration\n        } else {\n          /** @type {Array<VariableDeclarator>} */\n          const declarators = []\n\n          for (const specifier of node.specifiers) {\n            // `id` can only be an identifier,\n            // so we ignore literal.\n            if (\n              specifier.exported.type === 'Identifier' &&\n              specifier.local.type === 'Identifier' &&\n              specifier.local.name !== specifier.exported.name\n            ) {\n              declarators.push({\n                type: 'VariableDeclarator',\n                id: specifier.exported,\n                init: specifier.local\n              })\n            }\n          }\n\n          if (declarators.length > 0) {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations: declarators\n            }\n          }\n        }\n      } else {\n        replace = node\n      }\n\n      if (replace) {\n        replacement.push(replace)\n      }\n    }\n  }\n\n  /**\n   * @param {Readonly<Expression> | undefined} content\n   *   Content.\n   * @param {'function-body' | 'program'} outputFormat\n   *   Output format.\n   * @param {boolean | undefined} [hasInternalLayout=false]\n   *   Whether there’s an internal layout (default: `false`).\n   * @returns {Array<ExportDefaultDeclaration | FunctionDeclaration>}\n   *   Functions.\n   */\n  function createMdxContent(content, outputFormat, hasInternalLayout) {\n    /** @type {JSXElement} */\n    const element = {\n      type: 'JSXElement',\n      openingElement: {\n        type: 'JSXOpeningElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'},\n        attributes: [\n          {\n            type: 'JSXSpreadAttribute',\n            argument: {type: 'Identifier', name: 'props'}\n          }\n        ],\n        selfClosing: false\n      },\n      closingElement: {\n        type: 'JSXClosingElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'}\n      },\n      children: [\n        {\n          type: 'JSXElement',\n          openingElement: {\n            type: 'JSXOpeningElement',\n            name: {type: 'JSXIdentifier', name: '_createMdxContent'},\n            attributes: [\n              {\n                type: 'JSXSpreadAttribute',\n                argument: {type: 'Identifier', name: 'props'}\n              }\n            ],\n            selfClosing: true\n          },\n          closingElement: null,\n          children: []\n        }\n      ]\n    }\n\n    let result = /** @type {Expression} */ (element)\n\n    if (!hasInternalLayout) {\n      result = {\n        type: 'ConditionalExpression',\n        test: {type: 'Identifier', name: 'MDXLayout'},\n        consequent: result,\n        alternate: {\n          type: 'CallExpression',\n          callee: {type: 'Identifier', name: '_createMdxContent'},\n          arguments: [{type: 'Identifier', name: 'props'}],\n          optional: false\n        }\n      }\n    }\n\n    let argument =\n      // Cast because TS otherwise does not think `JSXFragment`s are expressions.\n      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */ (\n        content || {type: 'Identifier', name: 'undefined'}\n      )\n\n    // Unwrap a fragment of a single element.\n    if (\n      argument.type === 'JSXFragment' &&\n      argument.children.length === 1 &&\n      argument.children[0].type === 'JSXElement'\n    ) {\n      argument = argument.children[0]\n    }\n\n    let awaitExpression = false\n\n    walk(argument, {\n      enter(node) {\n        if (\n          node.type === 'ArrowFunctionExpression' ||\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression'\n        ) {\n          return this.skip()\n        }\n\n        if (\n          node.type === 'AwaitExpression' ||\n          /* c8 ignore next 2 -- can only occur in a function (which then can\n           * only be async, so skipped it) */\n          (node.type === 'ForOfStatement' && node.await)\n        ) {\n          awaitExpression = true\n        }\n      }\n    })\n\n    /** @type {FunctionDeclaration} */\n    const declaration = {\n      type: 'FunctionDeclaration',\n      id: {type: 'Identifier', name: 'MDXContent'},\n      params: [\n        {\n          type: 'AssignmentPattern',\n          left: {type: 'Identifier', name: 'props'},\n          right: {type: 'ObjectExpression', properties: []}\n        }\n      ],\n      body: {\n        type: 'BlockStatement',\n        body: [{type: 'ReturnStatement', argument: result}]\n      }\n    }\n\n    return [\n      {\n        type: 'FunctionDeclaration',\n        async: awaitExpression,\n        id: {type: 'Identifier', name: '_createMdxContent'},\n        params: [{type: 'Identifier', name: 'props'}],\n        body: {\n          type: 'BlockStatement',\n          body: [\n            {\n              type: 'ReturnStatement',\n              // Cast because TS doesn’t think `JSXFragment` is an expression.\n              // eslint-disable-next-line object-shorthand\n              argument: /** @type {Expression} */ (argument)\n            }\n          ]\n        }\n      },\n      outputFormat === 'program'\n        ? {type: 'ExportDefaultDeclaration', declaration}\n        : declaration\n    ]\n  }\n}\n\n/**\n * @param {Program} tree\n * @param {string} name\n * @param {string} value\n * @returns {undefined}\n */\nfunction injectPragma(tree, name, value) {\n  tree.comments?.unshift({\n    type: 'Block',\n    value: name + ' ' + value,\n    data: {_mdxIsPragmaComment: true}\n  })\n}\n\n/**\n * @param {Expression} importMetaUrl\n * @returns {FunctionDeclaration}\n */\nfunction resolveDynamicMdxSpecifier(importMetaUrl) {\n  return {\n    type: 'FunctionDeclaration',\n    id: {type: 'Identifier', name: '_resolveDynamicMdxSpecifier'},\n    generator: false,\n    async: false,\n    params: [{type: 'Identifier', name: 'd'}],\n    body: {\n      type: 'BlockStatement',\n      body: [\n        {\n          type: 'IfStatement',\n          test: {\n            type: 'BinaryExpression',\n            left: {\n              type: 'UnaryExpression',\n              operator: 'typeof',\n              prefix: true,\n              argument: {type: 'Identifier', name: 'd'}\n            },\n            operator: '!==',\n            right: {type: 'Literal', value: 'string'}\n          },\n          consequent: {\n            type: 'ReturnStatement',\n            argument: {type: 'Identifier', name: 'd'}\n          },\n          alternate: null\n        },\n        // To do: use `URL.canParse` when widely supported (see commented\n        // out code below).\n        {\n          type: 'TryStatement',\n          block: {\n            type: 'BlockStatement',\n            body: [\n              {\n                type: 'ExpressionStatement',\n                expression: {\n                  type: 'NewExpression',\n                  callee: {type: 'Identifier', name: 'URL'},\n                  arguments: [{type: 'Identifier', name: 'd'}]\n                }\n              },\n              {\n                type: 'ReturnStatement',\n                argument: {type: 'Identifier', name: 'd'}\n              }\n            ]\n          },\n          handler: {\n            type: 'CatchClause',\n            param: null,\n            body: {type: 'BlockStatement', body: []}\n          },\n          finalizer: null\n        },\n        // To do: use `URL.canParse` when widely supported.\n        // {\n        //   type: 'IfStatement',\n        //   test: {\n        //     type: 'CallExpression',\n        //     callee: toIdOrMemberExpression(['URL', 'canParse']),\n        //     arguments: [{type: 'Identifier', name: 'd'}],\n        //     optional: false\n        //   },\n        //   consequent: {\n        //     type: 'ReturnStatement',\n        //     argument: {type: 'Identifier', name: 'd'}\n        //   },\n        //   alternate: null\n        // },\n        {\n          type: 'IfStatement',\n          test: {\n            type: 'LogicalExpression',\n            left: {\n              type: 'LogicalExpression',\n              left: {\n                type: 'CallExpression',\n                callee: toIdOrMemberExpression(['d', 'startsWith']),\n                arguments: [{type: 'Literal', value: '/'}],\n                optional: false\n              },\n              operator: '||',\n              right: {\n                type: 'CallExpression',\n                callee: toIdOrMemberExpression(['d', 'startsWith']),\n                arguments: [{type: 'Literal', value: './'}],\n                optional: false\n              }\n            },\n            operator: '||',\n            right: {\n              type: 'CallExpression',\n              callee: toIdOrMemberExpression(['d', 'startsWith']),\n              arguments: [{type: 'Literal', value: '../'}],\n              optional: false\n            }\n          },\n          consequent: {\n            type: 'ReturnStatement',\n            argument: {\n              type: 'MemberExpression',\n              object: {\n                type: 'NewExpression',\n                callee: {type: 'Identifier', name: 'URL'},\n                arguments: [{type: 'Identifier', name: 'd'}, importMetaUrl]\n              },\n              property: {type: 'Identifier', name: 'href'},\n              computed: false,\n              optional: false\n            }\n          },\n          alternate: null\n        },\n        {\n          type: 'ReturnStatement',\n          argument: {type: 'Identifier', name: 'd'}\n        }\n      ]\n    }\n  }\n}\n\n/**\n * @returns {Array<Statement>}\n */\nfunction createImportMetaUrlVariable() {\n  return [\n    {\n      type: 'VariableDeclaration',\n      declarations: [\n        {\n          type: 'VariableDeclarator',\n          id: {type: 'Identifier', name: '_importMetaUrl'},\n          init: toIdOrMemberExpression(['arguments', 0, 'baseUrl'])\n        }\n      ],\n      kind: 'const'\n    },\n    {\n      type: 'IfStatement',\n      test: {\n        type: 'UnaryExpression',\n        operator: '!',\n        prefix: true,\n        argument: {type: 'Identifier', name: '_importMetaUrl'}\n      },\n      consequent: {\n        type: 'ThrowStatement',\n        argument: {\n          type: 'NewExpression',\n          callee: {type: 'Identifier', name: 'Error'},\n          arguments: [\n            {\n              type: 'Literal',\n              value:\n                'Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`'\n            }\n          ]\n        }\n      },\n      alternate: null\n    }\n  ]\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/util/estree-util-to-binary-addition.js"],"sourcesContent":["/**\n * @import {Expression} from 'estree-jsx'\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * @param {ReadonlyArray<Expression>} expressions\n *   Expressions.\n * @returns {Expression}\n *   Addition.\n */\nexport function toBinaryAddition(expressions) {\n  let index = -1\n  /** @type {Expression | undefined} */\n  let left\n\n  while (++index < expressions.length) {\n    const right = expressions[index]\n    left = left ? {type: 'BinaryExpression', left, operator: '+', right} : right\n  }\n\n  assert(left, 'expected non-empty `expressions` to be passed')\n  return left\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;;AAQO,SAAS,iBAAiB,WAAW;IAC1C,IAAI,QAAQ,CAAC;IACb,mCAAmC,GACnC,IAAI;IAEJ,MAAO,EAAE,QAAQ,YAAY,MAAM,CAAE;QACnC,MAAM,QAAQ,WAAW,CAAC,MAAM;QAChC,OAAO,OAAO;YAAC,MAAM;YAAoB;YAAM,UAAU;YAAK;QAAK,IAAI;IACzE;IAEA,IAAA,qMAAM,EAAC,MAAM;IACb,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1249, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/plugin/recma-jsx-rewrite.js"],"sourcesContent":["/**\n * @import {\n      Expression,\n      Function as EstreeFunction,\n      Identifier,\n      ImportSpecifier,\n      JSXElement,\n      ModuleDeclaration,\n      ObjectPattern,\n      Program,\n      Property,\n      SpreadElement,\n      Statement,\n      VariableDeclarator\n * } from 'estree-jsx'\n * @import {Scope} from 'estree-util-scope'\n * @import {VFile} from 'vfile'\n * @import {ProcessorOptions} from '../core.js'\n */\n\n/**\n * @typedef StackEntry\n *   Entry.\n * @property {Array<string>} components\n *   Used components.\n * @property {Map<string, string>} idToInvalidComponentName\n *   Map of JSX identifiers which cannot be used as JS identifiers, to valid JS identifiers.\n * @property {Readonly<EstreeFunction>} node\n *   Function.\n * @property {Array<string>} objects\n *   Identifiers of used objects (such as `x` in `x.y`).\n * @property {Record<string, {node: Readonly<JSXElement>, component: boolean}>} references\n *   Map of JSX identifiers for components and objects, to where they were first used.\n * @property {Array<string>} tags\n *   Tag names.\n */\n\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {createVisitors} from 'estree-util-scope'\nimport {walk} from 'estree-walker'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toBinaryAddition} from '../util/estree-util-to-binary-addition.js'\nimport {\n  toIdOrMemberExpression,\n  toJsxIdOrMemberExpression\n} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * A plugin that rewrites JSX in functions to accept components as\n * `props.components` (when the function is called `_createMdxContent`), or from\n * a provider (if there is one).\n * It also makes sure that any undefined components are defined: either from\n * received components or as a function that throws an error.\n *\n * @param {Readonly<ProcessorOptions>} options\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport function recmaJsxRewrite(options) {\n  const {development, outputFormat, providerImportSource} = options\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    const visitors = createVisitors()\n    /** @type {Array<StackEntry>} */\n    const functionStack = []\n    let importProvider = false\n    let createErrorHelper = false\n\n    walk(tree, {\n      enter(node) {\n        visitors.enter(node)\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          functionStack.push({\n            components: [],\n            idToInvalidComponentName: new Map(),\n            node,\n            objects: [],\n            references: {},\n            tags: []\n          })\n\n          // `MDXContent` only ever contains `MDXLayout`.\n          if (\n            isNamedFunction(node, 'MDXContent') &&\n            !inScope(visitors.scopes, 'MDXLayout')\n          ) {\n            functionStack[0].components.push('MDXLayout')\n          }\n        }\n\n        const functionInfo = functionStack[0]\n\n        if (\n          !functionInfo ||\n          (!isNamedFunction(functionInfo.node, '_createMdxContent') &&\n            !providerImportSource)\n        ) {\n          return\n        }\n\n        if (node.type === 'JSXElement') {\n          let name = node.openingElement.name\n\n          // `<x.y>`, `<Foo.Bar>`, `<x.y.z>`.\n          if (name.type === 'JSXMemberExpression') {\n            /** @type {Array<string>} */\n            const ids = []\n\n            // Find the left-most identifier.\n            while (name.type === 'JSXMemberExpression') {\n              ids.unshift(name.property.name)\n              name = name.object\n            }\n\n            ids.unshift(name.name)\n            const fullId = ids.join('.')\n            const id = name.name\n            const isInScope = inScope(visitors.scopes, id)\n\n            if (\n              !Object.hasOwn(functionInfo.references, fullId) &&\n              (!isInScope ||\n                // If the parent scope is `_createMdxContent`, then this\n                // references a component we can add a check statement for.\n                (functionStack.length === 1 &&\n                  functionStack[0].node.type === 'FunctionDeclaration' &&\n                  isNamedFunction(functionStack[0].node, '_createMdxContent')))\n            ) {\n              functionInfo.references[fullId] = {component: true, node}\n            }\n\n            if (!functionInfo.objects.includes(id) && !isInScope) {\n              functionInfo.objects.push(id)\n            }\n          }\n          // `<xml:thing>`.\n          else if (name.type === 'JSXNamespacedName') {\n            // Ignore namespaces.\n          }\n          // If the name is a valid ES identifier, and it doesn’t start with a\n          // lowercase letter, it’s a component.\n          // For example, `$foo`, `_bar`, `Baz` are all component names.\n          // But `foo` and `b-ar` are tag names.\n          else if (isIdentifierName(name.name) && !/^[a-z]/.test(name.name)) {\n            const id = name.name\n\n            if (!inScope(visitors.scopes, id)) {\n              // No need to add an error for an undefined layout — we use an\n              // `if` later.\n              if (\n                id !== 'MDXLayout' &&\n                !Object.hasOwn(functionInfo.references, id)\n              ) {\n                functionInfo.references[id] = {component: true, node}\n              }\n\n              if (!functionInfo.components.includes(id)) {\n                functionInfo.components.push(id)\n              }\n            }\n          } else if (node.data && node.data._mdxExplicitJsx) {\n            // Do not turn explicit JSX into components from `_components`.\n            // As in, a given `h1` component is used for `# heading` (next case),\n            // but not for `<h1>heading</h1>`.\n          } else {\n            const id = name.name\n\n            if (!functionInfo.tags.includes(id)) {\n              functionInfo.tags.push(id)\n            }\n\n            /** @type {Array<number | string>} */\n            let jsxIdExpression = ['_components', id]\n            if (isIdentifierName(id) === false) {\n              let invalidComponentName =\n                functionInfo.idToInvalidComponentName.get(id)\n              if (invalidComponentName === undefined) {\n                invalidComponentName = `_component${functionInfo.idToInvalidComponentName.size}`\n                functionInfo.idToInvalidComponentName.set(\n                  id,\n                  invalidComponentName\n                )\n              }\n\n              jsxIdExpression = [invalidComponentName]\n            }\n\n            node.openingElement.name =\n              toJsxIdOrMemberExpression(jsxIdExpression)\n\n            if (node.closingElement) {\n              node.closingElement.name =\n                toJsxIdOrMemberExpression(jsxIdExpression)\n            }\n          }\n        }\n      },\n      leave(node) {\n        visitors.exit(node)\n\n        /** @type {Array<Property | SpreadElement>} */\n        const defaults = []\n        /** @type {Array<string>} */\n        const actual = []\n        /** @type {Array<Expression>} */\n        const parameters = []\n        /** @type {Array<VariableDeclarator>} */\n        const declarations = []\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          const functionInfo = functionStack[functionStack.length - 1]\n\n          /** @type {string} */\n          let name\n\n          for (name of functionInfo.tags.sort()) {\n            defaults.push({\n              type: 'Property',\n              kind: 'init',\n              key: isIdentifierName(name)\n                ? {type: 'Identifier', name}\n                : {type: 'Literal', value: name},\n              value: {type: 'Literal', value: name},\n              method: false,\n              shorthand: false,\n              computed: false\n            })\n          }\n\n          actual.push(...functionInfo.components)\n\n          for (name of functionInfo.objects) {\n            // In some cases, a component is used directly (`<X>`) but it’s also\n            // used as an object (`<X.Y>`).\n            if (!actual.includes(name)) {\n              actual.push(name)\n            }\n          }\n\n          actual.sort()\n\n          /** @type {Array<Statement>} */\n          const statements = []\n\n          if (\n            defaults.length > 0 ||\n            actual.length > 0 ||\n            functionInfo.idToInvalidComponentName.size > 0\n          ) {\n            if (providerImportSource) {\n              importProvider = true\n              parameters.push({\n                type: 'CallExpression',\n                callee: {type: 'Identifier', name: '_provideComponents'},\n                arguments: [],\n                optional: false\n              })\n            }\n\n            // Accept `components` as a prop if this is the `MDXContent` or\n            // `_createMdxContent` function.\n            if (\n              isNamedFunction(functionInfo.node, 'MDXContent') ||\n              isNamedFunction(functionInfo.node, '_createMdxContent')\n            ) {\n              parameters.push(toIdOrMemberExpression(['props', 'components']))\n            }\n\n            if (defaults.length > 0 || parameters.length > 1) {\n              for (const parameter of parameters) {\n                defaults.push({type: 'SpreadElement', argument: parameter})\n              }\n            }\n\n            // If we’re getting components from several sources, merge them.\n            /** @type {Expression} */\n            let componentsInit =\n              defaults.length > 0\n                ? {type: 'ObjectExpression', properties: defaults}\n                : // If we’re only getting components from `props.components`,\n                  // make sure it’s defined.\n                  {\n                    type: 'LogicalExpression',\n                    operator: '||',\n                    left: parameters[0],\n                    right: {type: 'ObjectExpression', properties: []}\n                  }\n\n            /** @type {ObjectPattern | undefined} */\n            let componentsPattern\n\n            // Add components to scope.\n            // For `['MyComponent', 'MDXLayout']` this generates:\n            // ```tsx\n            // const {MyComponent, wrapper: MDXLayout} = _components\n            // ```\n            // Note that MDXLayout is special as it’s taken from\n            // `_components.wrapper`.\n            if (actual.length > 0) {\n              componentsPattern = {\n                type: 'ObjectPattern',\n                properties: actual.map(function (name) {\n                  return {\n                    type: 'Property',\n                    kind: 'init',\n                    key: {\n                      type: 'Identifier',\n                      name: name === 'MDXLayout' ? 'wrapper' : name\n                    },\n                    value: {type: 'Identifier', name},\n                    method: false,\n                    shorthand: name !== 'MDXLayout',\n                    computed: false\n                  }\n                })\n              }\n            }\n\n            if (functionInfo.tags.length > 0) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: {type: 'Identifier', name: '_components'},\n                init: componentsInit\n              })\n              componentsInit = {type: 'Identifier', name: '_components'}\n            }\n\n            if (isNamedFunction(functionInfo.node, '_createMdxContent')) {\n              for (const [id, componentName] of [\n                ...functionInfo.idToInvalidComponentName\n              ].sort(function ([a], [b]) {\n                return a.localeCompare(b)\n              })) {\n                // For JSX IDs that can’t be represented as JavaScript IDs (as in,\n                // those with dashes, such as `custom-element`), generate a\n                // separate variable that is a valid JS ID (such as `_component0`),\n                // and takes it from components:\n                // `const _component0 = _components['custom-element']`\n                declarations.push({\n                  type: 'VariableDeclarator',\n                  id: {\n                    type: 'Identifier',\n                    name: componentName\n                  },\n                  init: {\n                    type: 'MemberExpression',\n                    object: {type: 'Identifier', name: '_components'},\n                    property: {type: 'Literal', value: id},\n                    computed: true,\n                    optional: false\n                  }\n                })\n              }\n            }\n\n            if (componentsPattern) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: componentsPattern,\n                init: componentsInit\n              })\n            }\n\n            if (declarations.length > 0) {\n              statements.push({\n                type: 'VariableDeclaration',\n                kind: 'const',\n                declarations\n              })\n            }\n          }\n\n          /** @type {string} */\n          let key\n\n          // Add partials (so for `x.y.z` it’d generate `x` and `x.y` too).\n          for (key in functionInfo.references) {\n            if (Object.hasOwn(functionInfo.references, key)) {\n              const parts = key.split('.')\n              let index = 0\n              while (++index < parts.length) {\n                const partial = parts.slice(0, index).join('.')\n                if (!Object.hasOwn(functionInfo.references, partial)) {\n                  functionInfo.references[partial] = {\n                    component: false,\n                    node: functionInfo.references[key].node\n                  }\n                }\n              }\n            }\n          }\n\n          const references = Object.keys(functionInfo.references).sort()\n\n          let index = -1\n          while (++index < references.length) {\n            const id = references[index]\n            const info = functionInfo.references[id]\n            const place = stringifyPosition(positionFromEstree(info.node))\n            /** @type {Array<Expression>} */\n            const parameters = [\n              {type: 'Literal', value: id},\n              {type: 'Literal', value: info.component}\n            ]\n\n            createErrorHelper = true\n\n            if (development && place) {\n              parameters.push({type: 'Literal', value: place})\n            }\n\n            statements.push({\n              type: 'IfStatement',\n              test: {\n                type: 'UnaryExpression',\n                operator: '!',\n                prefix: true,\n                argument: toIdOrMemberExpression(id.split('.'))\n              },\n              consequent: {\n                type: 'ExpressionStatement',\n                expression: {\n                  type: 'CallExpression',\n                  callee: {type: 'Identifier', name: '_missingMdxReference'},\n                  arguments: parameters,\n                  optional: false\n                }\n              },\n              alternate: undefined\n            })\n          }\n\n          if (statements.length > 0) {\n            // Arrow functions with an implied return:\n            if (node.body.type !== 'BlockStatement') {\n              node.body = {\n                type: 'BlockStatement',\n                body: [{type: 'ReturnStatement', argument: node.body}]\n              }\n            }\n\n            node.body.body.unshift(...statements)\n          }\n\n          functionStack.pop()\n        }\n      }\n    })\n\n    // If a provider is used (and can be used), import it.\n    if (importProvider && providerImportSource) {\n      tree.body.unshift(\n        createImportProvider(providerImportSource, outputFormat)\n      )\n    }\n\n    // If potentially missing components are used.\n    if (createErrorHelper) {\n      /** @type {Array<Expression>} */\n      const message = [\n        {type: 'Literal', value: 'Expected '},\n        {\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'component'},\n          consequent: {type: 'Literal', value: 'component'},\n          alternate: {type: 'Literal', value: 'object'}\n        },\n        {type: 'Literal', value: ' `'},\n        {type: 'Identifier', name: 'id'},\n        {\n          type: 'Literal',\n          value:\n            '` to be defined: you likely forgot to import, pass, or provide it.'\n        }\n      ]\n\n      /** @type {Array<Identifier>} */\n      const parameters = [\n        {type: 'Identifier', name: 'id'},\n        {type: 'Identifier', name: 'component'}\n      ]\n\n      if (development) {\n        message.push({\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'place'},\n          consequent: toBinaryAddition([\n            {type: 'Literal', value: '\\nIt’s referenced in your code at `'},\n            {type: 'Identifier', name: 'place'},\n            {\n              type: 'Literal',\n              value: (file.path ? '` in `' + file.path : '') + '`'\n            }\n          ]),\n          alternate: {type: 'Literal', value: ''}\n        })\n\n        parameters.push({type: 'Identifier', name: 'place'})\n      }\n\n      tree.body.push({\n        type: 'FunctionDeclaration',\n        id: {type: 'Identifier', name: '_missingMdxReference'},\n        generator: false,\n        async: false,\n        params: parameters,\n        body: {\n          type: 'BlockStatement',\n          body: [\n            {\n              type: 'ThrowStatement',\n              argument: {\n                type: 'NewExpression',\n                callee: {type: 'Identifier', name: 'Error'},\n                arguments: [toBinaryAddition(message)]\n              }\n            }\n          ]\n        }\n      })\n    }\n\n    if (outputFormat === 'function-body') {\n      tree.body.unshift({\n        type: 'ExpressionStatement',\n        expression: {type: 'Literal', value: 'use strict'},\n        directive: 'use strict'\n      })\n    }\n  }\n}\n\n/**\n * @param {string} providerImportSource\n *   Provider source.\n * @param {'function-body' | 'program' | null | undefined} outputFormat\n *   Format.\n * @returns {ModuleDeclaration | Statement}\n *   Node.\n */\nfunction createImportProvider(providerImportSource, outputFormat) {\n  /** @type {Array<ImportSpecifier>} */\n  const specifiers = [\n    {\n      type: 'ImportSpecifier',\n      imported: {type: 'Identifier', name: 'useMDXComponents'},\n      local: {type: 'Identifier', name: '_provideComponents'}\n    }\n  ]\n\n  return outputFormat === 'function-body'\n    ? {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declarations: specifiersToDeclarations(\n          specifiers,\n          toIdOrMemberExpression(['arguments', 0])\n        )\n      }\n    : {\n        type: 'ImportDeclaration',\n        specifiers,\n        source: {type: 'Literal', value: providerImportSource}\n      }\n}\n\n/**\n * @param {Readonly<EstreeFunction>} node\n *   Node.\n * @param {string} name\n *   Name.\n * @returns {boolean}\n *   Whether `node` is a named function with `name`.\n */\nfunction isNamedFunction(node, name) {\n  return Boolean(node && 'id' in node && node.id && node.id.name === name)\n}\n\n/**\n * @param {Array<Scope>} scopes\n *   Scope.\n * @param {string} id\n *   Identifier.\n * @returns {boolean}\n *   Whether `id` is in `scope`.\n */\nfunction inScope(scopes, id) {\n  let index = scopes.length\n\n  while (index--) {\n    const scope = scopes[index]\n\n    if (scope.defined.includes(id)) {\n      return true\n    }\n  }\n\n  return false\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1852, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/plugin/rehype-remove-raw.js"],"sourcesContent":["/**\n * @import {Root} from 'hast'\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that removes raw HTML.\n *\n * This is needed if the format is `md` and `rehype-raw` was not used to parse\n * dangerous HTML into nodes.\n *\n * @returns\n *   Transform.\n */\nexport function rehypeRemoveRaw() {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'raw', function (_, index, parent) {\n      if (parent && typeof index === 'number') {\n        parent.children.splice(index, 1)\n        return index\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;;AAWO,SAAS;IACd;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,IAAA,kPAAK,EAAC,MAAM,OAAO,SAAU,CAAC,EAAE,KAAK,EAAE,MAAM;YAC3C,IAAI,UAAU,OAAO,UAAU,UAAU;gBACvC,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAC9B,OAAO;YACT;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1879, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/plugin/remark-mark-and-unravel.js"],"sourcesContent":["/**\n * @import {Root, RootContent} from 'mdast'\n */\n\nimport {collapseWhiteSpace} from 'collapse-white-space'\nimport {walk} from 'estree-walker'\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that unravels `<p><h1>x</h1></p>` but also\n * `<p><Component /></p>` (so it has no knowledge of “HTML”).\n *\n * It also marks JSX as being explicitly JSX, so when a user passes a `h1`\n * component, it is used for `# heading` but not for `<h1>heading</h1>`.\n *\n * @returns\n *   Transform.\n */\nexport function remarkMarkAndUnravel() {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, function (node, index, parent) {\n      let offset = -1\n      let all = true\n      let oneOrMore = false\n\n      if (parent && typeof index === 'number' && node.type === 'paragraph') {\n        const children = node.children\n\n        while (++offset < children.length) {\n          const child = children[offset]\n\n          if (\n            child.type === 'mdxJsxTextElement' ||\n            child.type === 'mdxTextExpression'\n          ) {\n            oneOrMore = true\n          } else if (\n            child.type === 'text' &&\n            collapseWhiteSpace(child.value, {style: 'html', trim: true}) === ''\n          ) {\n            // Empty.\n          } else {\n            all = false\n            break\n          }\n        }\n\n        if (all && oneOrMore) {\n          offset = -1\n\n          /** @type {Array<RootContent>} */\n          const newChildren = []\n\n          while (++offset < children.length) {\n            const child = children[offset]\n\n            if (child.type === 'mdxJsxTextElement') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxJsxFlowElement'\n            }\n\n            if (child.type === 'mdxTextExpression') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxFlowExpression'\n            }\n\n            if (\n              child.type === 'text' &&\n              /^[\\t\\r\\n ]+$/.test(String(child.value))\n            ) {\n              // Empty.\n            } else {\n              newChildren.push(child)\n            }\n          }\n\n          parent.children.splice(index, 1, ...newChildren)\n          return index\n        }\n      }\n\n      if (\n        node.type === 'mdxJsxFlowElement' ||\n        node.type === 'mdxJsxTextElement'\n      ) {\n        const data = node.data || (node.data = {})\n        data._mdxExplicitJsx = true\n      }\n\n      if (\n        (node.type === 'mdxFlowExpression' ||\n          node.type === 'mdxTextExpression' ||\n          node.type === 'mdxjsEsm') &&\n        node.data &&\n        node.data.estree\n      ) {\n        walk(node.data.estree, {\n          enter(node) {\n            if (node.type === 'JSXElement') {\n              const data = node.data || (node.data = {})\n              data._mdxExplicitJsx = true\n            }\n          }\n        })\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;AACA;AACA;;;;AAYO,SAAS;IACd;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,IAAA,kPAAK,EAAC,MAAM,SAAU,IAAI,EAAE,KAAK,EAAE,MAAM;YACvC,IAAI,SAAS,CAAC;YACd,IAAI,MAAM;YACV,IAAI,YAAY;YAEhB,IAAI,UAAU,OAAO,UAAU,YAAY,KAAK,IAAI,KAAK,aAAa;gBACpE,MAAM,WAAW,KAAK,QAAQ;gBAE9B,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;oBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;oBAE9B,IACE,MAAM,IAAI,KAAK,uBACf,MAAM,IAAI,KAAK,qBACf;wBACA,YAAY;oBACd,OAAO,IACL,MAAM,IAAI,KAAK,UACf,IAAA,gPAAkB,EAAC,MAAM,KAAK,EAAE;wBAAC,OAAO;wBAAQ,MAAM;oBAAI,OAAO,IACjE;oBACA,SAAS;oBACX,OAAO;wBACL,MAAM;wBACN;oBACF;gBACF;gBAEA,IAAI,OAAO,WAAW;oBACpB,SAAS,CAAC;oBAEV,+BAA+B,GAC/B,MAAM,cAAc,EAAE;oBAEtB,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;wBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;wBAE9B,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,wEAAwE;4BACxE,MAAM,IAAI,GAAG;wBACf;wBAEA,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,wEAAwE;4BACxE,MAAM,IAAI,GAAG;wBACf;wBAEA,IACE,MAAM,IAAI,KAAK,UACf,eAAe,IAAI,CAAC,OAAO,MAAM,KAAK,IACtC;wBACA,SAAS;wBACX,OAAO;4BACL,YAAY,IAAI,CAAC;wBACnB;oBACF;oBAEA,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO,MAAM;oBACpC,OAAO;gBACT;YACF;YAEA,IACE,KAAK,IAAI,KAAK,uBACd,KAAK,IAAI,KAAK,qBACd;gBACA,MAAM,OAAO,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;gBACzC,KAAK,eAAe,GAAG;YACzB;YAEA,IACE,CAAC,KAAK,IAAI,KAAK,uBACb,KAAK,IAAI,KAAK,uBACd,KAAK,IAAI,KAAK,UAAU,KAC1B,KAAK,IAAI,IACT,KAAK,IAAI,CAAC,MAAM,EAChB;gBACA,IAAA,qNAAI,EAAC,KAAK,IAAI,CAAC,MAAM,EAAE;oBACrB,OAAM,IAAI;wBACR,IAAI,KAAK,IAAI,KAAK,cAAc;4BAC9B,MAAM,OAAO,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;4BACzC,KAAK,eAAe,GAAG;wBACzB;oBACF;gBACF;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1962, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/node-types.js"],"sourcesContent":["/**\n * List of node types made by `mdast-util-mdx`, which have to be passed\n * through untouched from the mdast tree to the hast tree.\n */\nexport const nodeTypes = /** @type {const} */ ([\n  'mdxFlowExpression',\n  'mdxJsxFlowElement',\n  'mdxJsxTextElement',\n  'mdxTextExpression',\n  'mdxjsEsm'\n])\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,MAAM,YAAkC;IAC7C;IACA;IACA;IACA;IACA;CACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1980, "column": 0}, "map": {"version":3,"sources":["file:///home/tom/www2026/8_server/vercel/fumadocs/node_modules/.pnpm/%40mdx-js%2Bmdx%403.1.0_acorn%408.15.0/node_modules/%40mdx-js/mdx/lib/core.js"],"sourcesContent":["/**\n * @import {Program} from 'estree-jsx'\n * @import {Root} from 'mdast'\n * @import {Options as RehypeRecmaOptions} from 'rehype-recma'\n * @import {Options as RemarkRehypeOptions} from 'remark-rehype'\n * @import {SourceMapGenerator} from 'source-map'\n * @import {PluggableList, Processor} from 'unified'\n */\n\n/**\n * @typedef ProcessorOptions\n *   Configuration for `createProcessor`.\n * @property {typeof SourceMapGenerator | null | undefined} [SourceMapGenerator]\n *   Add a source map (object form) as the `map` field on the resulting file\n *   (optional).\n * @property {URL | string | null | undefined} [baseUrl]\n *   Use this URL as `import.meta.url` and resolve `import` and `export … from`\n *   relative to it (optional, example: `import.meta.url`).\n * @property {boolean | null | undefined} [development=false]\n *   Whether to add extra info to error messages in generated code and use the\n *   development automatic JSX runtime (`Fragment` and `jsxDEV` from\n *   `/jsx-dev-runtime`) (default: `false`);\n *   when using the webpack loader (`@mdx-js/loader`) or the Rollup integration\n *   (`@mdx-js/rollup`) through Vite, this is automatically inferred from how\n *   you configure those tools.\n * @property {RehypeRecmaOptions['elementAttributeNameCase']} [elementAttributeNameCase='react']\n *   Casing to use for attribute names (default: `'react'`);\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`;\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`;\n *   for JSX components written in MDX, the author has to be aware of which\n *   framework they use and write code accordingly;\n *   for AST nodes generated by this project, this option configures it\n * @property {'md' | 'mdx' | null | undefined} [format='mdx']\n *   format of the file (default: `'mdx'`);\n *   `'md'` means treat as markdown and `'mdx'` means treat as MDX.\n * @property {boolean | null | undefined} [jsx=false]\n *   Whether to keep JSX (default: `false`);\n *   the default is to compile JSX away so that the resulting file is\n *   immediately runnable.\n * @property {string | null | undefined} [jsxImportSource='react']\n *   Place to import automatic JSX runtimes from (default: `'react'`);\n *   when in the `automatic` runtime, this is used to define an import for\n *   `Fragment`, `jsx`, `jsxDEV`, and `jsxs`.\n * @property {'automatic' | 'classic' | null | undefined} [jsxRuntime='automatic']\n *   JSX runtime to use (default: `'automatic'`);\n *   the automatic runtime compiles to `import _jsx from\n *   '$importSource/jsx-runtime'\\n_jsx('p')`;\n *   the classic runtime compiles to calls such as `h('p')`.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {ReadonlyArray<string> | null | undefined} [mdExtensions]\n *   List of markdown extensions, with dot (default: `['.md', '.markdown', …]`);\n *   affects integrations.\n * @property {ReadonlyArray<string> | null | undefined} [mdxExtensions]\n *   List of MDX extensions, with dot (default: `['.mdx']`);\n *   affects integrations.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Output format to generate (default: `'program'`);\n *   in most cases `'program'` should be used, it results in a whole program;\n *   internally `evaluate` uses `'function-body'` to compile to\n *   code that can be passed to `run`;\n *   in some cases, you might want what `evaluate` does in separate steps, such\n *   as when compiling on the server and running on the client.\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Pragma for JSX, used in the classic runtime as an identifier for function\n *   calls: `<x />` to `React.createElement('x')` (default:\n *   `'React.createElement'`);\n *   when changing this, you should also define `pragmaFrag` and\n *   `pragmaImportSource` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Pragma for fragment symbol, used in the classic runtime as an identifier\n *   for unnamed calls: `<>` to `React.createElement(React.Fragment)` (default:\n *   `'React.Fragment'`);\n *   when changing this, you should also define `pragma` and\n *   `pragmaImportSource` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [pragmaImportSource='react']\n *   Where to import the identifier of `pragma` from, used in the classic\n *   runtime (default: `'react'`);\n *   to illustrate, when `pragma` is `'a.b'` and `pragmaImportSource` is `'c'`\n *   the following will be generated: `import a from 'c'` and things such as\n *   `a.b('h1', {})`.\n *   when changing this, you should also define `pragma` and `pragmaFrag` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [providerImportSource]\n *   Place to import a provider from (optional, example: `'@mdx-js/react'`);\n *   normally it’s used for runtimes that support context (React, Preact), but\n *   it can be used to inject components into the compiled code;\n *   the module must export and identifier `useMDXComponents` which is called\n *   without arguments to get an object of components (`MDXComponents` from\n *   `mdx/types.js`).\n * @property {PluggableList | null | undefined} [recmaPlugins]\n *   List of recma plugins (optional);\n *   this is a new ecosystem, currently in beta, to transform esast trees\n *   (JavaScript)\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark plugins (optional).\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype plugins (optional).\n * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype` (optional);\n *   the option `allowDangerousHtml` will always be set to `true` and the MDX\n *   nodes (see `nodeTypes`) are passed through;\n *   In particular, you might want to pass configuration for footnotes if your\n *   content is not in English.\n * @property {RehypeRecmaOptions['stylePropertyNameCase']} [stylePropertyNameCase='dom']\n *   Casing to use for property names in `style` objects (default: `'dom'`);\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`;\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`;\n *   for JSX components written in MDX, the author has to be aware of which\n *   framework they use and write code accordingly;\n *   for AST nodes generated by this project, this option configures it\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` properties on `td` and `th` into CSS `style`\n *   properties (default: `true`).\n */\n\nimport {unreachable} from 'devlop'\nimport recmaBuildJsx from 'recma-build-jsx'\nimport recmaJsx from 'recma-jsx'\nimport recmaStringify from 'recma-stringify'\nimport rehypeRecma from 'rehype-recma'\nimport remarkMdx from 'remark-mdx'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {unified} from 'unified'\nimport {recmaBuildJsxTransform} from './plugin/recma-build-jsx-transform.js'\nimport {recmaDocument} from './plugin/recma-document.js'\nimport {recmaJsxRewrite} from './plugin/recma-jsx-rewrite.js'\nimport {rehypeRemoveRaw} from './plugin/rehype-remove-raw.js'\nimport {remarkMarkAndUnravel} from './plugin/remark-mark-and-unravel.js'\nimport {nodeTypes} from './node-types.js'\n\nconst removedOptions = [\n  'compilers',\n  'filepath',\n  'hastPlugins',\n  'mdPlugins',\n  'skipExport',\n  'wrapExport'\n]\n\nlet warned = false\n\n/**\n * Create a processor to compile markdown or MDX to JavaScript.\n *\n * > **Note**: `format: 'detect'` is not allowed in `ProcessorOptions`.\n *\n * @param {Readonly<ProcessorOptions> | null | undefined} [options]\n *   Configuration (optional).\n * @return {Processor<Root, Program, Program, Program, string>}\n *   Processor.\n */\nexport function createProcessor(options) {\n  const settings = options || {}\n  let index = -1\n\n  while (++index < removedOptions.length) {\n    const key = removedOptions[index]\n    if (key in settings) {\n      unreachable(\n        'Unexpected removed option `' +\n          key +\n          '`; see <https://mdxjs.com/migrating/v2/> on how to migrate'\n      )\n    }\n  }\n\n  // @ts-expect-error: throw an error for a runtime value which is not allowed\n  // by the types.\n  if (settings.format === 'detect') {\n    unreachable(\n      \"Unexpected `format: 'detect'`, which is not supported by `createProcessor`, expected `'mdx'` or `'md'`\"\n    )\n  }\n\n  if (\n    (settings.jsxRuntime === 'classic' ||\n      settings.pragma ||\n      settings.pragmaFrag ||\n      settings.pragmaImportSource) &&\n    !warned\n  ) {\n    warned = true\n    console.warn(\n      \"Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate\"\n    )\n  }\n\n  const pipeline = unified().use(remarkParse)\n\n  if (settings.format !== 'md') {\n    pipeline.use(remarkMdx)\n  }\n\n  const remarkRehypeOptions = settings.remarkRehypeOptions || {}\n\n  pipeline\n    .use(remarkMarkAndUnravel)\n    .use(settings.remarkPlugins || [])\n    .use(remarkRehype, {\n      ...remarkRehypeOptions,\n      allowDangerousHtml: true,\n      passThrough: [...(remarkRehypeOptions.passThrough || []), ...nodeTypes]\n    })\n    .use(settings.rehypePlugins || [])\n\n  if (settings.format === 'md') {\n    pipeline.use(rehypeRemoveRaw)\n  }\n\n  pipeline\n    // @ts-expect-error: `Program` is close enough to a `Node`,\n    // but type inference has trouble with it and bridges.\n    .use(rehypeRecma, settings)\n    .use(recmaDocument, settings)\n    .use(recmaJsxRewrite, settings)\n\n  if (!settings.jsx) {\n    pipeline.use(recmaBuildJsx, settings).use(recmaBuildJsxTransform, settings)\n  }\n\n  pipeline\n    .use(recmaJsx)\n    .use(recmaStringify, settings)\n    .use(settings.recmaPlugins || [])\n\n  // @ts-expect-error: TS doesn’t get the plugins we added with if-statements.\n  return pipeline\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkHC;;;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAEA,MAAM,iBAAiB;IACrB;IACA;IACA;IACA;IACA;IACA;CACD;AAED,IAAI,SAAS;AAYN,SAAS,gBAAgB,OAAO;IACrC,MAAM,WAAW,WAAW,CAAC;IAC7B,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,eAAe,MAAM,CAAE;QACtC,MAAM,MAAM,cAAc,CAAC,MAAM;QACjC,IAAI,OAAO,UAAU;YACnB,IAAA,8MAAW,EACT,gCACE,MACA;QAEN;IACF;IAEA,4EAA4E;IAC5E,gBAAgB;IAChB,IAAI,SAAS,MAAM,KAAK,UAAU;QAChC,IAAA,8MAAW,EACT;IAEJ;IAEA,IACE,CAAC,SAAS,UAAU,KAAK,aACvB,SAAS,MAAM,IACf,SAAS,UAAU,IACnB,SAAS,kBAAkB,KAC7B,CAAC,QACD;QACA,SAAS;QACT,QAAQ,IAAI,CACV;IAEJ;IAEA,MAAM,WAAW,IAAA,uMAAO,IAAG,GAAG,CAAC,uNAAW;IAE1C,IAAI,SAAS,MAAM,KAAK,MAAM;QAC5B,SAAS,GAAG,CAAC,kNAAS;IACxB;IAEA,MAAM,sBAAsB,SAAS,mBAAmB,IAAI,CAAC;IAE7D,SACG,GAAG,CAAC,oSAAoB,EACxB,GAAG,CAAC,SAAS,aAAa,IAAI,EAAE,EAChC,GAAG,CAAC,yNAAY,EAAE;QACjB,GAAG,mBAAmB;QACtB,oBAAoB;QACpB,aAAa;eAAK,oBAAoB,WAAW,IAAI,EAAE;eAAM,4PAAS;SAAC;IACzE,GACC,GAAG,CAAC,SAAS,aAAa,IAAI,EAAE;IAEnC,IAAI,SAAS,MAAM,KAAK,MAAM;QAC5B,SAAS,GAAG,CAAC,sRAAe;IAC9B;IAEA,QACE,2DAA2D;IAC3D,sDAAsD;KACrD,GAAG,CAAC,sNAAW,EAAE,UACjB,GAAG,CAAC,8QAAa,EAAE,UACnB,GAAG,CAAC,sRAAe,EAAE;IAExB,IAAI,CAAC,SAAS,GAAG,EAAE;QACjB,SAAS,GAAG,CAAC,kOAAa,EAAE,UAAU,GAAG,CAAC,wSAAsB,EAAE;IACpE;IAEA,SACG,GAAG,CAAC,sOAAQ,EACZ,GAAG,CAAC,4NAAc,EAAE,UACpB,GAAG,CAAC,SAAS,YAAY,IAAI,EAAE;IAElC,4EAA4E;IAC5E,OAAO;AACT","ignoreList":[0],"debugId":null}}]
}