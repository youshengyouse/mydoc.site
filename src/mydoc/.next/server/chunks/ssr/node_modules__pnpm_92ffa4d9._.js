module.exports = [
"[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getUserAgent",
    ()=>getUserAgent
]);
function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
}
}),
"[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/register.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
__turbopack_context__.s([
    "register",
    ()=>register
]);
function register(state, name, method, options) {
    if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
    }
    if (!options) {
        options = {};
    }
    if (Array.isArray(name)) {
        return name.reverse().reduce((callback, name)=>{
            return register.bind(null, state, name, callback, options);
        }, method)();
    }
    return Promise.resolve().then(()=>{
        if (!state.registry[name]) {
            return method(options);
        }
        return state.registry[name].reduce((method, registered)=>{
            return registered.hook.bind(null, method, options);
        }, method)();
    });
}
}),
"[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/add.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
__turbopack_context__.s([
    "addHook",
    ()=>addHook
]);
function addHook(state, kind, name, hook) {
    const orig = hook;
    if (!state.registry[name]) {
        state.registry[name] = [];
    }
    if (kind === "before") {
        hook = (method, options)=>{
            return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
    }
    if (kind === "after") {
        hook = (method, options)=>{
            let result;
            return Promise.resolve().then(method.bind(null, options)).then((result_)=>{
                result = result_;
                return orig(result, options);
            }).then(()=>{
                return result;
            });
        };
    }
    if (kind === "error") {
        hook = (method, options)=>{
            return Promise.resolve().then(method.bind(null, options)).catch((error)=>{
                return orig(error, options);
            });
        };
    }
    state.registry[name].push({
        hook: hook,
        orig: orig
    });
}
}),
"[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/remove.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
__turbopack_context__.s([
    "removeHook",
    ()=>removeHook
]);
function removeHook(state, name, method) {
    if (!state.registry[name]) {
        return;
    }
    const index = state.registry[name].map((registered)=>{
        return registered.orig;
    }).indexOf(method);
    if (index === -1) {
        return;
    }
    state.registry[name].splice(index, 1);
}
}),
"[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/register.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$add$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/add.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$remove$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/lib/remove.js [app-rsc] (ecmascript)");
;
;
;
// bind with array of arguments: https://stackoverflow.com/a/21792913
const bind = Function.bind;
const bindable = bind.bind(bind);
function bindApi(hook, state, name) {
    const removeHookRef = bindable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$remove$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removeHook"], null).apply(null, name ? [
        state,
        name
    ] : [
        state
    ]);
    hook.api = {
        remove: removeHookRef
    };
    hook.remove = removeHookRef;
    [
        "before",
        "error",
        "after",
        "wrap"
    ].forEach((kind)=>{
        const args = name ? [
            state,
            kind,
            name
        ] : [
            state,
            kind
        ];
        hook[kind] = hook.api[kind] = bindable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$add$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addHook"], null).apply(null, args);
    });
}
function Singular() {
    const singularHookName = Symbol("Singular");
    const singularHookState = {
        registry: {}
    };
    const singularHook = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["register"].bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
}
function Collection() {
    const state = {
        registry: {}
    };
    const hook = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["register"].bind(null, state);
    bindApi(hook, state);
    return hook;
}
const __TURBOPACK__default__export__ = {
    Singular,
    Collection
};
}),
"[project]/node_modules/.pnpm/@octokit+endpoint@11.0.0/node_modules/@octokit/endpoint/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/defaults.js
__turbopack_context__.s([
    "endpoint",
    ()=>endpoint
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/defaults.js
var userAgent = `octokit-endpoint.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`;
var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
    },
    mediaType: {
        format: ""
    }
};
// pkg/dist-src/util/lowercase-keys.js
function lowercaseKeys(object) {
    if (!object) {
        return {};
    }
    return Object.keys(object).reduce((newObj, key)=>{
        newObj[key.toLowerCase()] = object[key];
        return newObj;
    }, {});
}
// pkg/dist-src/util/is-plain-object.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) return false;
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null) return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
// pkg/dist-src/util/merge-deep.js
function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key)=>{
        if (isPlainObject(options[key])) {
            if (!(key in defaults)) Object.assign(result, {
                [key]: options[key]
            });
            else result[key] = mergeDeep(defaults[key], options[key]);
        } else {
            Object.assign(result, {
                [key]: options[key]
            });
        }
    });
    return result;
}
// pkg/dist-src/util/remove-undefined-properties.js
function removeUndefinedProperties(obj) {
    for(const key in obj){
        if (obj[key] === void 0) {
            delete obj[key];
        }
    }
    return obj;
}
// pkg/dist-src/merge.js
function merge(defaults, route, options) {
    if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? {
            method,
            url
        } : {
            url: method
        }, options);
    } else {
        options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
        if (defaults && defaults.mediaType.previews?.length) {
            mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview)=>!mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
        }
        mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview)=>preview.replace(/-preview/, ""));
    }
    return mergedOptions;
}
// pkg/dist-src/util/add-query-parameters.js
function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
        return url;
    }
    return url + separator + names.map((name)=>{
        if (name === "q") {
            return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
}
// pkg/dist-src/util/extract-url-variable-names.js
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
    return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
        return [];
    }
    return matches.map(removeNonChars).reduce((a, b)=>a.concat(b), []);
}
// pkg/dist-src/util/omit.js
function omit(object, keysToOmit) {
    const result = {
        __proto__: null
    };
    for (const key of Object.keys(object)){
        if (keysToOmit.indexOf(key) === -1) {
            result[key] = object[key];
        }
    }
    return result;
}
// pkg/dist-src/util/url-template.js
function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
    }).join("");
}
function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
        return encodeUnreserved(key) + "=" + value;
    } else {
        return value;
    }
}
function isDefined(value) {
    return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
                value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        } else {
            if (modifier === "*") {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function(value2) {
                        result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
                    });
                } else {
                    Object.keys(value).forEach(function(k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            } else {
                const tmp = [];
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function(value2) {
                        tmp.push(encodeValue(operator, value2));
                    });
                } else {
                    Object.keys(value).forEach(function(k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeUnreserved(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }
                if (isKeyOperator(operator)) {
                    result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                } else if (tmp.length !== 0) {
                    result.push(tmp.join(","));
                }
            }
        }
    } else {
        if (operator === ";") {
            if (isDefined(value)) {
                result.push(encodeUnreserved(key));
            }
        } else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
        } else if (value === "") {
            result.push("");
        }
    }
    return result;
}
function parseUrl(template) {
    return {
        expand: expand.bind(null, template)
    };
}
function expand(template, context) {
    var operators = [
        "+",
        "#",
        ".",
        "/",
        ";",
        "?",
        "&"
    ];
    template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
        if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function(variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                    separator = "&";
                } else if (operator !== "#") {
                    separator = operator;
                }
                return (values.length !== 0 ? operator : "") + values.join(separator);
            } else {
                return values.join(",");
            }
        } else {
            return encodeReserved(literal);
        }
    });
    if (template === "/") {
        return template;
    } else {
        return template.replace(/\/$/, "");
    }
}
// pkg/dist-src/parse.js
function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType"
    ]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
        url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option)=>urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
        if (options.mediaType.format) {
            headers.accept = headers.accept.split(/,/).map((format)=>format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
        }
        if (url.endsWith("/graphql")) {
            if (options.mediaType.previews?.length) {
                const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
                headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview)=>{
                    const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
                    return `application/vnd.github.${preview}-preview${format}`;
                }).join(",");
            }
        }
    }
    if ([
        "GET",
        "HEAD"
    ].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
    } else {
        if ("data" in remainingParameters) {
            body = remainingParameters.data;
        } else {
            if (Object.keys(remainingParameters).length) {
                body = remainingParameters;
            }
        }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
    }
    if ([
        "PATCH",
        "PUT"
    ].includes(method) && typeof body === "undefined") {
        body = "";
    }
    return Object.assign({
        method,
        url,
        headers
    }, typeof body !== "undefined" ? {
        body
    } : null, options.request ? {
        request: options.request
    } : null);
}
// pkg/dist-src/endpoint-with-defaults.js
function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
}
// pkg/dist-src/with-defaults.js
function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
        DEFAULTS: DEFAULTS2,
        defaults: withDefaults.bind(null, DEFAULTS2),
        merge: merge.bind(null, DEFAULTS2),
        parse
    });
}
// pkg/dist-src/index.js
var endpoint = withDefaults(null, DEFAULTS);
;
}),
"[project]/node_modules/.pnpm/fast-content-type-parse@3.0.0/node_modules/fast-content-type-parse/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const NullObject = function NullObject() {};
NullObject.prototype = Object.create(null);
/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */ const paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */ const quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */ const mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
// default ContentType to prevent repeated object creation
const defaultContentType = {
    type: '',
    parameters: new NullObject()
};
Object.freeze(defaultContentType.parameters);
Object.freeze(defaultContentType);
/**
 * Parse media type to object.
 *
 * @param {string|object} header
 * @return {Object}
 * @public
 */ function parse(header) {
    if (typeof header !== 'string') {
        throw new TypeError('argument header is required and must be a string');
    }
    let index = header.indexOf(';');
    const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
        throw new TypeError('invalid media type');
    }
    const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
    };
    // parse parameters
    if (index === -1) {
        return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index;
    while(match = paramRE.exec(header)){
        if (match.index !== index) {
            throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);
            quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
    }
    if (index !== header.length) {
        throw new TypeError('invalid parameter format');
    }
    return result;
}
function safeParse(header) {
    if (typeof header !== 'string') {
        return defaultContentType;
    }
    let index = header.indexOf(';');
    const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
    }
    const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
    };
    // parse parameters
    if (index === -1) {
        return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index;
    while(match = paramRE.exec(header)){
        if (match.index !== index) {
            return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);
            quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
    }
    if (index !== header.length) {
        return defaultContentType;
    }
    return result;
}
module.exports.default = {
    parse,
    safeParse
};
module.exports.parse = parse;
module.exports.safeParse = safeParse;
module.exports.defaultContentType = defaultContentType;
}),
"[project]/node_modules/.pnpm/@octokit+request-error@7.0.0/node_modules/@octokit/request-error/dist-src/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RequestError",
    ()=>RequestError
]);
class RequestError extends Error {
    name;
    /**
   * http status code
   */ status;
    /**
   * Request options that lead to the error.
   */ request;
    /**
   * Response object if a response was received
   */ response;
    constructor(message, statusCode, options){
        super(message);
        this.name = "HttpError";
        this.status = Number.parseInt(statusCode);
        if (Number.isNaN(this.status)) {
            this.status = 0;
        }
        if ("response" in options) {
            this.response = options.response;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
                authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
            });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
    }
}
;
}),
"[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "request",
    ()=>request
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$endpoint$40$11$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$endpoint$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+endpoint@11.0.0/node_modules/@octokit/endpoint/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/defaults.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/fetch-wrapper.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fast$2d$content$2d$type$2d$parse$40$3$2e$0$2e$0$2f$node_modules$2f$fast$2d$content$2d$type$2d$parse$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/fast-content-type-parse@3.0.0/node_modules/fast-content-type-parse/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/fetch-wrapper.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request-error@7.0.0/node_modules/@octokit/request-error/dist-src/index.js [app-rsc] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/defaults.js
var defaults_default = {
    headers: {
        "user-agent": `octokit-request.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    }
};
;
// pkg/dist-src/is-plain-object.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) return false;
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null) return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
;
async function fetchWrapper(requestOptions) {
    const fetch = requestOptions.request?.fetch || globalThis.fetch;
    if (!fetch) {
        throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    }
    const log = requestOptions.request?.log || console;
    const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
    const body = isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
    const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value])=>[
            name,
            String(value)
        ]));
    let fetchResponse;
    try {
        fetchResponse = await fetch(requestOptions.url, {
            method: requestOptions.method,
            body,
            redirect: requestOptions.request?.redirect,
            headers: requestHeaders,
            signal: requestOptions.request?.signal,
            // duplex must be set if request.body is ReadableStream or Async Iterables.
            // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
            ...requestOptions.body && {
                duplex: "half"
            }
        });
    } catch (error) {
        let message = "Unknown Error";
        if (error instanceof Error) {
            if (error.name === "AbortError") {
                error.status = 500;
                throw error;
            }
            message = error.message;
            if (error.name === "TypeError" && "cause" in error) {
                if (error.cause instanceof Error) {
                    message = error.cause.message;
                } else if (typeof error.cause === "string") {
                    message = error.cause;
                }
            }
        }
        const requestError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"](message, 500, {
            request: requestOptions
        });
        requestError.cause = error;
        throw requestError;
    }
    const status = fetchResponse.status;
    const url = fetchResponse.url;
    const responseHeaders = {};
    for (const [key, value] of fetchResponse.headers){
        responseHeaders[key] = value;
    }
    const octokitResponse = {
        url,
        status,
        headers: responseHeaders,
        data: ""
    };
    if ("deprecation" in responseHeaders) {
        const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
        const deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
        return octokitResponse;
    }
    if (requestOptions.method === "HEAD") {
        if (status < 400) {
            return octokitResponse;
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"](fetchResponse.statusText, status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    if (status === 304) {
        octokitResponse.data = await getResponseData(fetchResponse);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"]("Not modified", status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    if (status >= 400) {
        octokitResponse.data = await getResponseData(fetchResponse);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"](toErrorMessage(octokitResponse.data), status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
    return octokitResponse;
}
async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (!contentType) {
        return response.text().catch(()=>"");
    }
    const mimetype = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fast$2d$content$2d$type$2d$parse$40$3$2e$0$2e$0$2f$node_modules$2f$fast$2d$content$2d$type$2d$parse$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["safeParse"])(contentType);
    if (isJSONResponse(mimetype)) {
        let text = "";
        try {
            text = await response.text();
            return JSON.parse(text);
        } catch (err) {
            return text;
        }
    } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
        return response.text().catch(()=>"");
    } else {
        return response.arrayBuffer().catch(()=>new ArrayBuffer(0));
    }
}
function isJSONResponse(mimetype) {
    return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
    if (typeof data === "string") {
        return data;
    }
    if (data instanceof ArrayBuffer) {
        return "Unknown error";
    }
    if ("message" in data) {
        const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
        return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v)=>JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
}
// pkg/dist-src/with-defaults.js
function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint2.parse(endpointOptions));
        }
        const request2 = (route2, parameters2)=>{
            return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
        };
        Object.assign(request2, {
            endpoint: endpoint2,
            defaults: withDefaults.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
    });
}
// pkg/dist-src/index.js
var request = withDefaults(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$endpoint$40$11$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$endpoint$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["endpoint"], defaults_default);
;
}),
"[project]/node_modules/.pnpm/@octokit+graphql@9.0.1/node_modules/@octokit/graphql/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "GraphqlResponseError",
    ()=>GraphqlResponseError,
    "graphql",
    ()=>graphql2,
    "withCustomRequest",
    ()=>withCustomRequest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
;
// pkg/dist-src/error.js
function _buildMessageForResponseErrors(data) {
    return `Request failed due to following response errors:
` + data.errors.map((e)=>` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
    constructor(request2, headers, response){
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "GraphqlResponseError";
    errors;
    data;
};
// pkg/dist-src/graphql.js
var NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
    "operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = [
    "query",
    "method",
    "url"
];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
    if (options) {
        if (typeof query === "string" && "query" in options) {
            return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for(const key in options){
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
            return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({
        query
    }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key)=>{
        if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
        }
        if (!result.variables) {
            result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
    }, {});
    const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request2(requestOptions).then((response)=>{
        if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)){
                headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
    });
}
// pkg/dist-src/with-defaults.js
function withDefaults(request2, newDefaults) {
    const newRequest = request2.defaults(newDefaults);
    const newApi = (query, options)=>{
        return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: newRequest.endpoint
    });
}
// pkg/dist-src/index.js
var graphql2 = withDefaults(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"], {
    headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    },
    method: "POST",
    url: "/graphql"
});
function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql"
    });
}
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-token@6.0.0/node_modules/@octokit/auth-token/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/is-jwt.js
__turbopack_context__.s([
    "createTokenAuth",
    ()=>createTokenAuth
]);
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
// pkg/dist-src/auth.js
async function auth(token) {
    const isApp = isJWT(token);
    const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
    const isUserToServer = token.startsWith("ghu_");
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
        type: "token",
        token,
        tokenType
    };
}
// pkg/dist-src/with-authorization-prefix.js
function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
    }
    return `token ${token}`;
}
// pkg/dist-src/hook.js
async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
}
// pkg/dist-src/index.js
var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
    });
};
;
}),
"[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/version.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>VERSION
]);
const VERSION = "7.0.2";
;
}),
"[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Octokit",
    ()=>Octokit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/before-after-hook@4.0.0/node_modules/before-after-hook/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$graphql$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+graphql@9.0.1/node_modules/@octokit/graphql/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$token$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$token$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-token@6.0.0/node_modules/@octokit/auth-token/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/version.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
const noop = ()=>{};
const consoleWarn = console.warn.bind(console);
const consoleError = console.error.bind(console);
const userAgentTrail = `octokit-core.js/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VERSION"]} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`;
class Octokit {
    static VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VERSION"];
    static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
            constructor(...args){
                const options = args[0] || {};
                if (typeof defaults === "function") {
                    super(defaults(options));
                    return;
                }
                super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
                    userAgent: `${options.userAgent} ${defaults.userAgent}`
                } : null));
            }
        };
        return OctokitWithDefaults;
    }
    static plugins = [];
    /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */ static plugin(...newPlugins) {
        const currentPlugins = this.plugins;
        const NewOctokit = class extends this {
            static plugins = currentPlugins.concat(newPlugins.filter((plugin)=>!currentPlugins.includes(plugin)));
        };
        return NewOctokit;
    }
    constructor(options = {}){
        const hook = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$before$2d$after$2d$hook$40$4$2e$0$2e$0$2f$node_modules$2f$before$2d$after$2d$hook$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].Collection();
        const requestDefaults = {
            baseUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
                // @ts-ignore internal usage only, no need to type
                hook: hook.bind(null, "request")
            }),
            mediaType: {
                previews: [],
                format: ""
            }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
        if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].defaults(requestDefaults);
        this.graphql = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$graphql$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["withCustomRequest"])(this.request).defaults(requestDefaults);
        this.log = Object.assign({
            debug: noop,
            info: noop,
            warn: consoleWarn,
            error: consoleError
        }, options.log);
        this.hook = hook;
        if (!options.authStrategy) {
            if (!options.auth) {
                this.auth = async ()=>({
                        type: "unauthenticated"
                    });
            } else {
                const auth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$token$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$token$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createTokenAuth"])(options.auth);
                hook.wrap("request", auth.hook);
                this.auth = auth;
            }
        } else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(Object.assign({
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions
            }, options.auth));
            hook.wrap("request", auth.hook);
            this.auth = auth;
        }
        const classConstructor = this.constructor;
        for(let i = 0; i < classConstructor.plugins.length; ++i){
            Object.assign(this, classConstructor.plugins[i](this, options));
        }
    }
    // assigned during constructor
    request;
    graphql;
    log;
    hook;
    // TODO: type `octokit.auth` based on passed options.authStrategy
    auth;
}
;
}),
"[project]/node_modules/.pnpm/@octokit+plugin-paginate-rest@13.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/version.js
__turbopack_context__.s([
    "composePaginateRest",
    ()=>composePaginateRest,
    "isPaginatingEndpoint",
    ()=>isPaginatingEndpoint,
    "paginateRest",
    ()=>paginateRest,
    "paginatingEndpoints",
    ()=>paginatingEndpoints
]);
var VERSION = "0.0.0-development";
// pkg/dist-src/normalize-paginated-list-response.js
function normalizePaginatedListResponse(response) {
    if (!response.data) {
        return {
            ...response,
            data: []
        };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization) return response;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
}
// pkg/dist-src/iterator.js
function iterator(octokit, route, parameters) {
    const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
        [Symbol.asyncIterator]: ()=>({
                async next () {
                    if (!url) return {
                        done: true
                    };
                    try {
                        const response = await requestMethod({
                            method,
                            url,
                            headers
                        });
                        const normalizedResponse = normalizePaginatedListResponse(response);
                        url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
                        return {
                            value: normalizedResponse
                        };
                    } catch (error) {
                        if (error.status !== 409) throw error;
                        url = "";
                        return {
                            value: {
                                status: 200,
                                headers: {},
                                data: []
                            }
                        };
                    }
                }
            })
    };
}
// pkg/dist-src/paginate.js
function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result)=>{
        if (result.done) {
            return results;
        }
        let earlyExit = false;
        function done() {
            earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
            return results;
        }
        return gather(octokit, results, iterator2, mapFn);
    });
}
// pkg/dist-src/compose-paginate.js
var composePaginateRest = Object.assign(paginate, {
    iterator
});
// pkg/dist-src/generated/paginating-endpoints.js
var paginatingEndpoints = [
    "GET /advisories",
    "GET /app/hook/deliveries",
    "GET /app/installation-requests",
    "GET /app/installations",
    "GET /assignments/{assignment_id}/accepted_assignments",
    "GET /classrooms",
    "GET /classrooms/{classroom_id}/assignments",
    "GET /enterprises/{enterprise}/code-security/configurations",
    "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/hosted-runners",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runner-groups",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/attestations/{subject_digest}",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/campaigns",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/code-security/configurations",
    "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/copilot/billing/seats",
    "GET /orgs/{org}/copilot/metrics",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}",
    "GET /orgs/{org}/insights/api/subject-stats",
    "GET /orgs/{org}/insights/api/user-stats/{user_id}",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/organization-roles/{role_id}/teams",
    "GET /orgs/{org}/organization-roles/{role_id}/users",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/personal-access-token-requests",
    "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
    "GET /orgs/{org}/personal-access-tokens",
    "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
    "GET /orgs/{org}/private-registries",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/properties/values",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/rulesets",
    "GET /orgs/{org}/rulesets/rule-suites",
    "GET /orgs/{org}/rulesets/{ruleset_id}/history",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/security-advisories",
    "GET /orgs/{org}/settings/network-configurations",
    "GET /orgs/{org}/team/{team_slug}/copilot/metrics",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/organization-secrets",
    "GET /repos/{owner}/{repo}/actions/organization-variables",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/activity",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/attestations/{subject_digest}",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/rules/branches/{branch}",
    "GET /repos/{owner}/{repo}/rulesets",
    "GET /repos/{owner}/{repo}/rulesets/rule-suites",
    "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/security-advisories",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/social_accounts",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/attestations/{subject_digest}",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/social_accounts",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions"
];
// pkg/dist-src/paginating-endpoints.js
function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
    } else {
        return false;
    }
}
// pkg/dist-src/index.js
function paginateRest(octokit) {
    return {
        paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit)
        })
    };
}
paginateRest.VERSION = VERSION;
;
}),
"[project]/node_modules/.pnpm/@octokit+plugin-paginate-graphql@6.0.0_@octokit+core@7.0.2/node_modules/@octokit/plugin-paginate-graphql/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/errors.js
__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "paginateGraphQL",
    ()=>paginateGraphQL
]);
var generateMessage = (path, cursorValue)=>`The cursor at "${path.join(",")}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`;
var MissingCursorChange = class extends Error {
    constructor(pageInfo, cursorValue){
        super(generateMessage(pageInfo.pathInQuery, cursorValue));
        this.pageInfo = pageInfo;
        this.cursorValue = cursorValue;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "MissingCursorChangeError";
};
var MissingPageInfo = class extends Error {
    constructor(response){
        super(`No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(response, null, 2)}`);
        this.response = response;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "MissingPageInfo";
};
// pkg/dist-src/object-helpers.js
var isObject = (value)=>Object.prototype.toString.call(value) === "[object Object]";
function findPaginatedResourcePath(responseData) {
    const paginatedResourcePath = deepFindPathToProperty(responseData, "pageInfo");
    if (paginatedResourcePath.length === 0) {
        throw new MissingPageInfo(responseData);
    }
    return paginatedResourcePath;
}
var deepFindPathToProperty = (object, searchProp, path = [])=>{
    for (const key of Object.keys(object)){
        const currentPath = [
            ...path,
            key
        ];
        const currentValue = object[key];
        if (isObject(currentValue)) {
            if (currentValue.hasOwnProperty(searchProp)) {
                return currentPath;
            }
            const result = deepFindPathToProperty(currentValue, searchProp, currentPath);
            if (result.length > 0) {
                return result;
            }
        }
    }
    return [];
};
var get = (object, path)=>{
    return path.reduce((current, nextProperty)=>current[nextProperty], object);
};
var set = (object, path, mutator)=>{
    const lastProperty = path[path.length - 1];
    const parentPath = [
        ...path
    ].slice(0, -1);
    const parent = get(object, parentPath);
    if (typeof mutator === "function") {
        parent[lastProperty] = mutator(parent[lastProperty]);
    } else {
        parent[lastProperty] = mutator;
    }
};
// pkg/dist-src/extract-page-info.js
var extractPageInfos = (responseData)=>{
    const pageInfoPath = findPaginatedResourcePath(responseData);
    return {
        pathInQuery: pageInfoPath,
        pageInfo: get(responseData, [
            ...pageInfoPath,
            "pageInfo"
        ])
    };
};
// pkg/dist-src/page-info.js
var isForwardSearch = (givenPageInfo)=>{
    return givenPageInfo.hasOwnProperty("hasNextPage");
};
var getCursorFrom = (pageInfo)=>isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;
var hasAnotherPage = (pageInfo)=>isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;
// pkg/dist-src/iterator.js
var createIterator = (octokit)=>{
    return (query, initialParameters = {})=>{
        let nextPageExists = true;
        let parameters = {
            ...initialParameters
        };
        return {
            [Symbol.asyncIterator]: ()=>({
                    async next () {
                        if (!nextPageExists) return {
                            done: true,
                            value: {}
                        };
                        const response = await octokit.graphql(query, parameters);
                        const pageInfoContext = extractPageInfos(response);
                        const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);
                        nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);
                        if (nextPageExists && nextCursorValue === parameters.cursor) {
                            throw new MissingCursorChange(pageInfoContext, nextCursorValue);
                        }
                        parameters = {
                            ...parameters,
                            cursor: nextCursorValue
                        };
                        return {
                            done: false,
                            value: response
                        };
                    }
                })
        };
    };
};
// pkg/dist-src/merge-responses.js
var mergeResponses = (response1, response2)=>{
    if (Object.keys(response1).length === 0) {
        return Object.assign(response1, response2);
    }
    const path = findPaginatedResourcePath(response1);
    const nodesPath = [
        ...path,
        "nodes"
    ];
    const newNodes = get(response2, nodesPath);
    if (newNodes) {
        set(response1, nodesPath, (values)=>{
            return [
                ...values,
                ...newNodes
            ];
        });
    }
    const edgesPath = [
        ...path,
        "edges"
    ];
    const newEdges = get(response2, edgesPath);
    if (newEdges) {
        set(response1, edgesPath, (values)=>{
            return [
                ...values,
                ...newEdges
            ];
        });
    }
    const pageInfoPath = [
        ...path,
        "pageInfo"
    ];
    set(response1, pageInfoPath, get(response2, pageInfoPath));
    return response1;
};
// pkg/dist-src/paginate.js
var createPaginate = (octokit)=>{
    const iterator = createIterator(octokit);
    return async (query, initialParameters = {})=>{
        let mergedResponse = {};
        for await (const response of iterator(query, initialParameters)){
            mergedResponse = mergeResponses(mergedResponse, response);
        }
        return mergedResponse;
    };
};
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/index.js
function paginateGraphQL(octokit) {
    return {
        graphql: Object.assign(octokit.graphql, {
            paginate: Object.assign(createPaginate(octokit), {
                iterator: createIterator(octokit)
            })
        })
    };
}
;
}),
"[project]/node_modules/.pnpm/bottleneck@2.19.5/node_modules/bottleneck/light.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.
  * https://github.com/SGrondin/bottleneck
  */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
    function getCjsExportFromNamespace(n) {
        return n && n['default'] || n;
    }
    var load = function(received, defaults, onto = {}) {
        var k, ref, v;
        for(k in defaults){
            v = defaults[k];
            onto[k] = (ref = received[k]) != null ? ref : v;
        }
        return onto;
    };
    var overwrite = function(received, defaults, onto = {}) {
        var k, v;
        for(k in received){
            v = received[k];
            if (defaults[k] !== void 0) {
                onto[k] = v;
            }
        }
        return onto;
    };
    var parser = {
        load: load,
        overwrite: overwrite
    };
    var DLList;
    DLList = class DLList {
        constructor(incr, decr){
            this.incr = incr;
            this.decr = decr;
            this._first = null;
            this._last = null;
            this.length = 0;
        }
        push(value) {
            var node;
            this.length++;
            if (typeof this.incr === "function") {
                this.incr();
            }
            node = {
                value,
                prev: this._last,
                next: null
            };
            if (this._last != null) {
                this._last.next = node;
                this._last = node;
            } else {
                this._first = this._last = node;
            }
            return void 0;
        }
        shift() {
            var value;
            if (this._first == null) {
                return;
            } else {
                this.length--;
                if (typeof this.decr === "function") {
                    this.decr();
                }
            }
            value = this._first.value;
            if ((this._first = this._first.next) != null) {
                this._first.prev = null;
            } else {
                this._last = null;
            }
            return value;
        }
        first() {
            if (this._first != null) {
                return this._first.value;
            }
        }
        getArray() {
            var node, ref, results;
            node = this._first;
            results = [];
            while(node != null){
                results.push((ref = node, node = node.next, ref.value));
            }
            return results;
        }
        forEachShift(cb) {
            var node;
            node = this.shift();
            while(node != null){
                cb(node), node = this.shift();
            }
            return void 0;
        }
        debug() {
            var node, ref, ref1, ref2, results;
            node = this._first;
            results = [];
            while(node != null){
                results.push((ref = node, node = node.next, {
                    value: ref.value,
                    prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
                    next: (ref2 = ref.next) != null ? ref2.value : void 0
                }));
            }
            return results;
        }
    };
    var DLList_1 = DLList;
    var Events;
    Events = class Events {
        constructor(instance){
            this.instance = instance;
            this._events = {};
            if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
                throw new Error("An Emitter already exists for this object");
            }
            this.instance.on = (name, cb)=>{
                return this._addListener(name, "many", cb);
            };
            this.instance.once = (name, cb)=>{
                return this._addListener(name, "once", cb);
            };
            this.instance.removeAllListeners = (name = null)=>{
                if (name != null) {
                    return delete this._events[name];
                } else {
                    return this._events = {};
                }
            };
        }
        _addListener(name, status, cb) {
            var base;
            if ((base = this._events)[name] == null) {
                base[name] = [];
            }
            this._events[name].push({
                cb,
                status
            });
            return this.instance;
        }
        listenerCount(name) {
            if (this._events[name] != null) {
                return this._events[name].length;
            } else {
                return 0;
            }
        }
        async trigger(name, ...args) {
            var e, promises;
            try {
                if (name !== "debug") {
                    this.trigger("debug", `Event triggered: ${name}`, args);
                }
                if (this._events[name] == null) {
                    return;
                }
                this._events[name] = this._events[name].filter(function(listener) {
                    return listener.status !== "none";
                });
                promises = this._events[name].map(async (listener)=>{
                    var e, returned;
                    if (listener.status === "none") {
                        return;
                    }
                    if (listener.status === "once") {
                        listener.status = "none";
                    }
                    try {
                        returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                        if (typeof (returned != null ? returned.then : void 0) === "function") {
                            return await returned;
                        } else {
                            return returned;
                        }
                    } catch (error) {
                        e = error;
                        {
                            this.trigger("error", e);
                        }
                        return null;
                    }
                });
                return (await Promise.all(promises)).find(function(x) {
                    return x != null;
                });
            } catch (error) {
                e = error;
                {
                    this.trigger("error", e);
                }
                return null;
            }
        }
    };
    var Events_1 = Events;
    var DLList$1, Events$1, Queues;
    DLList$1 = DLList_1;
    Events$1 = Events_1;
    Queues = class Queues {
        constructor(num_priorities){
            var i;
            this.Events = new Events$1(this);
            this._length = 0;
            this._lists = (function() {
                var j, ref, results;
                results = [];
                for(i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j){
                    results.push(new DLList$1(()=>{
                        return this.incr();
                    }, ()=>{
                        return this.decr();
                    }));
                }
                return results;
            }).call(this);
        }
        incr() {
            if (this._length++ === 0) {
                return this.Events.trigger("leftzero");
            }
        }
        decr() {
            if (--this._length === 0) {
                return this.Events.trigger("zero");
            }
        }
        push(job) {
            return this._lists[job.options.priority].push(job);
        }
        queued(priority) {
            if (priority != null) {
                return this._lists[priority].length;
            } else {
                return this._length;
            }
        }
        shiftAll(fn) {
            return this._lists.forEach(function(list) {
                return list.forEachShift(fn);
            });
        }
        getFirst(arr = this._lists) {
            var j, len, list;
            for(j = 0, len = arr.length; j < len; j++){
                list = arr[j];
                if (list.length > 0) {
                    return list;
                }
            }
            return [];
        }
        shiftLastFrom(priority) {
            return this.getFirst(this._lists.slice(priority).reverse()).shift();
        }
    };
    var Queues_1 = Queues;
    var BottleneckError;
    BottleneckError = class BottleneckError extends Error {
    };
    var BottleneckError_1 = BottleneckError;
    var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser$1 = parser;
    BottleneckError$1 = BottleneckError_1;
    Job = class Job {
        constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise1){
            this.task = task;
            this.args = args;
            this.rejectOnDrop = rejectOnDrop;
            this.Events = Events;
            this._states = _states;
            this.Promise = Promise1;
            this.options = parser$1.load(options, jobDefaults);
            this.options.priority = this._sanitizePriority(this.options.priority);
            if (this.options.id === jobDefaults.id) {
                this.options.id = `${this.options.id}-${this._randomIndex()}`;
            }
            this.promise = new this.Promise((_resolve, _reject)=>{
                this._resolve = _resolve;
                this._reject = _reject;
            });
            this.retryCount = 0;
        }
        _sanitizePriority(priority) {
            var sProperty;
            sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
            if (sProperty < 0) {
                return 0;
            } else if (sProperty > NUM_PRIORITIES - 1) {
                return NUM_PRIORITIES - 1;
            } else {
                return sProperty;
            }
        }
        _randomIndex() {
            return Math.random().toString(36).slice(2);
        }
        doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
            if (this._states.remove(this.options.id)) {
                if (this.rejectOnDrop) {
                    this._reject(error != null ? error : new BottleneckError$1(message));
                }
                this.Events.trigger("dropped", {
                    args: this.args,
                    options: this.options,
                    task: this.task,
                    promise: this.promise
                });
                return true;
            } else {
                return false;
            }
        }
        _assertStatus(expected) {
            var status;
            status = this._states.jobStatus(this.options.id);
            if (!(status === expected || expected === "DONE" && status === null)) {
                throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
            }
        }
        doReceive() {
            this._states.start(this.options.id);
            return this.Events.trigger("received", {
                args: this.args,
                options: this.options
            });
        }
        doQueue(reachedHWM, blocked) {
            this._assertStatus("RECEIVED");
            this._states.next(this.options.id);
            return this.Events.trigger("queued", {
                args: this.args,
                options: this.options,
                reachedHWM,
                blocked
            });
        }
        doRun() {
            if (this.retryCount === 0) {
                this._assertStatus("QUEUED");
                this._states.next(this.options.id);
            } else {
                this._assertStatus("EXECUTING");
            }
            return this.Events.trigger("scheduled", {
                args: this.args,
                options: this.options
            });
        }
        async doExecute(chained, clearGlobalState, run, free) {
            var error, eventInfo, passed;
            if (this.retryCount === 0) {
                this._assertStatus("RUNNING");
                this._states.next(this.options.id);
            } else {
                this._assertStatus("EXECUTING");
            }
            eventInfo = {
                args: this.args,
                options: this.options,
                retryCount: this.retryCount
            };
            this.Events.trigger("executing", eventInfo);
            try {
                passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
                if (clearGlobalState()) {
                    this.doDone(eventInfo);
                    await free(this.options, eventInfo);
                    this._assertStatus("DONE");
                    return this._resolve(passed);
                }
            } catch (error1) {
                error = error1;
                return this._onFailure(error, eventInfo, clearGlobalState, run, free);
            }
        }
        doExpire(clearGlobalState, run, free) {
            var error, eventInfo;
            if (this._states.jobStatus(this.options.id === "RUNNING")) {
                this._states.next(this.options.id);
            }
            this._assertStatus("EXECUTING");
            eventInfo = {
                args: this.args,
                options: this.options,
                retryCount: this.retryCount
            };
            error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
            return this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
        async _onFailure(error, eventInfo, clearGlobalState, run, free) {
            var retry, retryAfter;
            if (clearGlobalState()) {
                retry = await this.Events.trigger("failed", error, eventInfo);
                if (retry != null) {
                    retryAfter = ~~retry;
                    this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
                    this.retryCount++;
                    return run(retryAfter);
                } else {
                    this.doDone(eventInfo);
                    await free(this.options, eventInfo);
                    this._assertStatus("DONE");
                    return this._reject(error);
                }
            }
        }
        doDone(eventInfo) {
            this._assertStatus("EXECUTING");
            this._states.next(this.options.id);
            return this.Events.trigger("done", eventInfo);
        }
    };
    var Job_1 = Job;
    var BottleneckError$2, LocalDatastore, parser$2;
    parser$2 = parser;
    BottleneckError$2 = BottleneckError_1;
    LocalDatastore = class LocalDatastore {
        constructor(instance, storeOptions, storeInstanceOptions){
            this.instance = instance;
            this.storeOptions = storeOptions;
            this.clientId = this.instance._randomIndex();
            parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
            this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
            this._running = 0;
            this._done = 0;
            this._unblockTime = 0;
            this.ready = this.Promise.resolve();
            this.clients = {};
            this._startHeartbeat();
        }
        _startHeartbeat() {
            var base;
            if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
                return typeof (base = this.heartbeat = setInterval(()=>{
                    var amount, incr, maximum, now, reservoir;
                    now = Date.now();
                    if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
                        this._lastReservoirRefresh = now;
                        this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
                        this.instance._drainAll(this.computeCapacity());
                    }
                    if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
                        ({ reservoirIncreaseAmount: amount, reservoirIncreaseMaximum: maximum, reservoir } = this.storeOptions);
                        this._lastReservoirIncrease = now;
                        incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
                        if (incr > 0) {
                            this.storeOptions.reservoir += incr;
                            return this.instance._drainAll(this.computeCapacity());
                        }
                    }
                }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
            } else {
                return clearInterval(this.heartbeat);
            }
        }
        async __publish__(message) {
            await this.yieldLoop();
            return this.instance.Events.trigger("message", message.toString());
        }
        async __disconnect__(flush) {
            await this.yieldLoop();
            clearInterval(this.heartbeat);
            return this.Promise.resolve();
        }
        yieldLoop(t = 0) {
            return new this.Promise(function(resolve, reject) {
                return setTimeout(resolve, t);
            });
        }
        computePenalty() {
            var ref;
            return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;
        }
        async __updateSettings__(options) {
            await this.yieldLoop();
            parser$2.overwrite(options, options, this.storeOptions);
            this._startHeartbeat();
            this.instance._drainAll(this.computeCapacity());
            return true;
        }
        async __running__() {
            await this.yieldLoop();
            return this._running;
        }
        async __queued__() {
            await this.yieldLoop();
            return this.instance.queued();
        }
        async __done__() {
            await this.yieldLoop();
            return this._done;
        }
        async __groupCheck__(time) {
            await this.yieldLoop();
            return this._nextRequest + this.timeout < time;
        }
        computeCapacity() {
            var maxConcurrent, reservoir;
            ({ maxConcurrent, reservoir } = this.storeOptions);
            if (maxConcurrent != null && reservoir != null) {
                return Math.min(maxConcurrent - this._running, reservoir);
            } else if (maxConcurrent != null) {
                return maxConcurrent - this._running;
            } else if (reservoir != null) {
                return reservoir;
            } else {
                return null;
            }
        }
        conditionsCheck(weight) {
            var capacity;
            capacity = this.computeCapacity();
            return capacity == null || weight <= capacity;
        }
        async __incrementReservoir__(incr) {
            var reservoir;
            await this.yieldLoop();
            reservoir = this.storeOptions.reservoir += incr;
            this.instance._drainAll(this.computeCapacity());
            return reservoir;
        }
        async __currentReservoir__() {
            await this.yieldLoop();
            return this.storeOptions.reservoir;
        }
        isBlocked(now) {
            return this._unblockTime >= now;
        }
        check(weight, now) {
            return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
        }
        async __check__(weight) {
            var now;
            await this.yieldLoop();
            now = Date.now();
            return this.check(weight, now);
        }
        async __register__(index, weight, expiration) {
            var now, wait;
            await this.yieldLoop();
            now = Date.now();
            if (this.conditionsCheck(weight)) {
                this._running += weight;
                if (this.storeOptions.reservoir != null) {
                    this.storeOptions.reservoir -= weight;
                }
                wait = Math.max(this._nextRequest - now, 0);
                this._nextRequest = now + wait + this.storeOptions.minTime;
                return {
                    success: true,
                    wait,
                    reservoir: this.storeOptions.reservoir
                };
            } else {
                return {
                    success: false
                };
            }
        }
        strategyIsBlock() {
            return this.storeOptions.strategy === 3;
        }
        async __submit__(queueLength, weight) {
            var blocked, now, reachedHWM;
            await this.yieldLoop();
            if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
                throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
            }
            now = Date.now();
            reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
            blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
            if (blocked) {
                this._unblockTime = now + this.computePenalty();
                this._nextRequest = this._unblockTime + this.storeOptions.minTime;
                this.instance._dropAllQueued();
            }
            return {
                reachedHWM,
                blocked,
                strategy: this.storeOptions.strategy
            };
        }
        async __free__(index, weight) {
            await this.yieldLoop();
            this._running -= weight;
            this._done += weight;
            this.instance._drainAll(this.computeCapacity());
            return {
                running: this._running
            };
        }
    };
    var LocalDatastore_1 = LocalDatastore;
    var BottleneckError$3, States;
    BottleneckError$3 = BottleneckError_1;
    States = class States {
        constructor(status1){
            this.status = status1;
            this._jobs = {};
            this.counts = this.status.map(function() {
                return 0;
            });
        }
        next(id) {
            var current, next;
            current = this._jobs[id];
            next = current + 1;
            if (current != null && next < this.status.length) {
                this.counts[current]--;
                this.counts[next]++;
                return this._jobs[id]++;
            } else if (current != null) {
                this.counts[current]--;
                return delete this._jobs[id];
            }
        }
        start(id) {
            var initial;
            initial = 0;
            this._jobs[id] = initial;
            return this.counts[initial]++;
        }
        remove(id) {
            var current;
            current = this._jobs[id];
            if (current != null) {
                this.counts[current]--;
                delete this._jobs[id];
            }
            return current != null;
        }
        jobStatus(id) {
            var ref;
            return (ref = this.status[this._jobs[id]]) != null ? ref : null;
        }
        statusJobs(status) {
            var k, pos, ref, results, v;
            if (status != null) {
                pos = this.status.indexOf(status);
                if (pos < 0) {
                    throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);
                }
                ref = this._jobs;
                results = [];
                for(k in ref){
                    v = ref[k];
                    if (v === pos) {
                        results.push(k);
                    }
                }
                return results;
            } else {
                return Object.keys(this._jobs);
            }
        }
        statusCounts() {
            return this.counts.reduce((acc, v, i)=>{
                acc[this.status[i]] = v;
                return acc;
            }, {});
        }
    };
    var States_1 = States;
    var DLList$2, Sync;
    DLList$2 = DLList_1;
    Sync = class Sync {
        constructor(name, Promise1){
            this.schedule = this.schedule.bind(this);
            this.name = name;
            this.Promise = Promise1;
            this._running = 0;
            this._queue = new DLList$2();
        }
        isEmpty() {
            return this._queue.length === 0;
        }
        async _tryToRun() {
            var args, cb, error, reject, resolve, returned, task;
            if (this._running < 1 && this._queue.length > 0) {
                this._running++;
                ({ task, args, resolve, reject } = this._queue.shift());
                cb = await async function() {
                    try {
                        returned = await task(...args);
                        return function() {
                            return resolve(returned);
                        };
                    } catch (error1) {
                        error = error1;
                        return function() {
                            return reject(error);
                        };
                    }
                }();
                this._running--;
                this._tryToRun();
                return cb();
            }
        }
        schedule(task, ...args) {
            var promise, reject, resolve;
            resolve = reject = null;
            promise = new this.Promise(function(_resolve, _reject) {
                resolve = _resolve;
                return reject = _reject;
            });
            this._queue.push({
                task,
                args,
                resolve,
                reject
            });
            this._tryToRun();
            return promise;
        }
    };
    var Sync_1 = Sync;
    var version = "2.19.5";
    var version$1 = {
        version: version
    };
    var version$2 = /*#__PURE__*/ Object.freeze({
        version: version,
        default: version$1
    });
    var require$$2 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$3 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$4 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
    parser$3 = parser;
    Events$2 = Events_1;
    RedisConnection$1 = require$$2;
    IORedisConnection$1 = require$$3;
    Scripts$1 = require$$4;
    Group = (function() {
        class Group {
            constructor(limiterOptions = {}){
                this.deleteKey = this.deleteKey.bind(this);
                this.limiterOptions = limiterOptions;
                parser$3.load(this.limiterOptions, this.defaults, this);
                this.Events = new Events$2(this);
                this.instances = {};
                this.Bottleneck = Bottleneck_1;
                this._startAutoCleanup();
                this.sharedConnection = this.connection != null;
                if (this.connection == null) {
                    if (this.limiterOptions.datastore === "redis") {
                        this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {
                            Events: this.Events
                        }));
                    } else if (this.limiterOptions.datastore === "ioredis") {
                        this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {
                            Events: this.Events
                        }));
                    }
                }
            }
            key(key = "") {
                var ref;
                return (ref = this.instances[key]) != null ? ref : (()=>{
                    var limiter;
                    limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
                        id: `${this.id}-${key}`,
                        timeout: this.timeout,
                        connection: this.connection
                    }));
                    this.Events.trigger("created", limiter, key);
                    return limiter;
                })();
            }
            async deleteKey(key = "") {
                var deleted, instance;
                instance = this.instances[key];
                if (this.connection) {
                    deleted = await this.connection.__runCommand__([
                        'del',
                        ...Scripts$1.allKeys(`${this.id}-${key}`)
                    ]);
                }
                if (instance != null) {
                    delete this.instances[key];
                    await instance.disconnect();
                }
                return instance != null || deleted > 0;
            }
            limiters() {
                var k, ref, results, v;
                ref = this.instances;
                results = [];
                for(k in ref){
                    v = ref[k];
                    results.push({
                        key: k,
                        limiter: v
                    });
                }
                return results;
            }
            keys() {
                return Object.keys(this.instances);
            }
            async clusterKeys() {
                var cursor, end, found, i, k, keys, len, next, start;
                if (this.connection == null) {
                    return this.Promise.resolve(this.keys());
                }
                keys = [];
                cursor = null;
                start = `b_${this.id}-`.length;
                end = "_settings".length;
                while(cursor !== 0){
                    [next, found] = await this.connection.__runCommand__([
                        "scan",
                        cursor != null ? cursor : 0,
                        "match",
                        `b_${this.id}-*_settings`,
                        "count",
                        10000
                    ]);
                    cursor = ~~next;
                    for(i = 0, len = found.length; i < len; i++){
                        k = found[i];
                        keys.push(k.slice(start, -end));
                    }
                }
                return keys;
            }
            _startAutoCleanup() {
                var base;
                clearInterval(this.interval);
                return typeof (base = this.interval = setInterval(async ()=>{
                    var e, k, ref, results, time, v;
                    time = Date.now();
                    ref = this.instances;
                    results = [];
                    for(k in ref){
                        v = ref[k];
                        try {
                            if (await v._store.__groupCheck__(time)) {
                                results.push(this.deleteKey(k));
                            } else {
                                results.push(void 0);
                            }
                        } catch (error) {
                            e = error;
                            results.push(v.Events.trigger("error", e));
                        }
                    }
                    return results;
                }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
            }
            updateSettings(options = {}) {
                parser$3.overwrite(options, this.defaults, this);
                parser$3.overwrite(options, options, this.limiterOptions);
                if (options.timeout != null) {
                    return this._startAutoCleanup();
                }
            }
            disconnect(flush = true) {
                var ref;
                if (!this.sharedConnection) {
                    return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
                }
            }
        }
        Group.prototype.defaults = {
            timeout: 1000 * 60 * 5,
            connection: null,
            Promise: Promise,
            id: "group-key"
        };
        return Group;
    }).call(commonjsGlobal);
    var Group_1 = Group;
    var Batcher, Events$3, parser$4;
    parser$4 = parser;
    Events$3 = Events_1;
    Batcher = (function() {
        class Batcher {
            constructor(options = {}){
                this.options = options;
                parser$4.load(this.options, this.defaults, this);
                this.Events = new Events$3(this);
                this._arr = [];
                this._resetPromise();
                this._lastFlush = Date.now();
            }
            _resetPromise() {
                return this._promise = new this.Promise((res, rej)=>{
                    return this._resolve = res;
                });
            }
            _flush() {
                clearTimeout(this._timeout);
                this._lastFlush = Date.now();
                this._resolve();
                this.Events.trigger("batch", this._arr);
                this._arr = [];
                return this._resetPromise();
            }
            add(data) {
                var ret;
                this._arr.push(data);
                ret = this._promise;
                if (this._arr.length === this.maxSize) {
                    this._flush();
                } else if (this.maxTime != null && this._arr.length === 1) {
                    this._timeout = setTimeout(()=>{
                        return this._flush();
                    }, this.maxTime);
                }
                return ret;
            }
        }
        Batcher.prototype.defaults = {
            maxTime: null,
            maxSize: null,
            Promise: Promise
        };
        return Batcher;
    }).call(commonjsGlobal);
    var Batcher_1 = Batcher;
    var require$$4$1 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$8 = getCjsExportFromNamespace(version$2);
    var Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
    NUM_PRIORITIES$1 = 10;
    DEFAULT_PRIORITY$1 = 5;
    parser$5 = parser;
    Queues$1 = Queues_1;
    Job$1 = Job_1;
    LocalDatastore$1 = LocalDatastore_1;
    RedisDatastore$1 = require$$4$1;
    Events$4 = Events_1;
    States$1 = States_1;
    Sync$1 = Sync_1;
    Bottleneck = (function() {
        class Bottleneck {
            constructor(options = {}, ...invalid){
                var storeInstanceOptions, storeOptions;
                this._addToQueue = this._addToQueue.bind(this);
                this._validateOptions(options, invalid);
                parser$5.load(options, this.instanceDefaults, this);
                this._queues = new Queues$1(NUM_PRIORITIES$1);
                this._scheduled = {};
                this._states = new States$1([
                    "RECEIVED",
                    "QUEUED",
                    "RUNNING",
                    "EXECUTING"
                ].concat(this.trackDoneStatus ? [
                    "DONE"
                ] : []));
                this._limiter = null;
                this.Events = new Events$4(this);
                this._submitLock = new Sync$1("submit", this.Promise);
                this._registerLock = new Sync$1("register", this.Promise);
                storeOptions = parser$5.load(options, this.storeDefaults, {});
                this._store = (function() {
                    if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
                        storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
                        return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
                    } else if (this.datastore === "local") {
                        storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
                        return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
                    } else {
                        throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
                    }
                }).call(this);
                this._queues.on("leftzero", ()=>{
                    var ref;
                    return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
                });
                this._queues.on("zero", ()=>{
                    var ref;
                    return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
                });
            }
            _validateOptions(options, invalid) {
                if (!(options != null && typeof options === "object" && invalid.length === 0)) {
                    throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
                }
            }
            ready() {
                return this._store.ready;
            }
            clients() {
                return this._store.clients;
            }
            channel() {
                return `b_${this.id}`;
            }
            channel_client() {
                return `b_${this.id}_${this._store.clientId}`;
            }
            publish(message) {
                return this._store.__publish__(message);
            }
            disconnect(flush = true) {
                return this._store.__disconnect__(flush);
            }
            chain(_limiter) {
                this._limiter = _limiter;
                return this;
            }
            queued(priority) {
                return this._queues.queued(priority);
            }
            clusterQueued() {
                return this._store.__queued__();
            }
            empty() {
                return this.queued() === 0 && this._submitLock.isEmpty();
            }
            running() {
                return this._store.__running__();
            }
            done() {
                return this._store.__done__();
            }
            jobStatus(id) {
                return this._states.jobStatus(id);
            }
            jobs(status) {
                return this._states.statusJobs(status);
            }
            counts() {
                return this._states.statusCounts();
            }
            _randomIndex() {
                return Math.random().toString(36).slice(2);
            }
            check(weight = 1) {
                return this._store.__check__(weight);
            }
            _clearGlobalState(index) {
                if (this._scheduled[index] != null) {
                    clearTimeout(this._scheduled[index].expiration);
                    delete this._scheduled[index];
                    return true;
                } else {
                    return false;
                }
            }
            async _free(index, job, options, eventInfo) {
                var e, running;
                try {
                    ({ running } = await this._store.__free__(index, options.weight));
                    this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
                    if (running === 0 && this.empty()) {
                        return this.Events.trigger("idle");
                    }
                } catch (error1) {
                    e = error1;
                    return this.Events.trigger("error", e);
                }
            }
            _run(index, job, wait) {
                var clearGlobalState, free, run;
                job.doRun();
                clearGlobalState = this._clearGlobalState.bind(this, index);
                run = this._run.bind(this, index, job);
                free = this._free.bind(this, index, job);
                return this._scheduled[index] = {
                    timeout: setTimeout(()=>{
                        return job.doExecute(this._limiter, clearGlobalState, run, free);
                    }, wait),
                    expiration: job.options.expiration != null ? setTimeout(function() {
                        return job.doExpire(clearGlobalState, run, free);
                    }, wait + job.options.expiration) : void 0,
                    job: job
                };
            }
            _drainOne(capacity) {
                return this._registerLock.schedule(()=>{
                    var args, index, next, options, queue;
                    if (this.queued() === 0) {
                        return this.Promise.resolve(null);
                    }
                    queue = this._queues.getFirst();
                    ({ options, args } = next = queue.first());
                    if (capacity != null && options.weight > capacity) {
                        return this.Promise.resolve(null);
                    }
                    this.Events.trigger("debug", `Draining ${options.id}`, {
                        args,
                        options
                    });
                    index = this._randomIndex();
                    return this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir })=>{
                        var empty;
                        this.Events.trigger("debug", `Drained ${options.id}`, {
                            success,
                            args,
                            options
                        });
                        if (success) {
                            queue.shift();
                            empty = this.empty();
                            if (empty) {
                                this.Events.trigger("empty");
                            }
                            if (reservoir === 0) {
                                this.Events.trigger("depleted", empty);
                            }
                            this._run(index, next, wait);
                            return this.Promise.resolve(options.weight);
                        } else {
                            return this.Promise.resolve(null);
                        }
                    });
                });
            }
            _drainAll(capacity, total = 0) {
                return this._drainOne(capacity).then((drained)=>{
                    var newCapacity;
                    if (drained != null) {
                        newCapacity = capacity != null ? capacity - drained : capacity;
                        return this._drainAll(newCapacity, total + drained);
                    } else {
                        return this.Promise.resolve(total);
                    }
                }).catch((e)=>{
                    return this.Events.trigger("error", e);
                });
            }
            _dropAllQueued(message) {
                return this._queues.shiftAll(function(job) {
                    return job.doDrop({
                        message
                    });
                });
            }
            stop(options = {}) {
                var done, waitForExecuting;
                options = parser$5.load(options, this.stopDefaults);
                waitForExecuting = (at)=>{
                    var finished;
                    finished = ()=>{
                        var counts;
                        counts = this._states.counts;
                        return counts[0] + counts[1] + counts[2] + counts[3] === at;
                    };
                    return new this.Promise((resolve, reject)=>{
                        if (finished()) {
                            return resolve();
                        } else {
                            return this.on("done", ()=>{
                                if (finished()) {
                                    this.removeAllListeners("done");
                                    return resolve();
                                }
                            });
                        }
                    });
                };
                done = options.dropWaitingJobs ? (this._run = function(index, next) {
                    return next.doDrop({
                        message: options.dropErrorMessage
                    });
                }, this._drainOne = ()=>{
                    return this.Promise.resolve(null);
                }, this._registerLock.schedule(()=>{
                    return this._submitLock.schedule(()=>{
                        var k, ref, v;
                        ref = this._scheduled;
                        for(k in ref){
                            v = ref[k];
                            if (this.jobStatus(v.job.options.id) === "RUNNING") {
                                clearTimeout(v.timeout);
                                clearTimeout(v.expiration);
                                v.job.doDrop({
                                    message: options.dropErrorMessage
                                });
                            }
                        }
                        this._dropAllQueued(options.dropErrorMessage);
                        return waitForExecuting(0);
                    });
                })) : this.schedule({
                    priority: NUM_PRIORITIES$1 - 1,
                    weight: 0
                }, ()=>{
                    return waitForExecuting(1);
                });
                this._receive = function(job) {
                    return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));
                };
                this.stop = ()=>{
                    return this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called"));
                };
                return done;
            }
            async _addToQueue(job) {
                var args, blocked, error, options, reachedHWM, shifted, strategy;
                ({ args, options } = job);
                try {
                    ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
                } catch (error1) {
                    error = error1;
                    this.Events.trigger("debug", `Could not queue ${options.id}`, {
                        args,
                        options,
                        error
                    });
                    job.doDrop({
                        error
                    });
                    return false;
                }
                if (blocked) {
                    job.doDrop();
                    return true;
                } else if (reachedHWM) {
                    shifted = strategy === Bottleneck.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;
                    if (shifted != null) {
                        shifted.doDrop();
                    }
                    if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {
                        if (shifted == null) {
                            job.doDrop();
                        }
                        return reachedHWM;
                    }
                }
                job.doQueue(reachedHWM, blocked);
                this._queues.push(job);
                await this._drainAll();
                return reachedHWM;
            }
            _receive(job) {
                if (this._states.jobStatus(job.options.id) != null) {
                    job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
                    return false;
                } else {
                    job.doReceive();
                    return this._submitLock.schedule(this._addToQueue, job);
                }
            }
            submit(...args) {
                var cb, fn, job, options, ref, ref1, task;
                if (typeof args[0] === "function") {
                    ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
                    options = parser$5.load({}, this.jobDefaults);
                } else {
                    ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
                    options = parser$5.load(options, this.jobDefaults);
                }
                task = (...args)=>{
                    return new this.Promise(function(resolve, reject) {
                        return fn(...args, function(...args) {
                            return (args[0] != null ? reject : resolve)(args);
                        });
                    });
                };
                job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
                job.promise.then(function(args) {
                    return typeof cb === "function" ? cb(...args) : void 0;
                }).catch(function(args) {
                    if (Array.isArray(args)) {
                        return typeof cb === "function" ? cb(...args) : void 0;
                    } else {
                        return typeof cb === "function" ? cb(args) : void 0;
                    }
                });
                return this._receive(job);
            }
            schedule(...args) {
                var job, options, task;
                if (typeof args[0] === "function") {
                    [task, ...args] = args;
                    options = {};
                } else {
                    [options, task, ...args] = args;
                }
                job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
                this._receive(job);
                return job.promise;
            }
            wrap(fn) {
                var schedule, wrapped;
                schedule = this.schedule.bind(this);
                wrapped = function(...args) {
                    return schedule(fn.bind(this), ...args);
                };
                wrapped.withOptions = function(options, ...args) {
                    return schedule(options, fn, ...args);
                };
                return wrapped;
            }
            async updateSettings(options = {}) {
                await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
                parser$5.overwrite(options, this.instanceDefaults, this);
                return this;
            }
            currentReservoir() {
                return this._store.__currentReservoir__();
            }
            incrementReservoir(incr = 0) {
                return this._store.__incrementReservoir__(incr);
            }
        }
        Bottleneck.default = Bottleneck;
        Bottleneck.Events = Events$4;
        Bottleneck.version = Bottleneck.prototype.version = require$$8.version;
        Bottleneck.strategy = Bottleneck.prototype.strategy = {
            LEAK: 1,
            OVERFLOW: 2,
            OVERFLOW_PRIORITY: 4,
            BLOCK: 3
        };
        Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;
        Bottleneck.Group = Bottleneck.prototype.Group = Group_1;
        Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;
        Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;
        Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;
        Bottleneck.prototype.jobDefaults = {
            priority: DEFAULT_PRIORITY$1,
            weight: 1,
            expiration: null,
            id: "<no-id>"
        };
        Bottleneck.prototype.storeDefaults = {
            maxConcurrent: null,
            minTime: 0,
            highWater: null,
            strategy: Bottleneck.prototype.strategy.LEAK,
            penalty: null,
            reservoir: null,
            reservoirRefreshInterval: null,
            reservoirRefreshAmount: null,
            reservoirIncreaseInterval: null,
            reservoirIncreaseAmount: null,
            reservoirIncreaseMaximum: null
        };
        Bottleneck.prototype.localStoreDefaults = {
            Promise: Promise,
            timeout: null,
            heartbeatInterval: 250
        };
        Bottleneck.prototype.redisStoreDefaults = {
            Promise: Promise,
            timeout: null,
            heartbeatInterval: 5000,
            clientTimeout: 10000,
            Redis: null,
            clientOptions: {},
            clusterNodes: null,
            clearDatastore: false,
            connection: null
        };
        Bottleneck.prototype.instanceDefaults = {
            datastore: "local",
            connection: null,
            id: "<no-id>",
            rejectOnDrop: true,
            trackDoneStatus: false,
            Promise: Promise
        };
        Bottleneck.prototype.stopDefaults = {
            enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
            dropWaitingJobs: true,
            dropErrorMessage: "This limiter has been stopped."
        };
        return Bottleneck;
    }).call(commonjsGlobal);
    var Bottleneck_1 = Bottleneck;
    var lib = Bottleneck_1;
    return lib;
});
}),
"[project]/node_modules/.pnpm/@octokit+plugin-retry@8.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-retry/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/version.js
__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "retry",
    ()=>retry
]);
// pkg/dist-src/wrap-request.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bottleneck$40$2$2e$19$2e$5$2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/bottleneck@2.19.5/node_modules/bottleneck/light.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request-error@7.0.0/node_modules/@octokit/request-error/dist-src/index.js [app-rsc] (ecmascript)");
var VERSION = "0.0.0-development";
// pkg/dist-src/error-request.js
async function errorRequest(state, octokit, error, options) {
    if (!error.request || !error.request.request) {
        throw error;
    }
    if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
        const retries = options.request.retries != null ? options.request.retries : state.retries;
        const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
        throw octokit.retry.retryRequest(error, retries, retryAfter);
    }
    throw error;
}
;
;
async function wrapRequest(state, octokit, request, options) {
    const limiter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bottleneck$40$2$2e$19$2e$5$2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"]();
    limiter.on("failed", function(error, info) {
        const maxRetries = ~~error.request.request.retries;
        const after = ~~error.request.request.retryAfter;
        options.request.retryCount = info.retryCount + 1;
        if (maxRetries > info.retryCount) {
            return after * state.retryAfterBaseValue;
        }
    });
    return limiter.schedule(requestWithGraphqlErrorHandling.bind(null, state, octokit, request), options);
}
async function requestWithGraphqlErrorHandling(state, octokit, request, options) {
    const response = await request(request, options);
    if (response.data && response.data.errors && response.data.errors.length > 0 && /Something went wrong while executing your query/.test(response.data.errors[0].message)) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"](response.data.errors[0].message, 500, {
            request: options,
            response
        });
        return errorRequest(state, octokit, error, options);
    }
    return response;
}
// pkg/dist-src/index.js
function retry(octokit, octokitOptions) {
    const state = Object.assign({
        enabled: true,
        retryAfterBaseValue: 1e3,
        doNotRetry: [
            400,
            401,
            403,
            404,
            410,
            422,
            451
        ],
        retries: 3
    }, octokitOptions.retry);
    if (state.enabled) {
        octokit.hook.error("request", errorRequest.bind(null, state, octokit));
        octokit.hook.wrap("request", wrapRequest.bind(null, state, octokit));
    }
    return {
        retry: {
            retryRequest: (error, retries, retryAfter)=>{
                error.request.request = Object.assign({}, error.request.request, {
                    retries,
                    retryAfter
                });
                return error;
            }
        }
    };
}
retry.VERSION = VERSION;
;
}),
"[project]/node_modules/.pnpm/@octokit+plugin-throttling@11.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-throttling/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "throttling",
    ()=>throttling
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bottleneck$40$2$2e$19$2e$5$2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/bottleneck@2.19.5/node_modules/bottleneck/light.js [app-rsc] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/wrap-request.js
var noop = ()=>Promise.resolve();
function wrapRequest(state, request, options) {
    return state.retryLimiter.schedule(doRequest, state, request, options);
}
async function doRequest(state, request, options) {
    const { pathname } = new URL(options.url, "http://github.test");
    const isAuth = isAuthRequest(options.method, pathname);
    const isWrite = !isAuth && options.method !== "GET" && options.method !== "HEAD";
    const isSearch = options.method === "GET" && pathname.startsWith("/search/");
    const isGraphQL = pathname.startsWith("/graphql");
    const retryCount = ~~request.retryCount;
    const jobOptions = retryCount > 0 ? {
        priority: 0,
        weight: 0
    } : {};
    if (state.clustering) {
        jobOptions.expiration = 1e3 * 60;
    }
    if (isWrite || isGraphQL) {
        await state.write.key(state.id).schedule(jobOptions, noop);
    }
    if (isWrite && state.triggersNotification(pathname)) {
        await state.notifications.key(state.id).schedule(jobOptions, noop);
    }
    if (isSearch) {
        await state.search.key(state.id).schedule(jobOptions, noop);
    }
    const req = (isAuth ? state.auth : state.global).key(state.id).schedule(jobOptions, request, options);
    if (isGraphQL) {
        const res = await req;
        if (res.data.errors != null && res.data.errors.some((error)=>error.type === "RATE_LIMITED")) {
            const error = Object.assign(new Error("GraphQL Rate Limit Exceeded"), {
                response: res,
                data: res.data
            });
            throw error;
        }
    }
    return req;
}
function isAuthRequest(method, pathname) {
    return method === "PATCH" && // https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-a-scoped-access-token
    /^\/applications\/[^/]+\/token\/scoped$/.test(pathname) || method === "POST" && // https://docs.github.com/en/rest/apps/oauth-applications?apiVersion=2022-11-28#reset-a-token
    (/^\/applications\/[^/]+\/token$/.test(pathname) || // https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-an-installation-access-token-for-an-app
    /^\/app\/installations\/[^/]+\/access_tokens$/.test(pathname) || // https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps
    pathname === "/login/oauth/access_token");
}
// pkg/dist-src/generated/triggers-notification-paths.js
var triggers_notification_paths_default = [
    "/orgs/{org}/invitations",
    "/orgs/{org}/invitations/{invitation_id}",
    "/orgs/{org}/teams/{team_slug}/discussions",
    "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "/repos/{owner}/{repo}/collaborators/{username}",
    "/repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "/repos/{owner}/{repo}/issues",
    "/repos/{owner}/{repo}/issues/{issue_number}/comments",
    "/repos/{owner}/{repo}/issues/{issue_number}/sub_issue",
    "/repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority",
    "/repos/{owner}/{repo}/pulls",
    "/repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
    "/repos/{owner}/{repo}/pulls/{pull_number}/merge",
    "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
    "/repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "/repos/{owner}/{repo}/releases",
    "/teams/{team_id}/discussions",
    "/teams/{team_id}/discussions/{discussion_number}/comments"
];
// pkg/dist-src/route-matcher.js
function routeMatcher(paths) {
    const regexes = paths.map((path)=>path.split("/").map((c)=>c.startsWith("{") ? "(?:.+?)" : c).join("/"));
    const regex2 = `^(?:${regexes.map((r)=>`(?:${r})`).join("|")})[^/]*$`;
    return new RegExp(regex2, "i");
}
// pkg/dist-src/index.js
var regex = routeMatcher(triggers_notification_paths_default);
var triggersNotification = regex.test.bind(regex);
var groups = {};
var createGroups = function(Bottleneck, common) {
    groups.global = new Bottleneck.Group({
        id: "octokit-global",
        maxConcurrent: 10,
        ...common
    });
    groups.auth = new Bottleneck.Group({
        id: "octokit-auth",
        maxConcurrent: 1,
        ...common
    });
    groups.search = new Bottleneck.Group({
        id: "octokit-search",
        maxConcurrent: 1,
        minTime: 2e3,
        ...common
    });
    groups.write = new Bottleneck.Group({
        id: "octokit-write",
        maxConcurrent: 1,
        minTime: 1e3,
        ...common
    });
    groups.notifications = new Bottleneck.Group({
        id: "octokit-notifications",
        maxConcurrent: 1,
        minTime: 3e3,
        ...common
    });
};
function throttling(octokit, octokitOptions) {
    const { enabled = true, Bottleneck = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$bottleneck$40$2$2e$19$2e$5$2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"], id = "no-id", timeout = 1e3 * 60 * 2, // Redis TTL: 2 minutes
    connection } = octokitOptions.throttle || {};
    if (!enabled) {
        return {};
    }
    const common = {
        timeout
    };
    if (typeof connection !== "undefined") {
        common.connection = connection;
    }
    if (groups.global == null) {
        createGroups(Bottleneck, common);
    }
    const state = Object.assign({
        clustering: connection != null,
        triggersNotification,
        fallbackSecondaryRateRetryAfter: 60,
        retryAfterBaseValue: 1e3,
        retryLimiter: new Bottleneck(),
        id,
        ...groups
    }, octokitOptions.throttle);
    if (typeof state.onSecondaryRateLimit !== "function" || typeof state.onRateLimit !== "function") {
        throw new Error(`octokit/plugin-throttling error:
        You must pass the onSecondaryRateLimit and onRateLimit error handlers.
        See https://octokit.github.io/rest.js/#throttling

        const octokit = new Octokit({
          throttle: {
            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);
    }
    const events = {};
    const emitter = new Bottleneck.Events(events);
    events.on("secondary-limit", state.onSecondaryRateLimit);
    events.on("rate-limit", state.onRateLimit);
    events.on("error", (e)=>octokit.log.warn("Error in throttling-plugin limit handler", e));
    state.retryLimiter.on("failed", async function(error, info) {
        const [state2, request, options] = info.args;
        const { pathname } = new URL(options.url, "http://github.test");
        const shouldRetryGraphQL = pathname.startsWith("/graphql") && error.status !== 401;
        if (!(shouldRetryGraphQL || error.status === 403 || error.status === 429)) {
            return;
        }
        const retryCount = ~~request.retryCount;
        request.retryCount = retryCount;
        options.request.retryCount = retryCount;
        const { wantRetry, retryAfter = 0 } = await async function() {
            if (/\bsecondary rate\b/i.test(error.message)) {
                const retryAfter2 = Number(error.response.headers["retry-after"]) || state2.fallbackSecondaryRateRetryAfter;
                const wantRetry2 = await emitter.trigger("secondary-limit", retryAfter2, options, octokit, retryCount);
                return {
                    wantRetry: wantRetry2,
                    retryAfter: retryAfter2
                };
            }
            if (error.response.headers != null && error.response.headers["x-ratelimit-remaining"] === "0" || (error.response.data?.errors ?? []).some((error2)=>error2.type === "RATE_LIMITED")) {
                const rateLimitReset = new Date(~~error.response.headers["x-ratelimit-reset"] * 1e3).getTime();
                const retryAfter2 = Math.max(// Add one second so we retry _after_ the reset time
                // https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#exceeding-the-rate-limit
                Math.ceil((rateLimitReset - Date.now()) / 1e3) + 1, 0);
                const wantRetry2 = await emitter.trigger("rate-limit", retryAfter2, options, octokit, retryCount);
                return {
                    wantRetry: wantRetry2,
                    retryAfter: retryAfter2
                };
            }
            return {};
        }();
        if (wantRetry) {
            request.retryCount++;
            return retryAfter * state2.retryAfterBaseValue;
        }
    });
    octokit.hook.wrap("request", wrapRequest.bind(null, state));
    return {};
}
throttling.VERSION = VERSION;
throttling.triggersNotification = triggersNotification;
;
}),
"[project]/node_modules/.pnpm/@octokit+oauth-authorization-url@8.0.0/node_modules/@octokit/oauth-authorization-url/dist-src/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "oauthAuthorizationUrl",
    ()=>oauthAuthorizationUrl
]);
function oauthAuthorizationUrl(options) {
    const clientType = options.clientType || "oauth-app";
    const baseUrl = options.baseUrl || "https://github.com";
    const result = {
        clientType,
        allowSignup: options.allowSignup === false ? false : true,
        clientId: options.clientId,
        login: options.login || null,
        redirectUrl: options.redirectUrl || null,
        state: options.state || Math.random().toString(36).substr(2),
        url: ""
    };
    if (clientType === "oauth-app") {
        const scopes = "scopes" in options ? options.scopes : [];
        result.scopes = typeof scopes === "string" ? scopes.split(/[,\s]+/).filter(Boolean) : scopes;
    }
    result.url = urlBuilderAuthorize(`${baseUrl}/login/oauth/authorize`, result);
    return result;
}
function urlBuilderAuthorize(base, options) {
    const map = {
        allowSignup: "allow_signup",
        clientId: "client_id",
        login: "login",
        redirectUrl: "redirect_uri",
        scopes: "scope",
        state: "state"
    };
    let url = base;
    Object.keys(map).filter((k)=>options[k] !== null).filter((k)=>{
        if (k !== "scopes") return true;
        if (options.clientType === "github-app") return false;
        return !Array.isArray(options[k]) || options[k].length > 0;
    }).map((key)=>[
            map[key],
            `${options[key]}`
        ]).forEach(([key, value], index)=>{
        url += index === 0 ? `?` : "&";
        url += `${key}=${encodeURIComponent(value)}`;
    });
    return url;
}
;
}),
"[project]/node_modules/.pnpm/@octokit+oauth-methods@6.0.0/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/version.js
__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "checkToken",
    ()=>checkToken,
    "createDeviceCode",
    ()=>createDeviceCode,
    "deleteAuthorization",
    ()=>deleteAuthorization,
    "deleteToken",
    ()=>deleteToken,
    "exchangeDeviceCode",
    ()=>exchangeDeviceCode,
    "exchangeWebFlowCode",
    ()=>exchangeWebFlowCode,
    "getWebFlowAuthorizationUrl",
    ()=>getWebFlowAuthorizationUrl,
    "refreshToken",
    ()=>refreshToken,
    "resetToken",
    ()=>resetToken,
    "scopeToken",
    ()=>scopeToken
]);
// pkg/dist-src/get-web-flow-authorization-url.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$authorization$2d$url$40$8$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$authorization$2d$url$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-authorization-url@8.0.0/node_modules/@octokit/oauth-authorization-url/dist-src/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/utils.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request-error@7.0.0/node_modules/@octokit/request-error/dist-src/index.js [app-rsc] (ecmascript)");
var VERSION = "0.0.0-development";
;
;
;
function requestToOAuthBaseUrl(request) {
    const endpointDefaults = request.endpoint.DEFAULTS;
    return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request, route, parameters) {
    const withOAuthParameters = {
        baseUrl: requestToOAuthBaseUrl(request),
        headers: {
            accept: "application/json"
        },
        ...parameters
    };
    const response = await request(route, withOAuthParameters);
    if ("error" in response.data) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RequestError"](`${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`, 400, {
            request: request.endpoint.merge(route, withOAuthParameters)
        });
        error.response = response;
        throw error;
    }
    return response;
}
// pkg/dist-src/get-web-flow-authorization-url.js
function getWebFlowAuthorizationUrl({ request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"], ...options }) {
    const baseUrl = requestToOAuthBaseUrl(request);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$authorization$2d$url$40$8$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$authorization$2d$url$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["oauthAuthorizationUrl"])({
        ...options,
        baseUrl
    });
}
;
async function exchangeWebFlowCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        client_secret: options.clientSecret,
        code: options.code,
        redirect_uri: options.redirectUrl
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
    };
    if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
            const apiTimeInMs = new Date(response.headers.date).getTime();
            authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp(apiTimeInMs, response.data.refresh_token_expires_in);
        }
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function createDeviceCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const parameters = {
        client_id: options.clientId
    };
    if ("scopes" in options && Array.isArray(options.scopes)) {
        parameters.scope = options.scopes.join(" ");
    }
    return oauthRequest(request, "POST /login/device/code", parameters);
}
;
async function exchangeDeviceCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        device_code: options.code,
        grant_type: "urn:ietf:params:oauth:grant-type:device_code"
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
    };
    if ("clientSecret" in options) {
        authentication.clientSecret = options.clientSecret;
    }
    if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
            const apiTimeInMs = new Date(response.headers.date).getTime();
            authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp2(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp2(apiTimeInMs, response.data.refresh_token_expires_in);
        }
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
function toTimestamp2(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function checkToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const response = await request("POST /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${btoa(`${options.clientId}:${options.clientSecret}`)}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: options.token,
        scopes: response.data.scopes
    };
    if (response.data.expires_at) authentication.expiresAt = response.data.expires_at;
    if (options.clientType === "github-app") {
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
;
async function refreshToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        client_secret: options.clientSecret,
        grant_type: "refresh_token",
        refresh_token: options.refreshToken
    });
    const apiTimeInMs = new Date(response.headers.date).getTime();
    const authentication = {
        clientType: "github-app",
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        refreshToken: response.data.refresh_token,
        expiresAt: toTimestamp3(apiTimeInMs, response.data.expires_in),
        refreshTokenExpiresAt: toTimestamp3(apiTimeInMs, response.data.refresh_token_expires_in)
    };
    return {
        ...response,
        authentication
    };
}
function toTimestamp3(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function scopeToken(options) {
    const { request: optionsRequest, clientType, clientId, clientSecret, token, ...requestOptions } = options;
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const response = await request("POST /applications/{client_id}/token/scoped", {
        headers: {
            authorization: `basic ${btoa(`${clientId}:${clientSecret}`)}`
        },
        client_id: clientId,
        access_token: token,
        ...requestOptions
    });
    const authentication = Object.assign({
        clientType,
        clientId,
        clientSecret,
        token: response.data.token
    }, response.data.expires_at ? {
        expiresAt: response.data.expires_at
    } : {});
    return {
        ...response,
        authentication
    };
}
;
async function resetToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    const response = await request("PATCH /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.token,
        scopes: response.data.scopes
    };
    if (response.data.expires_at) authentication.expiresAt = response.data.expires_at;
    if (options.clientType === "github-app") {
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
;
async function deleteToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    return request("DELETE /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
}
;
async function deleteAuthorization(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    return request("DELETE /applications/{client_id}/grant", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
}
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-oauth-device@8.0.1/node_modules/@octokit/auth-oauth-device/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "createOAuthDeviceAuth",
    ()=>createOAuthDeviceAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/get-oauth-access-token.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-methods@6.0.0/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-rsc] (ecmascript)");
;
;
;
async function getOAuthAccessToken(state, options) {
    const cachedAuthentication = getCachedAuthentication(state, options.auth);
    if (cachedAuthentication) return cachedAuthentication;
    const { data: verification } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createDeviceCode"])({
        clientType: state.clientType,
        clientId: state.clientId,
        request: options.request || state.request,
        // @ts-expect-error the extra code to make TS happy is not worth it
        scopes: options.auth.scopes || state.scopes
    });
    await state.onVerification(verification);
    const authentication = await waitForAccessToken(options.request || state.request, state.clientId, state.clientType, verification);
    state.authentication = authentication;
    return authentication;
}
function getCachedAuthentication(state, auth2) {
    if (auth2.refresh === true) return false;
    if (!state.authentication) return false;
    if (state.clientType === "github-app") {
        return state.authentication;
    }
    const authentication = state.authentication;
    const newScope = ("scopes" in auth2 && auth2.scopes || state.scopes).join(" ");
    const currentScope = authentication.scopes.join(" ");
    return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
    await new Promise((resolve)=>setTimeout(resolve, seconds * 1e3));
}
async function waitForAccessToken(request, clientId, clientType, verification) {
    try {
        const options = {
            clientId,
            request,
            code: verification.device_code
        };
        const { authentication } = clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["exchangeDeviceCode"])({
            ...options,
            clientType: "oauth-app"
        }) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["exchangeDeviceCode"])({
            ...options,
            clientType: "github-app"
        });
        return {
            type: "token",
            tokenType: "oauth",
            ...authentication
        };
    } catch (error) {
        if (!error.response) throw error;
        const errorType = error.response.data.error;
        if (errorType === "authorization_pending") {
            await wait(verification.interval);
            return waitForAccessToken(request, clientId, clientType, verification);
        }
        if (errorType === "slow_down") {
            await wait(verification.interval + 7);
            return waitForAccessToken(request, clientId, clientType, verification);
        }
        throw error;
    }
}
// pkg/dist-src/auth.js
async function auth(state, authOptions) {
    return getOAuthAccessToken(state, {
        auth: authOptions
    });
}
// pkg/dist-src/hook.js
async function hook(state, request, route, parameters) {
    let endpoint = request.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request(endpoint);
    }
    const { token } = await getOAuthAccessToken(state, {
        request,
        auth: {
            type: "oauth"
        }
    });
    endpoint.headers.authorization = `token ${token}`;
    return request(endpoint);
}
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/index.js
function createOAuthDeviceAuth(options) {
    const requestWithDefaults = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].defaults({
        headers: {
            "user-agent": `octokit-auth-oauth-device.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
        }
    });
    const { request = requestWithDefaults, ...otherOptions } = options;
    const state = options.clientType === "github-app" ? {
        ...otherOptions,
        clientType: "github-app",
        request
    } : {
        ...otherOptions,
        clientType: "oauth-app",
        request,
        scopes: options.scopes || []
    };
    if (!options.clientId) {
        throw new Error('[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)');
    }
    if (!options.onVerification) {
        throw new Error('[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)');
    }
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-oauth-user@6.0.0/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "createOAuthUserAuth",
    ()=>createOAuthUserAuth,
    "requiresBasicAuth",
    ()=>requiresBasicAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/get-authentication.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$device$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$device$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-device@8.0.1/node_modules/@octokit/auth-oauth-device/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-methods@6.0.0/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-rsc] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
;
async function getAuthentication(state) {
    if ("code" in state.strategyOptions) {
        const { authentication } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["exchangeWebFlowCode"])({
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions,
            request: state.request
        });
        return {
            type: "token",
            tokenType: "oauth",
            ...authentication
        };
    }
    if ("onVerification" in state.strategyOptions) {
        const deviceAuth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$device$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$device$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthDeviceAuth"])({
            clientType: state.clientType,
            clientId: state.clientId,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions,
            request: state.request
        });
        const authentication = await deviceAuth({
            type: "oauth"
        });
        return {
            clientSecret: state.clientSecret,
            ...authentication
        };
    }
    if ("token" in state.strategyOptions) {
        return {
            type: "token",
            tokenType: "oauth",
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions
        };
    }
    throw new Error("[@octokit/auth-oauth-user] Invalid strategy options");
}
;
async function auth(state, options = {}) {
    if (!state.authentication) {
        state.authentication = state.clientType === "oauth-app" ? await getAuthentication(state) : await getAuthentication(state);
    }
    if (state.authentication.invalid) {
        throw new Error("[@octokit/auth-oauth-user] Token is invalid");
    }
    const currentAuthentication = state.authentication;
    if ("expiresAt" in currentAuthentication) {
        if (options.type === "refresh" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */ new Date()) {
            const { authentication } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["refreshToken"])({
                clientType: "github-app",
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                refreshToken: currentAuthentication.refreshToken,
                request: state.request
            });
            state.authentication = {
                tokenType: "oauth",
                type: "token",
                ...authentication
            };
        }
    }
    if (options.type === "refresh") {
        if (state.clientType === "oauth-app") {
            throw new Error("[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens");
        }
        if (!currentAuthentication.hasOwnProperty("expiresAt")) {
            throw new Error("[@octokit/auth-oauth-user] Refresh token missing");
        }
        await state.onTokenCreated?.(state.authentication, {
            type: options.type
        });
    }
    if (options.type === "check" || options.type === "reset") {
        const method = options.type === "check" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["checkToken"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resetToken"];
        try {
            const { authentication } = await method({
                // @ts-expect-error making TS happy would require unnecessary code so no
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: state.authentication.token,
                request: state.request
            });
            state.authentication = {
                tokenType: "oauth",
                type: "token",
                // @ts-expect-error TBD
                ...authentication
            };
            if (options.type === "reset") {
                await state.onTokenCreated?.(state.authentication, {
                    type: options.type
                });
            }
            return state.authentication;
        } catch (error) {
            if (error.status === 404) {
                error.message = "[@octokit/auth-oauth-user] Token is invalid";
                state.authentication.invalid = true;
            }
            throw error;
        }
    }
    if (options.type === "delete" || options.type === "deleteAuthorization") {
        const method = options.type === "delete" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteToken"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteAuthorization"];
        try {
            await method({
                // @ts-expect-error making TS happy would require unnecessary code so no
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: state.authentication.token,
                request: state.request
            });
        } catch (error) {
            if (error.status !== 404) throw error;
        }
        state.authentication.invalid = true;
        return state.authentication;
    }
    return state.authentication;
}
// pkg/dist-src/requires-basic-auth.js
var ROUTES_REQUIRING_BASIC_AUTH = /\/applications\/[^/]+\/(token|grant)s?/;
function requiresBasicAuth(url) {
    return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);
}
// pkg/dist-src/hook.js
async function hook(state, request, route, parameters = {}) {
    const endpoint = request.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request(endpoint);
    }
    if (requiresBasicAuth(endpoint.url)) {
        const credentials = btoa(`${state.clientId}:${state.clientSecret}`);
        endpoint.headers.authorization = `basic ${credentials}`;
        return request(endpoint);
    }
    const { token } = state.clientType === "oauth-app" ? await auth({
        ...state,
        request
    }) : await auth({
        ...state,
        request
    });
    endpoint.headers.authorization = "token " + token;
    return request(endpoint);
}
// pkg/dist-src/index.js
function createOAuthUserAuth({ clientId, clientSecret, clientType = "oauth-app", request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].defaults({
    headers: {
        "user-agent": `octokit-auth-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    }
}), onTokenCreated, ...strategyOptions }) {
    const state = Object.assign({
        clientType,
        clientId,
        clientSecret,
        onTokenCreated,
        strategyOptions,
        request
    });
    return Object.assign(auth.bind(null, state), {
        // @ts-expect-error not worth the extra code needed to appease TS
        hook: hook.bind(null, state)
    });
}
createOAuthUserAuth.VERSION = VERSION;
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-oauth-app@9.0.1/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "createOAuthAppAuth",
    ()=>createOAuthAppAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/auth.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-user@6.0.0/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-rsc] (ecmascript)");
;
;
;
async function auth(state, authOptions) {
    if (authOptions.type === "oauth-app") {
        return {
            type: "oauth-app",
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            headers: {
                authorization: `basic ${btoa(`${state.clientId}:${state.clientSecret}`)}`
            }
        };
    }
    if ("factory" in authOptions) {
        const { type, ...options } = {
            ...authOptions,
            ...state
        };
        return authOptions.factory(options);
    }
    const common = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.request,
        ...authOptions
    };
    const userAuth = state.clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"])({
        ...common,
        clientType: state.clientType
    }) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"])({
        ...common,
        clientType: state.clientType
    });
    return userAuth();
}
;
async function hook(state, request2, route, parameters) {
    let endpoint = request2.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request2(endpoint);
    }
    if (state.clientType === "github-app" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["requiresBasicAuth"])(endpoint.url)) {
        throw new Error(`[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint.method} ${endpoint.url}" is not supported.`);
    }
    const credentials = btoa(`${state.clientId}:${state.clientSecret}`);
    endpoint.headers.authorization = `basic ${credentials}`;
    try {
        return await request2(endpoint);
    } catch (error) {
        if (error.status !== 401) throw error;
        error.message = `[@octokit/auth-oauth-app] "${endpoint.method} ${endpoint.url}" does not support clientId/clientSecret basic authentication.`;
        throw error;
    }
}
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
function createOAuthAppAuth(options) {
    const state = Object.assign({
        request: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].defaults({
            headers: {
                "user-agent": `octokit-auth-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
            }
        }),
        clientType: "oauth-app"
    }, options);
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}),
"[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// we don't @ts-check here because it chokes on atob and btoa which are available in all modern JS runtime environments
/**
 * @param {string} privateKey
 * @returns {boolean}
 */ __turbopack_context__.s([
    "base64encode",
    ()=>base64encode,
    "getDERfromPEM",
    ()=>getDERfromPEM,
    "getEncodedMessage",
    ()=>getEncodedMessage,
    "isOpenSsh",
    ()=>isOpenSsh,
    "isPkcs1",
    ()=>isPkcs1,
    "string2ArrayBuffer",
    ()=>string2ArrayBuffer
]);
function isPkcs1(privateKey) {
    return privateKey.includes("-----BEGIN RSA PRIVATE KEY-----");
}
function isOpenSsh(privateKey) {
    return privateKey.includes("-----BEGIN OPENSSH PRIVATE KEY-----");
}
function string2ArrayBuffer(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for(let i = 0, strLen = str.length; i < strLen; i++){
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function getDERfromPEM(pem) {
    const pemB64 = pem.trim().split("\n").slice(1, -1) // Remove the --- BEGIN / END PRIVATE KEY ---
    .join("");
    const decoded = atob(pemB64);
    return string2ArrayBuffer(decoded);
}
function getEncodedMessage(header, payload) {
    return `${base64encodeJSON(header)}.${base64encodeJSON(payload)}`;
}
function base64encode(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for(var i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return fromBase64(btoa(binary));
}
/**
 * @param {string} base64
 * @returns {string}
 */ function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @param {Record<string,unknown>} obj
 * @returns {string}
 */ function base64encodeJSON(obj) {
    return fromBase64(btoa(JSON.stringify(obj)));
}
}),
"[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/crypto-node.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// this can be removed once we only support Node 20+
__turbopack_context__.s([
    "convertPrivateKey",
    ()=>convertPrivateKey
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/utils.js [app-rsc] (ecmascript)");
;
;
;
function convertPrivateKey(privateKey) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPkcs1"])(privateKey)) return privateKey;
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createPrivateKey"])(privateKey).export({
        type: "pkcs8",
        format: "pem"
    });
}
}),
"[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/get-token.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// we don't @ts-check here because it chokes crypto which is a global API in modern JS runtime environments
__turbopack_context__.s([
    "getToken",
    ()=>getToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/crypto-node.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
;
async function getToken({ privateKey, payload }) {
    const convertedPrivateKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertPrivateKey"])(privateKey);
    // WebCrypto only supports PKCS#8, unfortunately
    /* c8 ignore start */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isPkcs1"])(convertedPrivateKey)) {
        throw new Error("[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
    }
    /* c8 ignore stop */ // WebCrypto does not support OpenSSH, unfortunately
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isOpenSsh"])(convertedPrivateKey)) {
        throw new Error("[universal-github-app-jwt] Private Key is in OpenSSH format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
    }
    const algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    };
    /** @type {import('../internals').Header} */ const header = {
        alg: "RS256",
        typ: "JWT"
    };
    const privateKeyDER = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDERfromPEM"])(convertedPrivateKey);
    const importedKey = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["subtle"].importKey("pkcs8", privateKeyDER, algorithm, false, [
        "sign"
    ]);
    const encodedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getEncodedMessage"])(header, payload);
    const encodedMessageArrBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["string2ArrayBuffer"])(encodedMessage);
    const signatureArrBuf = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["subtle"].sign(algorithm.name, importedKey, encodedMessageArrBuf);
    const encodedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["base64encode"])(signatureArrBuf);
    return `${encodedMessage}.${encodedSignature}`;
}
}),
"[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-check
// @ts-ignore - #get-token is defined in "imports" in package.json
__turbopack_context__.s([
    "default",
    ()=>githubAppJwt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$get$2d$token$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/lib/get-token.js [app-rsc] (ecmascript)");
;
async function githubAppJwt({ id, privateKey, now = Math.floor(Date.now() / 1000) }) {
    // Private keys are often times configured as environment variables, in which case line breaks are escaped using `\\n`.
    // Replace these here for convenience.
    const privateKeyWithNewlines = privateKey.replace(/\\n/g, '\n');
    // When creating a JSON Web Token, it sets the "issued at time" (iat) to 30s
    // in the past as we have seen people running situations where the GitHub API
    // claimed the iat would be in future. It turned out the clocks on the
    // different machine were not in sync.
    const nowWithSafetyMargin = now - 30;
    const expiration = nowWithSafetyMargin + 60 * 10; // JWT expiration time (10 minute maximum)
    const payload = {
        iat: nowWithSafetyMargin,
        exp: expiration,
        iss: id
    };
    const token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$get$2d$token$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getToken"])({
        privateKey: privateKeyWithNewlines,
        payload
    });
    return {
        appId: id,
        expiration,
        token
    };
}
}),
"[project]/node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.mjs [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */ __turbopack_context__.s([
    "Fifo",
    ()=>FifoObject,
    "FifoMap",
    ()=>FifoMap,
    "FifoObject",
    ()=>FifoObject,
    "HitStatisticsRecord",
    ()=>HitStatisticsRecord,
    "Lru",
    ()=>LruObject,
    "LruHitStatistics",
    ()=>LruObjectHitStatistics,
    "LruMap",
    ()=>LruMap,
    "LruObject",
    ()=>LruObject,
    "LruObjectHitStatistics",
    ()=>LruObjectHitStatistics
]);
class FifoMap {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    get size() {
        return this.items.size;
    }
    clear() {
        this.items = new Map();
        this.first = null;
        this.last = null;
    }
    delete(key) {
        if (this.items.has(key)) {
            const deletedItem = this.items.get(key);
            this.items.delete(key);
            if (deletedItem.prev !== null) {
                deletedItem.prev.next = deletedItem.next;
            }
            if (deletedItem.next !== null) {
                deletedItem.next.prev = deletedItem.prev;
            }
            if (this.first === deletedItem) {
                this.first = deletedItem.next;
            }
            if (this.last === deletedItem) {
                this.last = deletedItem.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            this.items.delete(item.key);
            if (this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (this.items.has(key)) {
            return this.items.get(key).expiry;
        }
    }
    get(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return this.items.keys();
    }
    set(key, value) {
        // Replace existing item
        if (this.items.has(key)) {
            const item = this.items.get(key);
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items.set(key, item);
        if (this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class LruMap {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    get size() {
        return this.items.size;
    }
    bumpLru(item) {
        if (this.last === item) {
            return; // Item is already the last one, no need to bump
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
            this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
        this.last = item;
    }
    clear() {
        this.items = new Map();
        this.first = null;
        this.last = null;
    }
    delete(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            this.items.delete(key);
            if (item.prev !== null) {
                item.prev.next = item.next;
            }
            if (item.next !== null) {
                item.next.prev = item.prev;
            }
            if (this.first === item) {
                this.first = item.next;
            }
            if (this.last === item) {
                this.last = item.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            this.items.delete(item.key);
            if (this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (this.items.has(key)) {
            return this.items.get(key).expiry;
        }
    }
    get(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return this.items.keys();
    }
    set(key, value) {
        // Replace existing item
        if (this.items.has(key)) {
            const item = this.items.get(key);
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            if (this.last !== item) {
                this.bumpLru(item);
            }
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items.set(key, item);
        if (this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class LruObject {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    bumpLru(item) {
        if (this.last === item) {
            return; // Item is already the last one, no need to bump
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
            this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
        this.last = item;
    }
    clear() {
        this.items = Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
    }
    delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            delete this.items[key];
            this.size--;
            if (item.prev !== null) {
                item.prev.next = item.next;
            }
            if (item.next !== null) {
                item.next.prev = item.prev;
            }
            if (this.first === item) {
                this.first = item.next;
            }
            if (this.last === item) {
                this.last = item.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            delete this.items[item.key];
            if (--this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            return this.items[key].expiry;
        }
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return Object.keys(this.items);
    }
    set(key, value) {
        // Replace existing item
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            if (this.last !== item) {
                this.bumpLru(item);
            }
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items[key] = item;
        if (++this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class HitStatisticsRecord {
    constructor(){
        this.records = {};
    }
    initForCache(cacheId, currentTimeStamp) {
        this.records[cacheId] = {
            [currentTimeStamp]: {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                invalidateOne: 0,
                invalidateAll: 0,
                sets: 0
            }
        };
    }
    resetForCache(cacheId) {
        for (let key of Object.keys(this.records[cacheId])){
            this.records[cacheId][key] = {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                invalidateOne: 0,
                invalidateAll: 0,
                sets: 0
            };
        }
    }
    getStatistics() {
        return this.records;
    }
} /**
 *
 * @param {Date} date
 * @returns {string}
 */ 
function getTimestamp(date) {
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
}
class HitStatistics {
    constructor(cacheId, statisticTtlInHours, globalStatisticsRecord){
        this.cacheId = cacheId;
        this.statisticTtlInHours = statisticTtlInHours;
        this.collectionStart = new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records = globalStatisticsRecord || new HitStatisticsRecord();
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
    get currentRecord() {
        // safety net
        /* c8 ignore next 14 */ if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
            this.records.records[this.cacheId][this.currentTimeStamp] = {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                sets: 0,
                invalidateOne: 0,
                invalidateAll: 0
            };
        }
        return this.records.records[this.cacheId][this.currentTimeStamp];
    }
    hoursPassed() {
        return (Date.now() - this.collectionStart) / 1000 / 60 / 60;
    }
    addHit() {
        this.archiveIfNeeded();
        this.currentRecord.hits++;
    }
    addFalsyHit() {
        this.archiveIfNeeded();
        this.currentRecord.falsyHits++;
    }
    addEmptyHit() {
        this.archiveIfNeeded();
        this.currentRecord.emptyHits++;
    }
    addMiss() {
        this.archiveIfNeeded();
        this.currentRecord.misses++;
    }
    addEviction() {
        this.archiveIfNeeded();
        this.currentRecord.evictions++;
    }
    setCacheSize(currentSize) {
        this.archiveIfNeeded();
        this.currentRecord.cacheSize = currentSize;
    }
    addExpiration() {
        this.archiveIfNeeded();
        this.currentRecord.expirations++;
    }
    addSet() {
        this.archiveIfNeeded();
        this.currentRecord.sets++;
    }
    addInvalidateOne() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateOne++;
    }
    addInvalidateAll() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateAll++;
    }
    getStatistics() {
        return this.records.getStatistics();
    }
    archiveIfNeeded() {
        if (this.hoursPassed() >= this.statisticTtlInHours) {
            this.collectionStart = new Date();
            this.currentTimeStamp = getTimestamp(this.collectionStart);
            this.records.initForCache(this.cacheId, this.currentTimeStamp);
        }
    }
}
class LruObjectHitStatistics extends LruObject {
    constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours){
        super(max || 1000, ttlInMsecs || 0);
        if (!cacheId) {
            throw new Error('Cache id is mandatory');
        }
        this.hitStatistics = new HitStatistics(cacheId, statisticTtlInHours !== undefined ? statisticTtlInHours : 24, globalStatisticsRecord);
    }
    getStatistics() {
        return this.hitStatistics.getStatistics();
    }
    set(key, value) {
        super.set(key, value);
        this.hitStatistics.addSet();
        this.hitStatistics.setCacheSize(this.size);
    }
    evict() {
        super.evict();
        this.hitStatistics.addEviction();
        this.hitStatistics.setCacheSize(this.size);
    }
    delete(key, isExpiration = false) {
        super.delete(key);
        if (!isExpiration) {
            this.hitStatistics.addInvalidateOne();
        }
        this.hitStatistics.setCacheSize(this.size);
    }
    clear() {
        super.clear();
        this.hitStatistics.addInvalidateAll();
        this.hitStatistics.setCacheSize(this.size);
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key, true);
                this.hitStatistics.addExpiration();
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            if (!item.value) {
                this.hitStatistics.addFalsyHit();
            }
            if (item.value === undefined || item.value === null || item.value === '') {
                this.hitStatistics.addEmptyHit();
            }
            this.hitStatistics.addHit();
            return item.value;
        }
        this.hitStatistics.addMiss();
    }
}
class FifoObject {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    clear() {
        this.items = Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
    }
    delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const deletedItem = this.items[key];
            delete this.items[key];
            this.size--;
            if (deletedItem.prev !== null) {
                deletedItem.prev.next = deletedItem.next;
            }
            if (deletedItem.next !== null) {
                deletedItem.next.prev = deletedItem.prev;
            }
            if (this.first === deletedItem) {
                this.first = deletedItem.next;
            }
            if (this.last === deletedItem) {
                this.last = deletedItem.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            delete this.items[item.key];
            if (--this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            return this.items[key].expiry;
        }
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return Object.keys(this.items);
    }
    set(key, value) {
        // Replace existing item
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items[key] = item;
        if (++this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-app@8.0.1/node_modules/@octokit/auth-app/dist-node/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "createAppAuth",
    ()=>createAppAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request@10.0.2/node_modules/@octokit/request/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$app$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-app@9.0.1/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-rsc] (ecmascript) <locals>");
// pkg/dist-src/get-app-authentication.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-github-app-jwt@2.2.2/node_modules/universal-github-app-jwt/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/cache.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$toad$2d$cache$40$3$2e$7$2e$0$2f$node_modules$2f$toad$2d$cache$2f$dist$2f$toad$2d$cache$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/toad-cache@3.7.0/node_modules/toad-cache/dist/toad-cache.mjs [app-rsc] (ecmascript)");
// pkg/dist-src/hook.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-user@6.0.0/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-rsc] (ecmascript)");
;
;
;
;
async function getAppAuthentication({ appId, privateKey, timeDifference }) {
    try {
        const authOptions = {
            id: appId,
            privateKey
        };
        if (timeDifference) {
            Object.assign(authOptions, {
                now: Math.floor(Date.now() / 1e3) + timeDifference
            });
        }
        const appAuthentication = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$github$2d$app$2d$jwt$40$2$2e$2$2e$2$2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(authOptions);
        return {
            type: "app",
            token: appAuthentication.token,
            appId: appAuthentication.appId,
            expiresAt: new Date(appAuthentication.expiration * 1e3).toISOString()
        };
    } catch (error) {
        if (privateKey === "-----BEGIN RSA PRIVATE KEY-----") {
            throw new Error("The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\n'");
        } else {
            throw error;
        }
    }
}
;
function getCache() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$toad$2d$cache$40$3$2e$7$2e$0$2f$node_modules$2f$toad$2d$cache$2f$dist$2f$toad$2d$cache$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Lru"](// cache max. 15000 tokens, that will use less than 10mb memory
    15e3, // Cache for 1 minute less than GitHub expiry
    1e3 * 60 * 59);
}
async function get(cache, options) {
    const cacheKey = optionsToCacheKey(options);
    const result = await cache.get(cacheKey);
    if (!result) {
        return;
    }
    const [token, createdAt, expiresAt, repositorySelection, permissionsString, singleFileName] = result.split("|");
    const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions2, string)=>{
        if (/!$/.test(string)) {
            permissions2[string.slice(0, -1)] = "write";
        } else {
            permissions2[string] = "read";
        }
        return permissions2;
    }, {});
    return {
        token,
        createdAt,
        expiresAt,
        permissions,
        repositoryIds: options.repositoryIds,
        repositoryNames: options.repositoryNames,
        singleFileName,
        repositorySelection
    };
}
async function set(cache, options, data) {
    const key = optionsToCacheKey(options);
    const permissionsString = options.permissions ? "" : Object.keys(data.permissions).map((name)=>`${name}${data.permissions[name] === "write" ? "!" : ""}`).join(",");
    const value = [
        data.token,
        data.createdAt,
        data.expiresAt,
        data.repositorySelection,
        permissionsString,
        data.singleFileName
    ].join("|");
    await cache.set(key, value);
}
function optionsToCacheKey({ installationId, permissions = {}, repositoryIds = [], repositoryNames = [] }) {
    const permissionsString = Object.keys(permissions).sort().map((name)=>permissions[name] === "read" ? name : `${name}!`).join(",");
    const repositoryIdsString = repositoryIds.sort().join(",");
    const repositoryNamesString = repositoryNames.join(",");
    return [
        installationId,
        repositoryIdsString,
        repositoryNamesString,
        permissionsString
    ].filter(Boolean).join("|");
}
// pkg/dist-src/to-token-authentication.js
function toTokenAuthentication({ installationId, token, createdAt, expiresAt, repositorySelection, permissions, repositoryIds, repositoryNames, singleFileName }) {
    return Object.assign({
        type: "token",
        tokenType: "installation",
        token,
        installationId,
        permissions,
        createdAt,
        expiresAt,
        repositorySelection
    }, repositoryIds ? {
        repositoryIds
    } : null, repositoryNames ? {
        repositoryNames
    } : null, singleFileName ? {
        singleFileName
    } : null);
}
// pkg/dist-src/get-installation-authentication.js
async function getInstallationAuthentication(state, options, customRequest) {
    const installationId = Number(options.installationId || state.installationId);
    if (!installationId) {
        throw new Error("[@octokit/auth-app] installationId option is required for installation authentication.");
    }
    if (options.factory) {
        const { type, factory, oauthApp, ...factoryAuthOptions } = {
            ...state,
            ...options
        };
        return factory(factoryAuthOptions);
    }
    const request = customRequest || state.request;
    return getInstallationAuthenticationConcurrently(state, {
        ...options,
        installationId
    }, request);
}
var pendingPromises = /* @__PURE__ */ new Map();
function getInstallationAuthenticationConcurrently(state, options, request) {
    const cacheKey = optionsToCacheKey(options);
    if (pendingPromises.has(cacheKey)) {
        return pendingPromises.get(cacheKey);
    }
    const promise = getInstallationAuthenticationImpl(state, options, request).finally(()=>pendingPromises.delete(cacheKey));
    pendingPromises.set(cacheKey, promise);
    return promise;
}
async function getInstallationAuthenticationImpl(state, options, request) {
    if (!options.refresh) {
        const result = await get(state.cache, options);
        if (result) {
            const { token: token2, createdAt: createdAt2, expiresAt: expiresAt2, permissions: permissions2, repositoryIds: repositoryIds2, repositoryNames: repositoryNames2, singleFileName: singleFileName2, repositorySelection: repositorySelection2 } = result;
            return toTokenAuthentication({
                installationId: options.installationId,
                token: token2,
                createdAt: createdAt2,
                expiresAt: expiresAt2,
                permissions: permissions2,
                repositorySelection: repositorySelection2,
                repositoryIds: repositoryIds2,
                repositoryNames: repositoryNames2,
                singleFileName: singleFileName2
            });
        }
    }
    const appAuthentication = await getAppAuthentication(state);
    const payload = {
        installation_id: options.installationId,
        mediaType: {
            previews: [
                "machine-man"
            ]
        },
        headers: {
            authorization: `bearer ${appAuthentication.token}`
        }
    };
    if (options.repositoryIds) {
        Object.assign(payload, {
            repository_ids: options.repositoryIds
        });
    }
    if (options.repositoryNames) {
        Object.assign(payload, {
            repositories: options.repositoryNames
        });
    }
    if (options.permissions) {
        Object.assign(payload, {
            permissions: options.permissions
        });
    }
    const { data: { token, expires_at: expiresAt, repositories, permissions: permissionsOptional, repository_selection: repositorySelectionOptional, single_file: singleFileName } } = await request("POST /app/installations/{installation_id}/access_tokens", payload);
    const permissions = permissionsOptional || {};
    const repositorySelection = repositorySelectionOptional || "all";
    const repositoryIds = repositories ? repositories.map((r)=>r.id) : void 0;
    const repositoryNames = repositories ? repositories.map((repo)=>repo.name) : void 0;
    const createdAt = /* @__PURE__ */ new Date().toISOString();
    const cacheOptions = {
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames
    };
    if (singleFileName) {
        Object.assign(payload, {
            singleFileName
        });
    }
    await set(state.cache, options, cacheOptions);
    const cacheData = {
        installationId: options.installationId,
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames
    };
    if (singleFileName) {
        Object.assign(cacheData, {
            singleFileName
        });
    }
    return toTokenAuthentication(cacheData);
}
// pkg/dist-src/auth.js
async function auth(state, authOptions) {
    switch(authOptions.type){
        case "app":
            return getAppAuthentication(state);
        case "oauth-app":
            return state.oauthApp({
                type: "oauth-app"
            });
        case "installation":
            authOptions;
            return getInstallationAuthentication(state, {
                ...authOptions,
                type: "installation"
            });
        case "oauth-user":
            return state.oauthApp(authOptions);
        default:
            throw new Error(`Invalid auth type: ${authOptions.type}`);
    }
}
;
;
// pkg/dist-src/requires-app-auth.js
var PATHS = [
    "/app",
    "/app/hook/config",
    "/app/hook/deliveries",
    "/app/hook/deliveries/{delivery_id}",
    "/app/hook/deliveries/{delivery_id}/attempts",
    "/app/installations",
    "/app/installations/{installation_id}",
    "/app/installations/{installation_id}/access_tokens",
    "/app/installations/{installation_id}/suspended",
    "/app/installation-requests",
    "/marketplace_listing/accounts/{account_id}",
    "/marketplace_listing/plan",
    "/marketplace_listing/plans",
    "/marketplace_listing/plans/{plan_id}/accounts",
    "/marketplace_listing/stubbed/accounts/{account_id}",
    "/marketplace_listing/stubbed/plan",
    "/marketplace_listing/stubbed/plans",
    "/marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "/orgs/{org}/installation",
    "/repos/{owner}/{repo}/installation",
    "/users/{username}/installation"
];
function routeMatcher(paths) {
    const regexes = paths.map((p)=>p.split("/").map((c)=>c.startsWith("{") ? "(?:.+?)" : c).join("/"));
    const regex = `^(?:${regexes.map((r)=>`(?:${r})`).join("|")})$`;
    return new RegExp(regex, "i");
}
var REGEX = routeMatcher(PATHS);
function requiresAppAuth(url) {
    return !!url && REGEX.test(url.split("?")[0]);
}
// pkg/dist-src/hook.js
var FIVE_SECONDS_IN_MS = 5 * 1e3;
function isNotTimeSkewError(error) {
    return !(error.message.match(/'Expiration time' claim \('exp'\) must be a numeric value representing the future time at which the assertion expires/) || error.message.match(/'Issued at' claim \('iat'\) must be an Integer representing the time that the assertion was issued/));
}
async function hook(state, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    const url = endpoint.url;
    if (/\/login\/oauth\/access_token$/.test(url)) {
        return request(endpoint);
    }
    if (requiresAppAuth(url.replace(request.endpoint.DEFAULTS.baseUrl, ""))) {
        const { token: token2 } = await getAppAuthentication(state);
        endpoint.headers.authorization = `bearer ${token2}`;
        let response;
        try {
            response = await request(endpoint);
        } catch (error) {
            if (isNotTimeSkewError(error)) {
                throw error;
            }
            if (typeof error.response.headers.date === "undefined") {
                throw error;
            }
            const diff = Math.floor((Date.parse(error.response.headers.date) - Date.parse(/* @__PURE__ */ new Date().toString())) / 1e3);
            state.log.warn(error.message);
            state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);
            const { token: token3 } = await getAppAuthentication({
                ...state,
                timeDifference: diff
            });
            endpoint.headers.authorization = `bearer ${token3}`;
            return request(endpoint);
        }
        return response;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["requiresBasicAuth"])(url)) {
        const authentication = await state.oauthApp({
            type: "oauth-app"
        });
        endpoint.headers.authorization = authentication.headers.authorization;
        return request(endpoint);
    }
    const { token, createdAt } = await getInstallationAuthentication(state, // @ts-expect-error TBD
    {}, request.defaults({
        baseUrl: endpoint.baseUrl
    }));
    endpoint.headers.authorization = `token ${token}`;
    return sendRequestWithRetries(state, request, endpoint, createdAt);
}
async function sendRequestWithRetries(state, request, options, createdAt, retries = 0) {
    const timeSinceTokenCreationInMs = +/* @__PURE__ */ new Date() - +new Date(createdAt);
    try {
        return await request(options);
    } catch (error) {
        if (error.status !== 401) {
            throw error;
        }
        if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {
            if (retries > 0) {
                error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1e3}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;
            }
            throw error;
        }
        ++retries;
        const awaitTime = retries * 1e3;
        state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1e3}s)`);
        await new Promise((resolve)=>setTimeout(resolve, awaitTime));
        return sendRequestWithRetries(state, request, options, createdAt, retries);
    }
}
// pkg/dist-src/version.js
var VERSION = "8.0.1";
;
function createAppAuth(options) {
    if (!options.appId) {
        throw new Error("[@octokit/auth-app] appId option is required");
    }
    if (!options.privateKey) {
        throw new Error("[@octokit/auth-app] privateKey option is required");
    }
    if ("installationId" in options && !options.installationId) {
        throw new Error("[@octokit/auth-app] installationId is set to a falsy value");
    }
    const log = Object.assign({
        warn: console.warn.bind(console)
    }, options.log);
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$40$10$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["request"].defaults({
        headers: {
            "user-agent": `octokit-auth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
        }
    });
    const state = Object.assign({
        request,
        cache: getCache()
    }, options, options.installationId ? {
        installationId: Number(options.installationId)
    } : {}, {
        log,
        oauthApp: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$app$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createOAuthAppAuth"])({
            clientType: "github-app",
            clientId: options.clientId || "",
            clientSecret: options.clientSecret || "",
            request
        })
    });
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}),
"[project]/node_modules/.pnpm/@octokit+auth-unauthenticated@7.0.1/node_modules/@octokit/auth-unauthenticated/dist-node/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/auth.js
__turbopack_context__.s([
    "createUnauthenticatedAuth",
    ()=>createUnauthenticatedAuth
]);
async function auth(reason) {
    return {
        type: "unauthenticated",
        reason
    };
}
// pkg/dist-src/is-rate-limit-error.js
function isRateLimitError(error) {
    if (error.status !== 403) {
        return false;
    }
    if (!error.response) {
        return false;
    }
    return error.response.headers["x-ratelimit-remaining"] === "0";
}
// pkg/dist-src/is-abuse-limit-error.js
var REGEX_ABUSE_LIMIT_MESSAGE = /\babuse\b/i;
function isAbuseLimitError(error) {
    if (error.status !== 403) {
        return false;
    }
    return REGEX_ABUSE_LIMIT_MESSAGE.test(error.message);
}
// pkg/dist-src/hook.js
async function hook(reason, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    return request(endpoint).catch((error)=>{
        if (error.status === 404) {
            error.message = `Not found. May be due to lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (isRateLimitError(error)) {
            error.message = `API rate limit exceeded. This maybe caused by the lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (isAbuseLimitError(error)) {
            error.message = `You have triggered an abuse detection mechanism. This maybe caused by the lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (error.status === 401) {
            error.message = `Unauthorized. "${endpoint.method} ${endpoint.url}" failed most likely due to lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (error.status >= 400 && error.status < 500) {
            error.message = error.message.replace(/\.?$/, `. May be caused by lack of authentication (${reason}).`);
        }
        throw error;
    });
}
// pkg/dist-src/index.js
var createUnauthenticatedAuth = function createUnauthenticatedAuth2(options) {
    if (!options || !options.reason) {
        throw new Error("[@octokit/auth-unauthenticated] No reason passed to createUnauthenticatedAuth");
    }
    return Object.assign(auth.bind(null, options.reason), {
        hook: hook.bind(null, options.reason)
    });
};
;
}),
"[project]/node_modules/.pnpm/@octokit+oauth-app@8.0.1/node_modules/@octokit/oauth-app/dist-node/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "OAuthApp",
    ()=>OAuthApp,
    "createAWSLambdaAPIGatewayV2Handler",
    ()=>createAWSLambdaAPIGatewayV2Handler,
    "createNodeMiddleware",
    ()=>createNodeMiddleware,
    "createWebWorkerHandler",
    ()=>createWebWorkerHandler,
    "handleRequest",
    ()=>handleRequest,
    "sendNodeResponse",
    ()=>sendResponse,
    "unknownRouteResponse",
    ()=>unknownRouteResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$app$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-app@9.0.1/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-rsc] (ecmascript) <locals>");
// pkg/dist-src/oauth-app-octokit.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/methods/get-user-octokit.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-oauth-user@6.0.0/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/methods/get-web-flow-authorization-url.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-methods@6.0.0/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-unauthenticated@7.0.1/node_modules/@octokit/auth-unauthenticated/dist-node/index.js [app-rsc] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "8.0.1";
// pkg/dist-src/add-event-handler.js
function addEventHandler(state, eventName, eventHandler) {
    if (Array.isArray(eventName)) {
        for (const singleEventName of eventName){
            addEventHandler(state, singleEventName, eventHandler);
        }
        return;
    }
    if (!state.eventHandlers[eventName]) {
        state.eventHandlers[eventName] = [];
    }
    state.eventHandlers[eventName].push(eventHandler);
}
;
;
var OAuthAppOctokit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Octokit"].defaults({
    userAgent: `octokit-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$universal$2d$user$2d$agent$40$7$2e$0$2e$3$2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
});
;
// pkg/dist-src/emit-event.js
async function emitEvent(state, context) {
    const { name, action } = context;
    if (state.eventHandlers[`${name}.${action}`]) {
        for (const eventHandler of state.eventHandlers[`${name}.${action}`]){
            await eventHandler(context);
        }
    }
    if (state.eventHandlers[name]) {
        for (const eventHandler of state.eventHandlers[name]){
            await eventHandler(context);
        }
    }
}
// pkg/dist-src/methods/get-user-octokit.js
async function getUserOctokitWithState(state, options) {
    return state.octokit.auth({
        type: "oauth-user",
        ...options,
        async factory (options2) {
            const octokit = new state.Octokit({
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
                auth: options2
            });
            const authentication = await octokit.auth({
                type: "get"
            });
            await emitEvent(state, {
                name: "token",
                action: "created",
                token: authentication.token,
                scopes: authentication.scopes,
                authentication,
                octokit
            });
            return octokit;
        }
    });
}
;
function getWebFlowAuthorizationUrlWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        request: state.octokit.request,
        ...options,
        allowSignup: state.allowSignup ?? options.allowSignup,
        redirectUrl: options.redirectUrl ?? state.redirectUrl,
        scopes: options.scopes ?? state.defaultScopes
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getWebFlowAuthorizationUrl"]({
        clientType: state.clientType,
        ...optionsWithDefaults
    });
}
;
async function createTokenWithState(state, options) {
    const authentication = await state.octokit.auth({
        type: "oauth-user",
        ...options
    });
    await emitEvent(state, {
        name: "token",
        action: "created",
        token: authentication.token,
        scopes: authentication.scopes,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: authentication.token,
                scopes: authentication.scopes,
                refreshToken: authentication.refreshToken,
                expiresAt: authentication.expiresAt,
                refreshTokenExpiresAt: authentication.refreshTokenExpiresAt
            }
        })
    });
    return {
        authentication
    };
}
;
async function checkTokenWithState(state, options) {
    const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["checkToken"]({
        // @ts-expect-error not worth the extra code to appease TS
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    });
    Object.assign(result.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    return result;
}
;
;
async function resetTokenWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    if (state.clientType === "oauth-app") {
        const response2 = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resetToken"]({
            clientType: "oauth-app",
            ...optionsWithDefaults
        });
        const authentication2 = Object.assign(response2.authentication, {
            type: "token",
            tokenType: "oauth"
        });
        await emitEvent(state, {
            name: "token",
            action: "reset",
            token: response2.authentication.token,
            scopes: response2.authentication.scopes || void 0,
            authentication: authentication2,
            octokit: new state.Octokit({
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
                auth: {
                    clientType: state.clientType,
                    clientId: state.clientId,
                    clientSecret: state.clientSecret,
                    token: response2.authentication.token,
                    scopes: response2.authentication.scopes
                }
            })
        });
        return {
            ...response2,
            authentication: authentication2
        };
    }
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resetToken"]({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "reset",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function refreshTokenWithState(state, options) {
    if (state.clientType === "oauth-app") {
        throw new Error("[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps");
    }
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["refreshToken"]({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        refreshToken: options.refreshToken
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "refreshed",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function scopeTokenWithState(state, options) {
    if (state.clientType === "oauth-app") {
        throw new Error("[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps");
    }
    const response = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scopeToken"]({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "scoped",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$user$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function deleteTokenWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    const response = state.clientType === "oauth-app" ? await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteToken"]({
        clientType: "oauth-app",
        ...optionsWithDefaults
    }) : /* v8 ignore next 4 */ await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteToken"]({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "token.deleted" event. The access for the token has been revoked.`
            }
        })
    });
    return response;
}
;
;
async function deleteAuthorizationWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    const response = state.clientType === "oauth-app" ? await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteAuthorization"]({
        clientType: "oauth-app",
        ...optionsWithDefaults
    }) : /* v8 ignore next 4 */ await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["deleteAuthorization"]({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "token.deleted" event. The access for the token has been revoked.`
            }
        })
    });
    await emitEvent(state, {
        name: "authorization",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "authorization.deleted" event. The access for the app has been revoked.`
            }
        })
    });
    return response;
}
// pkg/dist-src/middleware/unknown-route-response.js
function unknownRouteResponse(request) {
    return {
        status: 404,
        headers: {
            "content-type": "application/json"
        },
        text: JSON.stringify({
            error: `Unknown route: ${request.method} ${request.url}`
        })
    };
}
// pkg/dist-src/middleware/handle-request.js
async function handleRequest(app, { pathPrefix = "/api/github/oauth" }, request) {
    let { pathname } = new URL(request.url, "http://localhost");
    if (!pathname.startsWith(`${pathPrefix}/`)) {
        return void 0;
    }
    if (request.method === "OPTIONS") {
        return {
            status: 200,
            headers: {
                "access-control-allow-origin": "*",
                "access-control-allow-methods": "*",
                "access-control-allow-headers": "Content-Type, User-Agent, Authorization"
            }
        };
    }
    pathname = pathname.slice(pathPrefix.length + 1);
    const route = [
        request.method,
        pathname
    ].join(" ");
    const routes = {
        getLogin: `GET login`,
        getCallback: `GET callback`,
        createToken: `POST token`,
        getToken: `GET token`,
        patchToken: `PATCH token`,
        patchRefreshToken: `PATCH refresh-token`,
        scopeToken: `POST token/scoped`,
        deleteToken: `DELETE token`,
        deleteGrant: `DELETE grant`
    };
    if (!Object.values(routes).includes(route)) {
        return unknownRouteResponse(request);
    }
    let json;
    try {
        const text = await request.text();
        json = text ? JSON.parse(text) : {};
    } catch (error) {
        return {
            status: 400,
            headers: {
                "content-type": "application/json",
                "access-control-allow-origin": "*"
            },
            text: JSON.stringify({
                error: "[@octokit/oauth-app] request error"
            })
        };
    }
    const { searchParams } = new URL(request.url, "http://localhost");
    const query = Object.fromEntries(searchParams);
    const headers = request.headers;
    try {
        if (route === routes.getLogin) {
            const authOptions = {};
            if (query.state) {
                Object.assign(authOptions, {
                    state: query.state
                });
            }
            if (query.scopes) {
                Object.assign(authOptions, {
                    scopes: query.scopes.split(",")
                });
            }
            if (query.allowSignup) {
                Object.assign(authOptions, {
                    allowSignup: query.allowSignup === "true"
                });
            }
            if (query.redirectUrl) {
                Object.assign(authOptions, {
                    redirectUrl: query.redirectUrl
                });
            }
            const { url } = app.getWebFlowAuthorizationUrl(authOptions);
            return {
                status: 302,
                headers: {
                    location: url
                }
            };
        }
        if (route === routes.getCallback) {
            if (query.error) {
                throw new Error(`[@octokit/oauth-app] ${query.error} ${query.error_description}`);
            }
            if (!query.code) {
                throw new Error('[@octokit/oauth-app] "code" parameter is required');
            }
            const { authentication: { token: token2 } } = await app.createToken({
                code: query.code
            });
            return {
                status: 200,
                headers: {
                    "content-type": "text/html"
                },
                text: `<h1>Token created successfully</h1>

<p>Your token is: <strong>${token2}</strong>. Copy it now as it cannot be shown again.</p>`
            };
        }
        if (route === routes.createToken) {
            const { code, redirectUrl } = json;
            if (!code) {
                throw new Error('[@octokit/oauth-app] "code" parameter is required');
            }
            const result = await app.createToken({
                code,
                redirectUrl
            });
            delete result.authentication.clientSecret;
            return {
                status: 201,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.getToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.checkToken({
                token: token2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.patchToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.resetToken({
                token: token2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.patchRefreshToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const { refreshToken: refreshToken2 } = json;
            if (!refreshToken2) {
                throw new Error("[@octokit/oauth-app] refreshToken must be sent in request body");
            }
            const result = await app.refreshToken({
                refreshToken: refreshToken2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.scopeToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.scopeToken({
                token: token2,
                ...json
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.deleteToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            await app.deleteToken({
                token: token2
            });
            return {
                status: 204,
                headers: {
                    "access-control-allow-origin": "*"
                }
            };
        }
        const token = headers.authorization?.substr("token ".length);
        if (!token) {
            throw new Error('[@octokit/oauth-app] "Authorization" header is required');
        }
        await app.deleteAuthorization({
            token
        });
        return {
            status: 204,
            headers: {
                "access-control-allow-origin": "*"
            }
        };
    } catch (error) {
        return {
            status: 400,
            headers: {
                "content-type": "application/json",
                "access-control-allow-origin": "*"
            },
            text: JSON.stringify({
                error: error.message
            })
        };
    }
}
// pkg/dist-src/middleware/node/parse-request.js
function parseRequest(request) {
    const { method, url, headers } = request;
    async function text() {
        const text2 = await new Promise((resolve, reject)=>{
            let bodyChunks = [];
            request.on("error", reject).on("data", (chunk)=>bodyChunks.push(chunk)).on("end", ()=>resolve(Buffer.concat(bodyChunks).toString()));
        });
        return text2;
    }
    return {
        method,
        url,
        headers,
        text
    };
}
// pkg/dist-src/middleware/node/send-response.js
function sendResponse(octokitResponse, response) {
    response.writeHead(octokitResponse.status, octokitResponse.headers);
    response.end(octokitResponse.text);
}
// pkg/dist-src/middleware/node/index.js
function createNodeMiddleware(app, options = {}) {
    return async function(request, response, next) {
        const octokitRequest = await parseRequest(request);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        if (octokitResponse) {
            sendResponse(octokitResponse, response);
            return true;
        } else {
            next?.();
            return false;
        }
    };
}
// pkg/dist-src/middleware/web-worker/parse-request.js
function parseRequest2(request) {
    const headers = Object.fromEntries(request.headers.entries());
    return {
        method: request.method,
        url: request.url,
        headers,
        text: ()=>request.text()
    };
}
// pkg/dist-src/middleware/web-worker/send-response.js
function sendResponse2(octokitResponse) {
    const responseOptions = {
        status: octokitResponse.status
    };
    if (octokitResponse.headers) {
        Object.assign(responseOptions, {
            headers: octokitResponse.headers
        });
    }
    return new Response(octokitResponse.text, responseOptions);
}
// pkg/dist-src/middleware/web-worker/index.js
function createWebWorkerHandler(app, options = {}) {
    return async function(request) {
        const octokitRequest = await parseRequest2(request);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        return octokitResponse ? sendResponse2(octokitResponse) : void 0;
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2-parse-request.js
function parseRequest3(request) {
    const { method } = request.requestContext.http;
    let url = request.rawPath;
    const { stage } = request.requestContext;
    if (url.startsWith("/" + stage)) url = url.substring(stage.length + 1);
    if (request.rawQueryString) url += "?" + request.rawQueryString;
    const headers = request.headers;
    const text = async ()=>request.body || "";
    return {
        method,
        url,
        headers,
        text
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2-send-response.js
function sendResponse3(octokitResponse) {
    return {
        statusCode: octokitResponse.status,
        headers: octokitResponse.headers,
        body: octokitResponse.text
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2.js
function createAWSLambdaAPIGatewayV2Handler(app, options = {}) {
    return async function(event) {
        const request = parseRequest3(event);
        const response = await handleRequest(app, options, request);
        return response ? sendResponse3(response) : void 0;
    };
}
// pkg/dist-src/index.js
var OAuthApp = class {
    static VERSION = VERSION;
    static defaults(defaults) {
        const OAuthAppWithDefaults = class extends this {
            constructor(...args){
                super({
                    ...defaults,
                    ...args[0]
                });
            }
        };
        return OAuthAppWithDefaults;
    }
    constructor(options){
        const Octokit2 = options.Octokit || OAuthAppOctokit;
        this.type = options.clientType || "oauth-app";
        const octokit = new Octokit2({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$oauth$2d$app$40$9$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createOAuthAppAuth"],
            auth: {
                clientType: this.type,
                clientId: options.clientId,
                clientSecret: options.clientSecret
            }
        });
        const state = {
            clientType: this.type,
            clientId: options.clientId,
            clientSecret: options.clientSecret,
            // @ts-expect-error defaultScopes not permitted for GitHub Apps
            defaultScopes: options.defaultScopes || [],
            allowSignup: options.allowSignup,
            baseUrl: options.baseUrl,
            redirectUrl: options.redirectUrl,
            log: options.log,
            Octokit: Octokit2,
            octokit,
            eventHandlers: {}
        };
        this.on = addEventHandler.bind(null, state);
        this.octokit = octokit;
        this.getUserOctokit = getUserOctokitWithState.bind(null, state);
        this.getWebFlowAuthorizationUrl = getWebFlowAuthorizationUrlWithState.bind(null, state);
        this.createToken = createTokenWithState.bind(null, state);
        this.checkToken = checkTokenWithState.bind(null, state);
        this.resetToken = resetTokenWithState.bind(null, state);
        this.refreshToken = refreshTokenWithState.bind(null, state);
        this.scopeToken = scopeTokenWithState.bind(null, state);
        this.deleteToken = deleteTokenWithState.bind(null, state);
        this.deleteAuthorization = deleteAuthorizationWithState.bind(null, state);
    }
    // assigned during constructor
    type;
    on;
    octokit;
    getUserOctokit;
    getWebFlowAuthorizationUrl;
    createToken;
    checkToken;
    resetToken;
    refreshToken;
    scopeToken;
    deleteToken;
    deleteAuthorization;
};
;
}),
"[project]/node_modules/.pnpm/@octokit+webhooks-methods@6.0.0/node_modules/@octokit/webhooks-methods/dist-node/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/node/sign.js
__turbopack_context__.s([
    "sign",
    ()=>sign,
    "verify",
    ()=>verify,
    "verifyWithFallback",
    ()=>verifyWithFallback
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
;
// pkg/dist-src/version.js
var VERSION = "6.0.0";
// pkg/dist-src/node/sign.js
async function sign(secret, payload) {
    if (!secret || !payload) {
        throw new TypeError("[@octokit/webhooks-methods] secret & payload required for sign()");
    }
    if (typeof payload !== "string") {
        throw new TypeError("[@octokit/webhooks-methods] payload must be a string");
    }
    const algorithm = "sha256";
    return `${algorithm}=${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["createHmac"])(algorithm, secret).update(payload).digest("hex")}`;
}
sign.VERSION = VERSION;
;
;
async function verify(secret, eventPayload, signature) {
    if (!secret || !eventPayload || !signature) {
        throw new TypeError("[@octokit/webhooks-methods] secret, eventPayload & signature required");
    }
    if (typeof eventPayload !== "string") {
        throw new TypeError("[@octokit/webhooks-methods] eventPayload must be a string");
    }
    const signatureBuffer = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(signature);
    const verificationBuffer = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].from(await sign(secret, eventPayload));
    if (signatureBuffer.length !== verificationBuffer.length) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["timingSafeEqual"])(signatureBuffer, verificationBuffer);
}
verify.VERSION = VERSION;
// pkg/dist-src/index.js
async function verifyWithFallback(secret, payload, signature, additionalSecrets) {
    const firstPass = await verify(secret, payload, signature);
    if (firstPass) {
        return true;
    }
    if (additionalSecrets !== void 0) {
        for (const s of additionalSecrets){
            const v = await verify(s, payload, signature);
            if (v) {
                return v;
            }
        }
    }
    return false;
}
;
}),
"[project]/node_modules/.pnpm/@octokit+webhooks@14.0.0/node_modules/@octokit/webhooks/dist-bundle/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/create-logger.js
__turbopack_context__.s([
    "Webhooks",
    ()=>Webhooks,
    "createEventHandler",
    ()=>createEventHandler,
    "createNodeMiddleware",
    ()=>createNodeMiddleware,
    "createWebMiddleware",
    ()=>createWebMiddleware,
    "emitterEventNames",
    ()=>emitterEventNames
]);
// pkg/dist-src/index.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+webhooks-methods@6.0.0/node_modules/@octokit/webhooks-methods/dist-node/index.js [app-rsc] (ecmascript)");
var createLogger = (logger)=>({
        debug: ()=>{},
        info: ()=>{},
        warn: console.warn.bind(console),
        error: console.error.bind(console),
        ...logger
    });
// pkg/dist-src/generated/webhook-names.js
var emitterEventNames = [
    "branch_protection_configuration",
    "branch_protection_configuration.disabled",
    "branch_protection_configuration.enabled",
    "branch_protection_rule",
    "branch_protection_rule.created",
    "branch_protection_rule.deleted",
    "branch_protection_rule.edited",
    "check_run",
    "check_run.completed",
    "check_run.created",
    "check_run.requested_action",
    "check_run.rerequested",
    "check_suite",
    "check_suite.completed",
    "check_suite.requested",
    "check_suite.rerequested",
    "code_scanning_alert",
    "code_scanning_alert.appeared_in_branch",
    "code_scanning_alert.closed_by_user",
    "code_scanning_alert.created",
    "code_scanning_alert.fixed",
    "code_scanning_alert.reopened",
    "code_scanning_alert.reopened_by_user",
    "commit_comment",
    "commit_comment.created",
    "create",
    "custom_property",
    "custom_property.created",
    "custom_property.deleted",
    "custom_property.promote_to_enterprise",
    "custom_property.updated",
    "custom_property_values",
    "custom_property_values.updated",
    "delete",
    "dependabot_alert",
    "dependabot_alert.auto_dismissed",
    "dependabot_alert.auto_reopened",
    "dependabot_alert.created",
    "dependabot_alert.dismissed",
    "dependabot_alert.fixed",
    "dependabot_alert.reintroduced",
    "dependabot_alert.reopened",
    "deploy_key",
    "deploy_key.created",
    "deploy_key.deleted",
    "deployment",
    "deployment.created",
    "deployment_protection_rule",
    "deployment_protection_rule.requested",
    "deployment_review",
    "deployment_review.approved",
    "deployment_review.rejected",
    "deployment_review.requested",
    "deployment_status",
    "deployment_status.created",
    "discussion",
    "discussion.answered",
    "discussion.category_changed",
    "discussion.closed",
    "discussion.created",
    "discussion.deleted",
    "discussion.edited",
    "discussion.labeled",
    "discussion.locked",
    "discussion.pinned",
    "discussion.reopened",
    "discussion.transferred",
    "discussion.unanswered",
    "discussion.unlabeled",
    "discussion.unlocked",
    "discussion.unpinned",
    "discussion_comment",
    "discussion_comment.created",
    "discussion_comment.deleted",
    "discussion_comment.edited",
    "fork",
    "github_app_authorization",
    "github_app_authorization.revoked",
    "gollum",
    "installation",
    "installation.created",
    "installation.deleted",
    "installation.new_permissions_accepted",
    "installation.suspend",
    "installation.unsuspend",
    "installation_repositories",
    "installation_repositories.added",
    "installation_repositories.removed",
    "installation_target",
    "installation_target.renamed",
    "issue_comment",
    "issue_comment.created",
    "issue_comment.deleted",
    "issue_comment.edited",
    "issues",
    "issues.assigned",
    "issues.closed",
    "issues.deleted",
    "issues.demilestoned",
    "issues.edited",
    "issues.labeled",
    "issues.locked",
    "issues.milestoned",
    "issues.opened",
    "issues.pinned",
    "issues.reopened",
    "issues.transferred",
    "issues.typed",
    "issues.unassigned",
    "issues.unlabeled",
    "issues.unlocked",
    "issues.unpinned",
    "issues.untyped",
    "label",
    "label.created",
    "label.deleted",
    "label.edited",
    "marketplace_purchase",
    "marketplace_purchase.cancelled",
    "marketplace_purchase.changed",
    "marketplace_purchase.pending_change",
    "marketplace_purchase.pending_change_cancelled",
    "marketplace_purchase.purchased",
    "member",
    "member.added",
    "member.edited",
    "member.removed",
    "membership",
    "membership.added",
    "membership.removed",
    "merge_group",
    "merge_group.checks_requested",
    "merge_group.destroyed",
    "meta",
    "meta.deleted",
    "milestone",
    "milestone.closed",
    "milestone.created",
    "milestone.deleted",
    "milestone.edited",
    "milestone.opened",
    "org_block",
    "org_block.blocked",
    "org_block.unblocked",
    "organization",
    "organization.deleted",
    "organization.member_added",
    "organization.member_invited",
    "organization.member_removed",
    "organization.renamed",
    "package",
    "package.published",
    "package.updated",
    "page_build",
    "personal_access_token_request",
    "personal_access_token_request.approved",
    "personal_access_token_request.cancelled",
    "personal_access_token_request.created",
    "personal_access_token_request.denied",
    "ping",
    "project",
    "project.closed",
    "project.created",
    "project.deleted",
    "project.edited",
    "project.reopened",
    "project_card",
    "project_card.converted",
    "project_card.created",
    "project_card.deleted",
    "project_card.edited",
    "project_card.moved",
    "project_column",
    "project_column.created",
    "project_column.deleted",
    "project_column.edited",
    "project_column.moved",
    "projects_v2",
    "projects_v2.closed",
    "projects_v2.created",
    "projects_v2.deleted",
    "projects_v2.edited",
    "projects_v2.reopened",
    "projects_v2_item",
    "projects_v2_item.archived",
    "projects_v2_item.converted",
    "projects_v2_item.created",
    "projects_v2_item.deleted",
    "projects_v2_item.edited",
    "projects_v2_item.reordered",
    "projects_v2_item.restored",
    "projects_v2_status_update",
    "projects_v2_status_update.created",
    "projects_v2_status_update.deleted",
    "projects_v2_status_update.edited",
    "public",
    "pull_request",
    "pull_request.assigned",
    "pull_request.auto_merge_disabled",
    "pull_request.auto_merge_enabled",
    "pull_request.closed",
    "pull_request.converted_to_draft",
    "pull_request.demilestoned",
    "pull_request.dequeued",
    "pull_request.edited",
    "pull_request.enqueued",
    "pull_request.labeled",
    "pull_request.locked",
    "pull_request.milestoned",
    "pull_request.opened",
    "pull_request.ready_for_review",
    "pull_request.reopened",
    "pull_request.review_request_removed",
    "pull_request.review_requested",
    "pull_request.synchronize",
    "pull_request.unassigned",
    "pull_request.unlabeled",
    "pull_request.unlocked",
    "pull_request_review",
    "pull_request_review.dismissed",
    "pull_request_review.edited",
    "pull_request_review.submitted",
    "pull_request_review_comment",
    "pull_request_review_comment.created",
    "pull_request_review_comment.deleted",
    "pull_request_review_comment.edited",
    "pull_request_review_thread",
    "pull_request_review_thread.resolved",
    "pull_request_review_thread.unresolved",
    "push",
    "registry_package",
    "registry_package.published",
    "registry_package.updated",
    "release",
    "release.created",
    "release.deleted",
    "release.edited",
    "release.prereleased",
    "release.published",
    "release.released",
    "release.unpublished",
    "repository",
    "repository.archived",
    "repository.created",
    "repository.deleted",
    "repository.edited",
    "repository.privatized",
    "repository.publicized",
    "repository.renamed",
    "repository.transferred",
    "repository.unarchived",
    "repository_advisory",
    "repository_advisory.published",
    "repository_advisory.reported",
    "repository_dispatch",
    "repository_dispatch.sample.collected",
    "repository_import",
    "repository_ruleset",
    "repository_ruleset.created",
    "repository_ruleset.deleted",
    "repository_ruleset.edited",
    "repository_vulnerability_alert",
    "repository_vulnerability_alert.create",
    "repository_vulnerability_alert.dismiss",
    "repository_vulnerability_alert.reopen",
    "repository_vulnerability_alert.resolve",
    "secret_scanning_alert",
    "secret_scanning_alert.created",
    "secret_scanning_alert.publicly_leaked",
    "secret_scanning_alert.reopened",
    "secret_scanning_alert.resolved",
    "secret_scanning_alert.validated",
    "secret_scanning_alert_location",
    "secret_scanning_alert_location.created",
    "secret_scanning_scan",
    "secret_scanning_scan.completed",
    "security_advisory",
    "security_advisory.published",
    "security_advisory.updated",
    "security_advisory.withdrawn",
    "security_and_analysis",
    "sponsorship",
    "sponsorship.cancelled",
    "sponsorship.created",
    "sponsorship.edited",
    "sponsorship.pending_cancellation",
    "sponsorship.pending_tier_change",
    "sponsorship.tier_changed",
    "star",
    "star.created",
    "star.deleted",
    "status",
    "sub_issues",
    "sub_issues.parent_issue_added",
    "sub_issues.parent_issue_removed",
    "sub_issues.sub_issue_added",
    "sub_issues.sub_issue_removed",
    "team",
    "team.added_to_repository",
    "team.created",
    "team.deleted",
    "team.edited",
    "team.removed_from_repository",
    "team_add",
    "watch",
    "watch.started",
    "workflow_dispatch",
    "workflow_job",
    "workflow_job.completed",
    "workflow_job.in_progress",
    "workflow_job.queued",
    "workflow_job.waiting",
    "workflow_run",
    "workflow_run.completed",
    "workflow_run.in_progress",
    "workflow_run.requested"
];
// pkg/dist-src/event-handler/on.js
function handleEventHandlers(state, webhookName, handler) {
    if (!state.hooks[webhookName]) {
        state.hooks[webhookName] = [];
    }
    state.hooks[webhookName].push(handler);
}
function receiverOn(state, webhookNameOrNames, handler) {
    if (Array.isArray(webhookNameOrNames)) {
        webhookNameOrNames.forEach((webhookName)=>receiverOn(state, webhookName, handler));
        return;
    }
    if ([
        "*",
        "error"
    ].includes(webhookNameOrNames)) {
        const webhookName = webhookNameOrNames === "*" ? "any" : webhookNameOrNames;
        const message = `Using the "${webhookNameOrNames}" event with the regular Webhooks.on() function is not supported. Please use the Webhooks.on${webhookName.charAt(0).toUpperCase() + webhookName.slice(1)}() method instead`;
        throw new Error(message);
    }
    if (!emitterEventNames.includes(webhookNameOrNames)) {
        state.log.warn(`"${webhookNameOrNames}" is not a known webhook name (https://developer.github.com/v3/activity/events/types/)`);
    }
    handleEventHandlers(state, webhookNameOrNames, handler);
}
function receiverOnAny(state, handler) {
    handleEventHandlers(state, "*", handler);
}
function receiverOnError(state, handler) {
    handleEventHandlers(state, "error", handler);
}
// pkg/dist-src/event-handler/wrap-error-handler.js
function wrapErrorHandler(handler, error) {
    let returnValue;
    try {
        returnValue = handler(error);
    } catch (error2) {
        console.log('FATAL: Error occurred in "error" event handler');
        console.log(error2);
    }
    if (returnValue && returnValue.catch) {
        returnValue.catch((error2)=>{
            console.log('FATAL: Error occurred in "error" event handler');
            console.log(error2);
        });
    }
}
// pkg/dist-src/event-handler/receive.js
function getHooks(state, eventPayloadAction, eventName) {
    const hooks = [
        state.hooks[eventName],
        state.hooks["*"]
    ];
    if (eventPayloadAction) {
        hooks.unshift(state.hooks[`${eventName}.${eventPayloadAction}`]);
    }
    return [].concat(...hooks.filter(Boolean));
}
function receiverHandle(state, event) {
    const errorHandlers = state.hooks.error || [];
    if (event instanceof Error) {
        const error = Object.assign(new AggregateError([
            event
        ], event.message), {
            event
        });
        errorHandlers.forEach((handler)=>wrapErrorHandler(handler, error));
        return Promise.reject(error);
    }
    if (!event || !event.name) {
        const error = new Error("Event name not passed");
        throw new AggregateError([
            error
        ], error.message);
    }
    if (!event.payload) {
        const error = new Error("Event name not passed");
        throw new AggregateError([
            error
        ], error.message);
    }
    const hooks = getHooks(state, "action" in event.payload ? event.payload.action : null, event.name);
    if (hooks.length === 0) {
        return Promise.resolve();
    }
    const errors = [];
    const promises = hooks.map((handler)=>{
        let promise = Promise.resolve(event);
        if (state.transform) {
            promise = promise.then(state.transform);
        }
        return promise.then((event2)=>{
            return handler(event2);
        }).catch((error)=>errors.push(Object.assign(error, {
                event
            })));
    });
    return Promise.all(promises).then(()=>{
        if (errors.length === 0) {
            return;
        }
        const error = new AggregateError(errors, errors.map((error2)=>error2.message).join("\n"));
        Object.assign(error, {
            event
        });
        errorHandlers.forEach((handler)=>wrapErrorHandler(handler, error));
        throw error;
    });
}
// pkg/dist-src/event-handler/remove-listener.js
function removeListener(state, webhookNameOrNames, handler) {
    if (Array.isArray(webhookNameOrNames)) {
        webhookNameOrNames.forEach((webhookName)=>removeListener(state, webhookName, handler));
        return;
    }
    if (!state.hooks[webhookNameOrNames]) {
        return;
    }
    for(let i = state.hooks[webhookNameOrNames].length - 1; i >= 0; i--){
        if (state.hooks[webhookNameOrNames][i] === handler) {
            state.hooks[webhookNameOrNames].splice(i, 1);
            return;
        }
    }
}
// pkg/dist-src/event-handler/index.js
function createEventHandler(options) {
    const state = {
        hooks: {},
        log: createLogger(options && options.log)
    };
    if (options && options.transform) {
        state.transform = options.transform;
    }
    return {
        on: receiverOn.bind(null, state),
        onAny: receiverOnAny.bind(null, state),
        onError: receiverOnError.bind(null, state),
        removeListener: removeListener.bind(null, state),
        receive: receiverHandle.bind(null, state)
    };
}
;
;
async function verifyAndReceive(state, event) {
    const matchesSignature = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["verifyWithFallback"])(state.secret, event.payload, event.signature, state.additionalSecrets).catch(()=>false);
    if (!matchesSignature) {
        const error = new Error("[@octokit/webhooks] signature does not match event payload and secret");
        return state.eventHandler.receive(Object.assign(error, {
            event,
            status: 400
        }));
    }
    let payload;
    try {
        payload = JSON.parse(event.payload);
    } catch (error) {
        error.message = "Invalid JSON";
        error.status = 400;
        throw new AggregateError([
            error
        ], error.message);
    }
    return state.eventHandler.receive({
        id: event.id,
        name: event.name,
        payload
    });
}
// pkg/dist-src/middleware/create-middleware.js
var isApplicationJsonRE = /^\s*(application\/json)\s*(?:;|$)/u;
var WEBHOOK_HEADERS = [
    "x-github-event",
    "x-hub-signature-256",
    "x-github-delivery"
];
function createMiddleware(options) {
    const { handleResponse: handleResponse3, getRequestHeader: getRequestHeader3, getPayload: getPayload3 } = options;
    return function middleware(webhooks, options2) {
        return async function octokitWebhooksMiddleware(request, response, next) {
            let pathname;
            try {
                pathname = new URL(request.url, "http://localhost").pathname;
            } catch (error) {
                return handleResponse3(JSON.stringify({
                    error: `Request URL could not be parsed: ${request.url}`
                }), 422, {
                    "content-type": "application/json"
                }, response);
            }
            if (pathname !== options2.path) {
                next?.();
                return handleResponse3(null);
            } else if (request.method !== "POST") {
                return handleResponse3(JSON.stringify({
                    error: `Unknown route: ${request.method} ${pathname}`
                }), 404, {
                    "content-type": "application/json"
                }, response);
            }
            const contentType = getRequestHeader3(request, "content-type");
            if (typeof contentType !== "string" || !isApplicationJsonRE.test(contentType)) {
                return handleResponse3(JSON.stringify({
                    error: `Unsupported "Content-Type" header value. Must be "application/json"`
                }), 415, {
                    "content-type": "application/json",
                    accept: "application/json"
                }, response);
            }
            const missingHeaders = WEBHOOK_HEADERS.filter((header)=>{
                return getRequestHeader3(request, header) == void 0;
            }).join(", ");
            if (missingHeaders) {
                return handleResponse3(JSON.stringify({
                    error: `Required headers missing: ${missingHeaders}`
                }), 400, {
                    "content-type": "application/json",
                    accept: "application/json"
                }, response);
            }
            const eventName = getRequestHeader3(request, "x-github-event");
            const signature = getRequestHeader3(request, "x-hub-signature-256");
            const id = getRequestHeader3(request, "x-github-delivery");
            options2.log.debug(`${eventName} event received (id: ${id})`);
            let didTimeout = false;
            let timeout;
            const timeoutPromise = new Promise((resolve)=>{
                timeout = setTimeout(()=>{
                    didTimeout = true;
                    resolve(handleResponse3("still processing\n", 202, {
                        "Content-Type": "text/plain",
                        accept: "application/json"
                    }, response));
                }, options2.timeout);
            });
            const processWebhook = async ()=>{
                try {
                    const payload = await getPayload3(request);
                    await webhooks.verifyAndReceive({
                        id,
                        name: eventName,
                        payload,
                        signature
                    });
                    clearTimeout(timeout);
                    if (didTimeout) return handleResponse3(null);
                    return handleResponse3("ok\n", 200, {
                        "content-type": "text/plain",
                        accept: "application/json"
                    }, response);
                } catch (error) {
                    clearTimeout(timeout);
                    if (didTimeout) return handleResponse3(null);
                    const err = Array.from(error.errors)[0];
                    const errorMessage = err.message ? `${err.name}: ${err.message}` : "Error: An Unspecified error occurred";
                    const statusCode = typeof err.status !== "undefined" ? err.status : 500;
                    options2.log.error(error);
                    return handleResponse3(JSON.stringify({
                        error: errorMessage
                    }), statusCode, {
                        "content-type": "application/json",
                        accept: "application/json"
                    }, response);
                }
            };
            return await Promise.race([
                timeoutPromise,
                processWebhook()
            ]);
        };
    };
}
// pkg/dist-src/middleware/node/handle-response.js
function handleResponse(body, status = 200, headers = {}, response) {
    if (body === null) {
        return false;
    }
    headers["content-length"] = body.length.toString();
    response.writeHead(status, headers).end(body);
    return true;
}
// pkg/dist-src/middleware/node/get-request-header.js
function getRequestHeader(request, key) {
    return request.headers[key];
}
// pkg/dist-src/concat-uint8array.js
function concatUint8Array(data) {
    if (data.length === 0) {
        return new Uint8Array(0);
    }
    let totalLength = 0;
    for(let i = 0; i < data.length; i++){
        totalLength += data[i].length;
    }
    if (totalLength === 0) {
        return new Uint8Array(0);
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for(let i = 0; i < data.length; i++){
        result.set(data[i], offset);
        offset += data[i].length;
    }
    return result;
}
// pkg/dist-src/middleware/node/get-payload.js
var textDecoder = new TextDecoder("utf-8", {
    fatal: false
});
var decode = textDecoder.decode.bind(textDecoder);
async function getPayload(request) {
    if (typeof request.body === "object" && "rawBody" in request && request.rawBody instanceof Uint8Array) {
        return decode(request.rawBody);
    } else if (typeof request.body === "string") {
        return request.body;
    }
    const payload = await getPayloadFromRequestStream(request);
    return decode(payload);
}
function getPayloadFromRequestStream(request) {
    return new Promise((resolve, reject)=>{
        let data = [];
        request.on("error", (error)=>reject(new AggregateError([
                error
            ], error.message)));
        request.on("data", data.push.bind(data));
        request.on("end", ()=>{
            const result = concatUint8Array(data);
            queueMicrotask(()=>resolve(result));
        });
    });
}
// pkg/dist-src/middleware/node/index.js
function createNodeMiddleware(webhooks, { path = "/api/github/webhooks", log = createLogger(), timeout = 9e3 } = {}) {
    return createMiddleware({
        handleResponse,
        getRequestHeader,
        getPayload
    })(webhooks, {
        path,
        log,
        timeout
    });
}
// pkg/dist-src/middleware/web/get-payload.js
function getPayload2(request) {
    return request.text();
}
// pkg/dist-src/middleware/web/get-request-header.js
function getRequestHeader2(request, key) {
    return request.headers.get(key);
}
// pkg/dist-src/middleware/web/handle-response.js
function handleResponse2(body, status = 200, headers = {}) {
    if (body !== null) {
        headers["content-length"] = body.length.toString();
    }
    return new Response(body, {
        status,
        headers
    });
}
// pkg/dist-src/middleware/web/index.js
function createWebMiddleware(webhooks, { path = "/api/github/webhooks", log = createLogger(), timeout = 9e3 } = {}) {
    return createMiddleware({
        handleResponse: handleResponse2,
        getRequestHeader: getRequestHeader2,
        getPayload: getPayload2
    })(webhooks, {
        path,
        log,
        timeout
    });
}
// pkg/dist-src/index.js
var Webhooks = class {
    sign;
    verify;
    on;
    onAny;
    onError;
    removeListener;
    receive;
    verifyAndReceive;
    constructor(options){
        if (!options || !options.secret) {
            throw new Error("[@octokit/webhooks] options.secret required");
        }
        const state = {
            eventHandler: createEventHandler(options),
            secret: options.secret,
            additionalSecrets: options.additionalSecrets,
            hooks: {},
            log: createLogger(options.log)
        };
        this.sign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sign"].bind(null, options.secret);
        this.verify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$2d$methods$40$6$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["verify"].bind(null, options.secret);
        this.on = state.eventHandler.on;
        this.onAny = state.eventHandler.onAny;
        this.onError = state.eventHandler.onError;
        this.removeListener = state.eventHandler.removeListener;
        this.receive = state.eventHandler.receive;
        this.verifyAndReceive = verifyAndReceive.bind(null, state);
    }
};
;
}),
"[project]/node_modules/.pnpm/@octokit+app@16.0.1/node_modules/@octokit/app/dist-node/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/index.js
__turbopack_context__.s([
    "App",
    ()=>App,
    "createNodeMiddleware",
    ()=>createNodeMiddleware
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-app@8.0.1/node_modules/@octokit/auth-app/dist-node/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-app@8.0.1/node_modules/@octokit/oauth-app/dist-node/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+auth-unauthenticated@7.0.1/node_modules/@octokit/auth-unauthenticated/dist-node/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$40$14$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+webhooks@14.0.0/node_modules/@octokit/webhooks/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/each-installation.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$rest$40$13$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-paginate-rest@13.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-rsc] (ecmascript)");
;
;
;
// pkg/dist-src/version.js
var VERSION = "16.0.1";
;
;
;
function webhooks(appOctokit, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$40$14$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Webhooks"]({
        secret: options.secret,
        transform: async (event)=>{
            if (!("installation" in event.payload) || typeof event.payload.installation !== "object") {
                const octokit2 = new appOctokit.constructor({
                    authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$unauthenticated$40$7$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
                    auth: {
                        reason: `"installation" key missing in webhook event payload`
                    }
                });
                return {
                    ...event,
                    octokit: octokit2
                };
            }
            const installationId = event.payload.installation.id;
            const octokit = await appOctokit.auth({
                type: "installation",
                installationId,
                factory (auth) {
                    return new auth.octokit.constructor({
                        ...auth.octokitOptions,
                        authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
                        ...{
                            auth: {
                                ...auth,
                                installationId
                            }
                        }
                    });
                }
            });
            octokit.hook.before("request", (options2)=>{
                options2.headers["x-github-delivery"] = event.id;
            });
            return {
                ...event,
                octokit
            };
        }
    });
}
;
;
async function getInstallationOctokit(app, installationId) {
    return app.octokit.auth({
        type: "installation",
        installationId,
        factory (auth) {
            const options = {
                ...auth.octokitOptions,
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
                ...{
                    auth: {
                        ...auth,
                        installationId
                    }
                }
            };
            return new auth.octokit.constructor(options);
        }
    });
}
// pkg/dist-src/each-installation.js
function eachInstallationFactory(app) {
    return Object.assign(eachInstallation.bind(null, app), {
        iterator: eachInstallationIterator.bind(null, app)
    });
}
async function eachInstallation(app, callback) {
    const i = eachInstallationIterator(app)[Symbol.asyncIterator]();
    let result = await i.next();
    while(!result.done){
        await callback(result.value);
        result = await i.next();
    }
}
function eachInstallationIterator(app) {
    return {
        async *[Symbol.asyncIterator] () {
            const iterator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$rest$40$13$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["composePaginateRest"].iterator(app.octokit, "GET /app/installations");
            for await (const { data: installations } of iterator){
                for (const installation of installations){
                    const installationOctokit = await getInstallationOctokit(app, installation.id);
                    yield {
                        octokit: installationOctokit,
                        installation
                    };
                }
            }
        }
    };
}
;
function eachRepositoryFactory(app) {
    return Object.assign(eachRepository.bind(null, app), {
        iterator: eachRepositoryIterator.bind(null, app)
    });
}
async function eachRepository(app, queryOrCallback, callback) {
    const i = eachRepositoryIterator(app, callback ? queryOrCallback : void 0)[Symbol.asyncIterator]();
    let result = await i.next();
    while(!result.done){
        if (callback) {
            await callback(result.value);
        } else {
            await queryOrCallback(result.value);
        }
        result = await i.next();
    }
}
function singleInstallationIterator(app, installationId) {
    return {
        async *[Symbol.asyncIterator] () {
            yield {
                octokit: await app.getInstallationOctokit(installationId)
            };
        }
    };
}
function eachRepositoryIterator(app, query) {
    return {
        async *[Symbol.asyncIterator] () {
            const iterator = query ? singleInstallationIterator(app, query.installationId) : app.eachInstallation.iterator();
            for await (const { octokit } of iterator){
                const repositoriesIterator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$rest$40$13$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["composePaginateRest"].iterator(octokit, "GET /installation/repositories");
                for await (const { data: repositories } of repositoriesIterator){
                    for (const repository of repositories){
                        yield {
                            octokit,
                            repository
                        };
                    }
                }
            }
        }
    };
}
// pkg/dist-src/get-installation-url.js
function getInstallationUrlFactory(app) {
    let installationUrlBasePromise;
    return async function getInstallationUrl(options = {}) {
        if (!installationUrlBasePromise) {
            installationUrlBasePromise = getInstallationUrlBase(app);
        }
        const installationUrlBase = await installationUrlBasePromise;
        const installationUrl = new URL(installationUrlBase);
        if (options.target_id !== void 0) {
            installationUrl.pathname += "/permissions";
            installationUrl.searchParams.append("target_id", options.target_id.toFixed());
        }
        if (options.state !== void 0) {
            installationUrl.searchParams.append("state", options.state);
        }
        return installationUrl.href;
    };
}
async function getInstallationUrlBase(app) {
    const { data: appInfo } = await app.octokit.request("GET /app");
    if (!appInfo) {
        throw new Error("[@octokit/app] unable to fetch metadata for app");
    }
    return `${appInfo.html_url}/installations/new`;
}
;
;
function noop() {}
function createNodeMiddleware(app, options = {}) {
    const log = Object.assign({
        debug: noop,
        info: noop,
        warn: console.warn.bind(console),
        error: console.error.bind(console)
    }, options.log);
    const optionsWithDefaults = {
        pathPrefix: "/api/github",
        ...options,
        log
    };
    const webhooksMiddleware = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$webhooks$40$14$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createNodeMiddleware"])(app.webhooks, {
        path: optionsWithDefaults.pathPrefix + "/webhooks",
        log
    });
    const oauthMiddleware = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createNodeMiddleware"])(app.oauth, {
        pathPrefix: optionsWithDefaults.pathPrefix + "/oauth"
    });
    return middleware.bind(null, optionsWithDefaults.pathPrefix, webhooksMiddleware, oauthMiddleware);
}
async function middleware(pathPrefix, webhooksMiddleware, oauthMiddleware, request, response, next) {
    const { pathname } = new URL(request.url, "http://localhost");
    if (pathname.startsWith(`${pathPrefix}/`)) {
        if (pathname === `${pathPrefix}/webhooks`) {
            webhooksMiddleware(request, response);
        } else if (pathname.startsWith(`${pathPrefix}/oauth/`)) {
            oauthMiddleware(request, response);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendNodeResponse"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["unknownRouteResponse"])(request), response);
        }
        return true;
    } else {
        next?.();
        return false;
    }
}
// pkg/dist-src/index.js
var App = class {
    static VERSION = VERSION;
    static defaults(defaults) {
        const AppWithDefaults = class extends this {
            constructor(...args){
                super({
                    ...defaults,
                    ...args[0]
                });
            }
        };
        return AppWithDefaults;
    }
    octokit;
    // @ts-ignore calling app.webhooks will throw a helpful error when options.webhooks is not set
    webhooks;
    // @ts-ignore calling app.oauth will throw a helpful error when options.oauth is not set
    oauth;
    getInstallationOctokit;
    eachInstallation;
    eachRepository;
    getInstallationUrl;
    log;
    constructor(options){
        const Octokit = options.Octokit || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Octokit"];
        const authOptions = Object.assign({
            appId: options.appId,
            privateKey: options.privateKey
        }, options.oauth ? {
            clientId: options.oauth.clientId,
            clientSecret: options.oauth.clientSecret
        } : {});
        const octokitOptions = {
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$auth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
            auth: authOptions
        };
        if ("log" in options && typeof options.log !== "undefined") {
            octokitOptions.log = options.log;
        }
        this.octokit = new Octokit(octokitOptions);
        this.log = Object.assign({
            debug: ()=>{},
            info: ()=>{},
            warn: console.warn.bind(console),
            error: console.error.bind(console)
        }, options.log);
        if (options.webhooks) {
            this.webhooks = webhooks(this.octokit, options.webhooks);
        } else {
            Object.defineProperty(this, "webhooks", {
                get () {
                    throw new Error("[@octokit/app] webhooks option not set");
                }
            });
        }
        if (options.oauth) {
            this.oauth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuthApp"]({
                ...options.oauth,
                clientType: "github-app",
                Octokit
            });
        } else {
            Object.defineProperty(this, "oauth", {
                get () {
                    throw new Error("[@octokit/app] oauth.clientId / oauth.clientSecret options are not set");
                }
            });
        }
        this.getInstallationOctokit = getInstallationOctokit.bind(null, this);
        this.eachInstallation = eachInstallationFactory(this);
        this.eachRepository = eachRepositoryFactory(this);
        this.getInstallationUrl = getInstallationUrlFactory(this);
    }
};
;
}),
"[project]/node_modules/.pnpm/octokit@5.0.3/node_modules/octokit/dist-bundle/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// pkg/dist-src/octokit.js
__turbopack_context__.s([
    "App",
    ()=>App,
    "OAuthApp",
    ()=>OAuthApp,
    "Octokit",
    ()=>Octokit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+core@7.0.2/node_modules/@octokit/core/dist-src/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$rest$40$13$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-paginate-rest@13.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$graphql$40$6$2e$0$2e$0_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-paginate-graphql@6.0.0_@octokit+core@7.0.2/node_modules/@octokit/plugin-paginate-graphql/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$rest$2d$endpoint$2d$methods$40$16$2e$0$2e$0_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@16.0.0_@octokit+core@7.0.2/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$retry$40$8$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$retry$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-retry@8.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-retry/dist-bundle/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$throttling$40$11$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$throttling$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+plugin-throttling@11.0.1_@octokit+core@7.0.2/node_modules/@octokit/plugin-throttling/dist-bundle/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/octokit.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$request$2d$error$40$7$2e$0$2e$0$2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+request-error@7.0.0/node_modules/@octokit/request-error/dist-src/index.js [app-rsc] (ecmascript)");
// pkg/dist-src/app.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$app$40$16$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+app@16.0.1/node_modules/@octokit/app/dist-node/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@octokit+oauth-app@8.0.1/node_modules/@octokit/oauth-app/dist-node/index.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
var Octokit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Octokit"].plugin(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$rest$2d$endpoint$2d$methods$40$16$2e$0$2e$0_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["restEndpointMethods"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$rest$40$13$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["paginateRest"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$paginate$2d$graphql$40$6$2e$0$2e$0_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["paginateGraphQL"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$retry$40$8$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$retry$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["retry"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$plugin$2d$throttling$40$11$2e$0$2e$1_$40$octokit$2b$core$40$7$2e$0$2e$2$2f$node_modules$2f40$octokit$2f$plugin$2d$throttling$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["throttling"]).defaults({
    userAgent: `octokit.js/${VERSION}`,
    throttle: {
        onRateLimit,
        onSecondaryRateLimit
    }
});
function onRateLimit(retryAfter, options, octokit) {
    octokit.log.warn(`Request quota exhausted for request ${options.method} ${options.url}`);
    if (options.request.retryCount === 0) {
        octokit.log.info(`Retrying after ${retryAfter} seconds!`);
        return true;
    }
}
function onSecondaryRateLimit(retryAfter, options, octokit) {
    octokit.log.warn(`SecondaryRateLimit detected for request ${options.method} ${options.url}`);
    if (options.request.retryCount === 0) {
        octokit.log.info(`Retrying after ${retryAfter} seconds!`);
        return true;
    }
}
;
;
;
var App = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$app$40$16$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["App"].defaults({
    Octokit
});
var OAuthApp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$octokit$2b$oauth$2d$app$40$8$2e$0$2e$1$2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["OAuthApp"].defaults({
    Octokit
});
;
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyXMLAttributes",
    ()=>applyXMLAttributes,
    "ensureMinLength",
    ()=>ensureMinLength,
    "getResultForCircular",
    ()=>getResultForCircular,
    "getXMLAttributes",
    ()=>getXMLAttributes,
    "mergeDeep",
    ()=>mergeDeep,
    "popSchemaStack",
    ()=>popSchemaStack,
    "toRFCDateTime",
    ()=>toRFCDateTime,
    "uuid",
    ()=>uuid
]);
'use strict';
function pad(number) {
    if (number < 10) {
        return '0' + number;
    }
    return number;
}
function toRFCDateTime(date, omitTime, omitDate, milliseconds) {
    var res = omitDate ? '' : date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate());
    if (!omitTime) {
        res += 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + (milliseconds ? '.' + (date.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) : '') + 'Z';
    }
    return res;
}
;
function ensureMinLength(sample, min) {
    if (min > sample.length) {
        return sample.repeat(Math.trunc(min / sample.length) + 1).substring(0, min);
    }
    return sample;
}
function mergeDeep(...objects) {
    const isObject = (obj)=>obj && typeof obj === 'object';
    return objects.reduce((prev, obj)=>{
        Object.keys(obj || {}).forEach((key)=>{
            const pVal = prev[key];
            const oVal = obj[key];
            if (isObject(pVal) && isObject(oVal)) {
                prev[key] = mergeDeep(pVal, oVal);
            } else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, Array.isArray(objects[objects.length - 1]) ? [] : {});
}
function uuid(str) {
    var hash = hashCode(str);
    var random = jsf32(hash, hash, hash, hash);
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
        var r = random() * 16 % 16 | 0;
        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
    return uuid;
}
function getResultForCircular(type) {
    return {
        value: type === 'object' ? {} : type === 'array' ? [] : undefined
    };
}
function popSchemaStack(seenSchemasStack, context) {
    if (context) seenSchemasStack.pop();
}
function getXMLAttributes(schema) {
    return {
        name: schema?.xml?.name || '',
        prefix: schema?.xml?.prefix || '',
        namespace: schema?.xml?.namespace || null,
        attribute: schema?.xml?.attribute ?? false,
        wrapped: schema?.xml?.wrapped ?? false
    };
}
function applyXMLAttributes(result, schema = {}, context = {}) {
    const { value: oldValue } = result;
    const { propertyName: oldPropertyName } = context;
    const { name, prefix, namespace, attribute, wrapped } = getXMLAttributes(schema);
    let propertyName = name || oldPropertyName ? `${prefix ? prefix + ':' : ''}${name || oldPropertyName}` : null;
    let value = typeof oldValue === 'object' ? Array.isArray(oldValue) ? [
        ...oldValue
    ] : {
        ...oldValue
    } : oldValue;
    if (attribute && propertyName) {
        propertyName = `$${propertyName}`;
    }
    if (namespace) {
        if (typeof value === 'object') {
            value[`$xmlns${prefix ? ':' + prefix : ''}`] = namespace;
        } else {
            value = {
                [`$xmlns${prefix ? ':' + prefix : ''}`]: namespace,
                ['#text']: value
            };
        }
    }
    if (schema.type === 'array') {
        if (wrapped && Array.isArray(value)) {
            value = {
                [propertyName]: [
                    ...value
                ]
            };
        }
        if (!wrapped) {
            propertyName = null;
        }
        if (schema.example !== undefined && !wrapped) {
            propertyName = schema.items?.xml?.name || propertyName;
        }
    }
    if (schema.oneOf || schema.anyOf || schema.allOf || schema.$ref) {
        propertyName = null;
    }
    return {
        propertyName,
        value
    };
}
function hashCode(str) {
    var hash = 0;
    if (str.length == 0) return hash;
    for(var i = 0; i < str.length; i++){
        var char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
    }
    return hash;
}
function jsf32(a, b, c, d) {
    return function() {
        a |= 0;
        b |= 0;
        c |= 0;
        d |= 0;
        var t = a - (b << 27 | b >>> 5) | 0;
        a = b ^ (c << 17 | c >>> 15);
        b = c + d | 0;
        c = d + t | 0;
        d = a + t | 0;
        return (d >>> 0) / 4294967296;
    };
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/allOf.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "allOfSample",
    ()=>allOfSample
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/traverse.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)");
;
;
function allOfSample(into, children, options, spec, context) {
    let res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(into, options, spec);
    const subSamples = [];
    for (let subSchema of children){
        const { type, readOnly, writeOnly, value } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])({
            type: res.type,
            ...subSchema
        }, options, spec, context);
        if (res.type && type && type !== res.type) {
            console.warn('allOf: schemas with different types can\'t be merged');
            res.type = type;
        }
        res.type = res.type || type;
        res.readOnly = res.readOnly || readOnly;
        res.writeOnly = res.writeOnly || writeOnly;
        if (value != null) subSamples.push(value);
    }
    if (res.type === 'object') {
        res.value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mergeDeep"])(res.value || {}, ...subSamples.filter((sample)=>typeof sample === 'object'));
        return res;
    } else {
        if (res.type === 'array') {
            // TODO: implement arrays
            if (!options.quiet) console.warn('OpenAPI Sampler: found allOf with "array" type. Result may be incorrect');
        }
        const lastSample = subSamples[subSamples.length - 1];
        res.value = lastSample != null ? lastSample : res.value;
        return res;
    }
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/infer.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "inferType",
    ()=>inferType
]);
const schemaKeywordTypes = {
    multipleOf: 'number',
    maximum: 'number',
    exclusiveMaximum: 'number',
    minimum: 'number',
    exclusiveMinimum: 'number',
    maxLength: 'string',
    minLength: 'string',
    pattern: 'string',
    items: 'array',
    maxItems: 'array',
    minItems: 'array',
    uniqueItems: 'array',
    additionalItems: 'array',
    maxProperties: 'object',
    minProperties: 'object',
    required: 'object',
    additionalProperties: 'object',
    properties: 'object',
    patternProperties: 'object',
    dependencies: 'object'
};
function inferType(schema) {
    if (schema.type !== undefined) {
        return Array.isArray(schema.type) ? schema.type.length === 0 ? null : schema.type[0] : schema.type;
    }
    const keywords = Object.keys(schemaKeywordTypes);
    for(var i = 0; i < keywords.length; i++){
        let keyword = keywords[i];
        let type = schemaKeywordTypes[keyword];
        if (schema[keyword] !== undefined) {
            return type;
        }
    }
    return null;
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/traverse.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clearCache",
    ()=>clearCache,
    "traverse",
    ()=>traverse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$openapi$2d$sampler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/openapi-sampler.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$allOf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/allOf.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/infer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$pointer$40$0$2e$6$2e$2$2f$node_modules$2f$json$2d$pointer$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/json-pointer@0.6.2/node_modules/json-pointer/index.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
let $refCache = {};
// for circular JS references we use additional array and not object as we need to compare entire schemas and not strings
let seenSchemasStack = [];
function clearCache() {
    $refCache = {};
    seenSchemasStack = [];
}
function inferExample(schema) {
    let example;
    if (schema.const !== undefined) {
        example = schema.const;
    } else if (schema.examples !== undefined && schema.examples.length) {
        example = schema.examples[0];
    } else if (schema.enum !== undefined && schema.enum.length) {
        example = schema.enum[0];
    } else if (schema.default !== undefined) {
        example = schema.default;
    }
    return example;
}
function tryInferExample(schema) {
    const example = inferExample(schema);
    // case when we don't infer example from schema but take from `const`, `examples`, `default` or `enum` keywords
    if (example !== undefined) {
        return {
            value: example,
            readOnly: schema.readOnly,
            writeOnly: schema.writeOnly,
            type: null
        };
    }
    return;
}
function traverse(schema, options, spec, context) {
    // checking circular JS references by checking context
    // because context is passed only when traversing through nested objects happens
    if (context) {
        if (seenSchemasStack.includes(schema)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getResultForCircular"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["inferType"])(schema));
        seenSchemasStack.push(schema);
    }
    if (context && context.depth > options.maxSampleDepth) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getResultForCircular"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["inferType"])(schema));
    }
    if (schema.$ref) {
        if (!spec) {
            throw new Error('Your schema contains $ref. You must provide full specification in the third parameter.');
        }
        let ref = decodeURIComponent(schema.$ref);
        if (ref.startsWith('#')) {
            ref = ref.substring(1);
        }
        const referenced = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$json$2d$pointer$40$0$2e$6$2e$2$2f$node_modules$2f$json$2d$pointer$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].get(spec, ref);
        let result;
        if ($refCache[ref] !== true) {
            $refCache[ref] = true;
            const traverseResult = traverse(referenced, options, spec, context);
            if (options.format === 'xml') {
                const { propertyName, value } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["applyXMLAttributes"])(traverseResult, referenced, context);
                result = {
                    ...traverseResult,
                    value: {
                        [propertyName || 'root']: value
                    }
                };
            } else {
                result = traverseResult;
            }
            $refCache[ref] = false;
        } else {
            const referencedType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["inferType"])(referenced);
            result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getResultForCircular"])(referencedType);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        return result;
    }
    if (schema.example !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        return {
            value: schema.example,
            readOnly: schema.readOnly,
            writeOnly: schema.writeOnly,
            type: schema.type
        };
    }
    if (schema.allOf !== undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        return tryInferExample(schema) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$allOf$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["allOfSample"])({
            ...schema,
            allOf: undefined
        }, schema.allOf, options, spec, context);
    }
    if (schema.oneOf && schema.oneOf.length) {
        if (schema.anyOf) {
            if (!options.quiet) console.warn('oneOf and anyOf are not supported on the same level. Skipping anyOf');
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        // Make sure to pass down readOnly and writeOnly annotations from the parent
        const firstOneOf = Object.assign({
            readOnly: schema.readOnly,
            writeOnly: schema.writeOnly
        }, schema.oneOf[0]);
        return traverseOneOrAnyOf(schema, firstOneOf);
    }
    if (schema.anyOf && schema.anyOf.length) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        // Make sure to pass down readOnly and writeOnly annotations from the parent
        const firstAnyOf = Object.assign({
            readOnly: schema.readOnly,
            writeOnly: schema.writeOnly
        }, schema.anyOf[0]);
        return traverseOneOrAnyOf(schema, firstAnyOf);
    }
    if (schema.if && schema.then) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
        const { if: ifSchema, then, ...rest } = schema;
        return traverse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mergeDeep"])(rest, ifSchema, then), options, spec, context);
    }
    let example = inferExample(schema);
    let type = null;
    if (example === undefined) {
        example = null;
        type = schema.type;
        if (Array.isArray(type) && schema.type.length > 0) {
            type = schema.type[0];
        }
        if (!type) {
            type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["inferType"])(schema);
        }
        let sampler = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$openapi$2d$sampler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["_samplers"][type];
        if (sampler) {
            example = sampler(schema, options, spec, context);
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["popSchemaStack"])(seenSchemasStack, context);
    return {
        value: example,
        readOnly: schema.readOnly,
        writeOnly: schema.writeOnly,
        type: type
    };
    //TURBOPACK unreachable
    ;
    function traverseOneOrAnyOf(schema, selectedSubSchema) {
        const inferred = tryInferExample(schema);
        if (inferred !== undefined) {
            return inferred;
        }
        const localExample = traverse({
            ...schema,
            oneOf: undefined,
            anyOf: undefined
        }, options, spec, context);
        const subSchemaExample = traverse(selectedSubSchema, options, spec, context);
        if (typeof localExample.value === 'object' && typeof subSchemaExample.value === 'object') {
            const mergedExample = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["mergeDeep"])(localExample.value, subSchemaExample.value);
            return {
                ...subSchemaExample,
                value: mergedExample
            };
        }
        return subSchemaExample;
    }
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/array.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sampleArray",
    ()=>sampleArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/traverse.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)");
;
;
function sampleArray(schema, options = {}, spec, context) {
    const depth = context && context.depth || 1;
    let arrayLength = Math.min(schema.maxItems != undefined ? schema.maxItems : Infinity, schema.minItems || 1);
    // for the sake of simplicity, we're treating `contains` in a similar way to `items`
    const items = schema.prefixItems || schema.items || schema.contains;
    if (Array.isArray(items)) {
        arrayLength = Math.max(arrayLength, items.length);
    }
    let itemSchemaGetter = (itemNumber)=>{
        if (Array.isArray(items)) {
            return items[itemNumber] || {};
        }
        return items || {};
    };
    let res = [];
    if (!items) return res;
    for(let i = 0; i < arrayLength; i++){
        let itemSchema = itemSchemaGetter(i);
        let { value: sample } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(itemSchema, options, spec, {
            depth: depth + 1
        });
        if (options?.format === 'xml') {
            const { value, propertyName } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["applyXMLAttributes"])({
                value: sample
            }, itemSchema, context);
            if (propertyName) {
                if (!res?.[propertyName]) {
                    res = {
                        ...res,
                        [propertyName]: []
                    };
                }
                res[propertyName].push(value);
            } else {
                res = {
                    ...res,
                    ...value
                };
            }
        } else {
            res.push(sample);
        }
    }
    if (options?.format === 'xml' && depth === 1) {
        const { value, propertyName } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["applyXMLAttributes"])({
            value: null
        }, schema, context);
        if (propertyName) {
            if (value) {
                res = Array.isArray(res) ? {
                    [propertyName]: {
                        ...value,
                        ...res.map((item)=>({
                                ['#text']: {
                                    ...item
                                }
                            }))
                    }
                } : {
                    [propertyName]: {
                        ...res,
                        ...value
                    }
                };
            } else {
                res = {
                    [propertyName]: res
                };
            }
        }
    }
    return res;
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/boolean.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sampleBoolean",
    ()=>sampleBoolean
]);
function sampleBoolean(schema) {
    return true; // let be optimistic :)
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/number.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sampleNumber",
    ()=>sampleNumber
]);
function sampleNumber(schema) {
    let res = 0;
    if (schema.type === 'number' && (schema.format === 'float' || schema.format === 'double')) {
        res = 0.1;
    }
    if (typeof schema.exclusiveMinimum === 'boolean' || typeof schema.exclusiveMaximum === 'boolean') {
        if (schema.maximum && schema.minimum) {
            res = schema.exclusiveMinimum ? Math.floor(schema.minimum) + 1 : schema.minimum;
            if (schema.exclusiveMaximum && res >= schema.maximum || !schema.exclusiveMaximum && res > schema.maximum) {
                res = (schema.maximum + schema.minimum) / 2;
            }
            return res;
        }
        if (schema.minimum) {
            if (schema.exclusiveMinimum) {
                return Math.floor(schema.minimum) + 1;
            } else {
                return schema.minimum;
            }
        }
        if (schema.maximum) {
            if (schema.exclusiveMaximum) {
                return schema.maximum > 0 ? 0 : Math.floor(schema.maximum) - 1;
            } else {
                return schema.maximum > 0 ? 0 : schema.maximum;
            }
        }
    } else {
        if (schema.minimum) {
            return schema.minimum;
        }
        if (schema.exclusiveMinimum) {
            res = Math.floor(schema.exclusiveMinimum) + 1;
            if (res === schema.exclusiveMaximum) {
                res = (res + Math.floor(schema.exclusiveMaximum) - 1) / 2;
            }
        } else if (schema.exclusiveMaximum) {
            res = Math.floor(schema.exclusiveMaximum) - 1;
        } else if (schema.maximum) {
            res = schema.maximum;
        }
    }
    return res;
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/object.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sampleObject",
    ()=>sampleObject
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/traverse.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)");
;
;
function sampleObject(schema, options = {}, spec, context) {
    let res = {};
    const depth = context && context.depth || 1;
    if (schema && typeof schema.properties === 'object') {
        // Prepare for skipNonRequired option
        const requiredProperties = Array.isArray(schema.required) ? schema.required : [];
        const requiredPropertiesMap = {};
        for (const requiredProperty of requiredProperties){
            requiredPropertiesMap[requiredProperty] = true;
        }
        Object.keys(schema.properties).forEach((propertyName)=>{
            // skip before traverse that could be costly
            if (options.skipNonRequired && !requiredPropertiesMap.hasOwnProperty(propertyName)) {
                return;
            }
            const sample = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(schema.properties[propertyName], options, spec, {
                propertyName,
                depth: depth + 1
            });
            if (options.skipReadOnly && sample.readOnly) {
                return;
            }
            if (options.skipWriteOnly && sample.writeOnly) {
                return;
            }
            if (options?.format === 'xml') {
                const { propertyName: newPropertyName, value } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["applyXMLAttributes"])(sample, schema.properties[propertyName], {
                    propertyName
                });
                if (newPropertyName) {
                    res[newPropertyName] = value;
                } else {
                    res = {
                        ...res,
                        ...value
                    };
                }
            } else {
                res[propertyName] = sample.value;
            }
        });
    }
    if (schema && typeof schema.additionalProperties === 'object') {
        const propertyName = schema.additionalProperties['x-additionalPropertiesName'] || 'property';
        res[`${String(propertyName)}1`] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(schema.additionalProperties, options, spec, {
            depth: depth + 1
        }).value;
        res[`${String(propertyName)}2`] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(schema.additionalProperties, options, spec, {
            depth: depth + 1
        }).value;
    }
    // Strictly enforce maxProperties constraint
    if (schema && typeof schema.properties === 'object' && schema.maxProperties !== undefined && Object.keys(res).length > schema.maxProperties) {
        const filteredResult = {};
        let propertiesAdded = 0;
        // Always include required properties first, if present
        const requiredProperties = Array.isArray(schema.required) ? schema.required : [];
        requiredProperties.forEach((propName)=>{
            if (res[propName] !== undefined) {
                filteredResult[propName] = res[propName];
                propertiesAdded++;
            }
        });
        // Add other properties until maxProperties is reached
        Object.keys(res).forEach((propName)=>{
            if (propertiesAdded < schema.maxProperties && !filteredResult.hasOwnProperty(propName)) {
                filteredResult[propName] = res[propName];
                propertiesAdded++;
            }
        });
        res = filteredResult;
    }
    return res;
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/string-regex.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
Faker - Copyright (c) 2022-2023

This software consists of voluntary contributions made by many individuals.
For exact contribution history, see the revision history
available at https://github.com/faker-js/faker

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

===

From: https://github.com/faker-js/faker/commit/a9f98046c7d5eeaabe12fc587024c06d683800b8
To: https://github.com/faker-js/faker/commit/29234378807c4141588861f69421bf20b5ac635e

Based on faker.js, copyright Marak Squires and contributor, what follows below is the original license.

===

faker.js - Copyright (c) 2020
Marak Squires
http://github.com/marak/faker.js/

faker.js was inspired by and has used data definitions from:

 * https://github.com/stympy/faker/ - Copyright (c) 2007-2010 Benjamin Curtis
 * http://search.cpan.org/~jasonk/Data-Faker-0.07/ - Copyright 2004-2005 by Jason Kohles

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ /** @returns {boolean} */ __turbopack_context__.s([
    "regexSample",
    ()=>regexSample
]);
function boolSample() {
    return true;
}
/**
 * @param {number} min - inclusive
 * @param {number} _max - inclusive
 * @returns {number}
 */ function intSample(min, _max) {
    return min;
}
/**
 * Returns a number based on given RegEx-based quantifier symbol or quantifier values.
 *
 * @param {string} quantifierSymbol Quantifier symbols can be either of these: `?`, `*`, `+`.
 * @param {string} quantifierMin Quantifier minimum value. If given without a maximum, this will be used as the quantifier value.
 * @param {string} quantifierMax Quantifier maximum value. Will randomly get a value between the minimum and maximum if both are provided.
 *
 * @returns {number} a random number based on the given quantifier parameters.
 *
 * @example
 * getRepetitionsBasedOnQuantifierParameters('*', null, null) // 3
 * getRepetitionsBasedOnQuantifierParameters(null, 10, null) // 10
 * getRepetitionsBasedOnQuantifierParameters(null, 5, 8) // 6
 *
 * @since 8.0.0
 */ function getRepetitionsBasedOnQuantifierParameters(quantifierSymbol, quantifierMin, quantifierMax) {
    let repetitions = 1;
    if (quantifierSymbol) {
        switch(quantifierSymbol){
            case '?':
                {
                    repetitions = boolSample() ? 0 : "TURBOPACK unreachable";
                    break;
                }
            case '*':
                {
                    const limit = 8;
                    repetitions = intSample(0, limit);
                    break;
                }
            case '+':
                {
                    const limit = 8;
                    repetitions = intSample(1, limit);
                    break;
                }
            default:
                throw new Error('Unknown quantifier symbol provided.');
        }
    } else if (quantifierMin != null && quantifierMax != null) {
        repetitions = intSample(parseInt(quantifierMin), parseInt(quantifierMax));
    } else if (quantifierMin != null && quantifierMax == null) {
        repetitions = parseInt(quantifierMin);
    }
    return repetitions;
}
function regexSample(pattern) {
    let isCaseInsensitive = false;
    if (pattern instanceof RegExp) {
        isCaseInsensitive = pattern.flags.includes('i');
        pattern = pattern.toString();
        pattern = pattern.match(/\/(.+?)\//)?.[1] ?? ''; // Remove frontslash from front and back of RegExp
    }
    let min;
    let max;
    let repetitions;
    // Deal with single wildcards
    const SINGLE_CHAR_REG = /([.A-Za-z0-9])(?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+))(?![^[]*]|[^{]*})/;
    let token = pattern.match(SINGLE_CHAR_REG);
    while(token != null){
        const quantifierMin = token[2];
        const quantifierMax = token[3];
        const quantifierSymbol = token[4];
        repetitions = getRepetitionsBasedOnQuantifierParameters(quantifierSymbol, quantifierMin, quantifierMax);
        pattern = pattern.slice(0, token.index) + token[1].repeat(repetitions) + pattern.slice(token.index + token[0].length);
        token = pattern.match(SINGLE_CHAR_REG);
    }
    const SINGLE_RANGE_REG = /(\d-\d|\w-\w|\d|\w|[-!@#$&()`.+,/"])/;
    const RANGE_ALPHANUMEMRIC_REG = /\[(\^|)(-|)(.+?)\](?:\{(\d+)(?:\,(\d+)|)\}|(\?|\*|\+)|)/;
    // Deal with character classes with quantifiers `[a-z0-9]{min[, max]}`
    token = pattern.match(RANGE_ALPHANUMEMRIC_REG);
    while(token != null){
        const isNegated = token[1] === '^';
        const includesDash = token[2] === '-';
        const quantifierMin = token[4];
        const quantifierMax = token[5];
        const quantifierSymbol = token[6];
        const rangeCodes = [];
        let ranges = token[3];
        let range = ranges.match(SINGLE_RANGE_REG);
        if (includesDash) {
            // 45 is the ascii code for '-'
            rangeCodes.push(45);
        }
        while(range != null){
            if (range[0].indexOf('-') === -1) {
                // handle non-ranges
                if (isCaseInsensitive && isNaN(Number(range[0]))) {
                    rangeCodes.push(range[0].toUpperCase().charCodeAt(0));
                    rangeCodes.push(range[0].toLowerCase().charCodeAt(0));
                } else {
                    rangeCodes.push(range[0].charCodeAt(0));
                }
            } else {
                // handle ranges
                const rangeMinMax = range[0].split('-').map((x)=>x.charCodeAt(0));
                min = rangeMinMax[0];
                max = rangeMinMax[1];
                // throw error if min larger than max
                if (min > max) {
                    throw new Error('Character range provided is out of order.');
                }
                for(let i = min; i <= max; i++){
                    if (isCaseInsensitive && isNaN(Number(String.fromCharCode(i)))) {
                        const ch = String.fromCharCode(i);
                        rangeCodes.push(ch.toUpperCase().charCodeAt(0));
                        rangeCodes.push(ch.toLowerCase().charCodeAt(0));
                    } else {
                        rangeCodes.push(i);
                    }
                }
            }
            ranges = ranges.substring(range[0].length);
            range = ranges.match(SINGLE_RANGE_REG);
        }
        repetitions = getRepetitionsBasedOnQuantifierParameters(quantifierSymbol, quantifierMin, quantifierMax);
        if (isNegated) {
            let index = -1;
            // 0-9
            for(let i = 48; i <= 57; i++){
                index = rangeCodes.indexOf(i);
                if (index > -1) {
                    rangeCodes.splice(index, 1);
                    continue;
                }
                rangeCodes.push(i);
            }
            // A-Z
            for(let i = 65; i <= 90; i++){
                index = rangeCodes.indexOf(i);
                if (index > -1) {
                    rangeCodes.splice(index, 1);
                    continue;
                }
                rangeCodes.push(i);
            }
            // a-z
            for(let i = 97; i <= 122; i++){
                index = rangeCodes.indexOf(i);
                if (index > -1) {
                    rangeCodes.splice(index, 1);
                    continue;
                }
                rangeCodes.push(i);
            }
        }
        const generatedString = Array.from({
            length: repetitions
        }, ()=>String.fromCharCode(rangeCodes[intSample(0, rangeCodes.length - 1)])).join('');
        pattern = pattern.slice(0, token.index) + generatedString + pattern.slice(token.index + token[0].length);
        token = pattern.match(RANGE_ALPHANUMEMRIC_REG);
    }
    const RANGE_REP_REG = /(.)\{(\d+)\,(\d+)\}/;
    // Deal with quantifier ranges `{min,max}`
    token = pattern.match(RANGE_REP_REG);
    while(token != null){
        min = parseInt(token[2]);
        max = parseInt(token[3]);
        // throw error if min larger than max
        if (min > max) {
            throw new Error('Numbers out of order in {} quantifier.');
        }
        repetitions = intSample(min, max);
        pattern = pattern.slice(0, token.index) + token[1].repeat(repetitions) + pattern.slice(token.index + token[0].length);
        token = pattern.match(RANGE_REP_REG);
    }
    const REP_REG = /(.)\{(\d+)\}/;
    // Deal with repeat `{num}`
    token = pattern.match(REP_REG);
    while(token != null){
        repetitions = parseInt(token[2]);
        pattern = pattern.slice(0, token.index) + token[1].repeat(repetitions) + pattern.slice(token.index + token[0].length);
        token = pattern.match(REP_REG);
    }
    return pattern;
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/string.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sampleString",
    ()=>sampleString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$string$2d$regex$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/string-regex.js [app-rsc] (ecmascript)");
'use strict';
;
;
const passwordSymbols = 'qwerty!@#$%^123456';
function emailSample() {
    return 'user@example.com';
}
function idnEmailSample() {
    return 'пошта@укр.нет';
}
function passwordSample(min, max) {
    let res = 'pa$$word';
    if (min > res.length) {
        res += '_';
        res += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ensureMinLength"])(passwordSymbols, min - res.length).substring(0, min - res.length);
    }
    return res;
}
function commonDateTimeSample({ min, max, omitTime, omitDate }) {
    let res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toRFCDateTime"])(new Date('2019-08-24T14:15:22.123Z'), omitTime, omitDate, false);
    if (res.length < min) {
        console.warn(`Using minLength = ${min} is incorrect with format "date-time"`);
    }
    if (max && res.length > max) {
        console.warn(`Using maxLength = ${max} is incorrect with format "date-time"`);
    }
    return res;
}
function dateTimeSample(min, max) {
    return commonDateTimeSample({
        min,
        max,
        omitTime: false,
        omitDate: false
    });
}
function dateSample(min, max) {
    return commonDateTimeSample({
        min,
        max,
        omitTime: true,
        omitDate: false
    });
}
function timeSample(min, max) {
    return commonDateTimeSample({
        min,
        max,
        omitTime: false,
        omitDate: true
    }).slice(1);
}
function defaultSample(min, max, _propertyName, pattern, enablePatterns = false) {
    if (pattern && enablePatterns) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$string$2d$regex$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["regexSample"](pattern);
    }
    let res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ensureMinLength"])('string', min);
    if (max && res.length > max) {
        res = res.substring(0, max);
    }
    return res;
}
function ipv4Sample() {
    return '192.168.0.1';
}
function ipv6Sample() {
    return '2001:0db8:85a3:0000:0000:8a2e:0370:7334';
}
function hostnameSample() {
    return 'example.com';
}
function idnHostnameSample() {
    return 'приклад.укр';
}
function uriSample() {
    return 'http://example.com';
}
function uriReferenceSample() {
    return '../dictionary';
}
function uriTemplateSample() {
    return 'http://example.com/{endpoint}';
}
function iriSample() {
    return 'http://example.com/entity/1';
}
function iriReferenceSample() {
    return '/entity/1';
}
function uuidSample(_min, _max, propertyName) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["uuid"])(propertyName || 'id');
}
function jsonPointerSample() {
    return '/json/pointer';
}
function relativeJsonPointerSample() {
    return '1/relative/json/pointer';
}
function regexSample() {
    return '/regex/';
}
const stringFormats = {
    'email': emailSample,
    'idn-email': idnEmailSample,
    'password': passwordSample,
    'date-time': dateTimeSample,
    'date': dateSample,
    'time': timeSample,
    'ipv4': ipv4Sample,
    'ipv6': ipv6Sample,
    'hostname': hostnameSample,
    'idn-hostname': idnHostnameSample,
    'iri': iriSample,
    'iri-reference': iriReferenceSample,
    'uri': uriSample,
    'uri-reference': uriReferenceSample,
    'uri-template': uriTemplateSample,
    'uuid': uuidSample,
    'default': defaultSample,
    'json-pointer': jsonPointerSample,
    'relative-json-pointer': relativeJsonPointerSample,
    'regex': regexSample
};
function sampleString(schema, options, spec, context) {
    let format = schema.format || 'default';
    let sampler = stringFormats[format] || defaultSample;
    let propertyName = context && context.propertyName;
    return sampler(schema.minLength || 0, schema.maxLength, propertyName, schema.pattern, options?.enablePatterns);
}
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/array.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$boolean$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/boolean.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/object.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$string$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/string.js [app-rsc] (ecmascript)");
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/openapi-sampler.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_registerSampler",
    ()=>_registerSampler,
    "_samplers",
    ()=>_samplers,
    "sample",
    ()=>sample
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/traverse.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/array.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$boolean$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/boolean.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/number.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/object.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$string$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/samplers/string.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fast$2d$xml$2d$parser$40$4$2e$5$2e$3$2f$node_modules$2f$fast$2d$xml$2d$parser$2f$src$2f$fxp$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/fxp.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$infer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/openapi-sampler@1.6.1/node_modules/openapi-sampler/src/infer.js [app-rsc] (ecmascript)");
;
;
;
var _samplers = {};
const defaults = {
    skipReadOnly: false,
    maxSampleDepth: 15
};
function convertJsonToXml(obj, schema) {
    if (!obj) {
        throw new Error('Unknown format output for building XML.');
    }
    if (Array.isArray(obj) || Object.keys(obj).length > 1) {
        obj = {
            [schema?.xml?.name || 'root']: obj
        }; // XML document must contain one root element
    }
    const builder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$fast$2d$xml$2d$parser$40$4$2e$5$2e$3$2f$node_modules$2f$fast$2d$xml$2d$parser$2f$src$2f$fxp$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["XMLBuilder"]({
        ignoreAttributes: false,
        format: true,
        attributeNamePrefix: '$',
        textNodeName: '#text'
    });
    return builder.build(obj);
}
function sample(schema, options, spec) {
    let opts = Object.assign({}, defaults, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["clearCache"])();
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$traverse$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["traverse"])(schema, opts, spec).value;
    if (opts?.format === 'xml') {
        return convertJsonToXml(result, schema);
    }
    return result;
}
;
function _registerSampler(type, sampler) {
    _samplers[type] = sampler;
}
;
;
_registerSampler('array', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$array$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleArray"]);
_registerSampler('boolean', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$boolean$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleBoolean"]);
_registerSampler('integer', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleNumber"]);
_registerSampler('number', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$number$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleNumber"]);
_registerSampler('object', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$object$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleObject"]);
_registerSampler('string', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$openapi$2d$sampler$40$1$2e$6$2e$1$2f$node_modules$2f$openapi$2d$sampler$2f$src$2f$samplers$2f$string$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sampleString"]);
}),
"[project]/node_modules/.pnpm/foreach@2.0.6/node_modules/foreach/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
module.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for(var i = 0; i < l; i++){
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for(var k in obj){
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};
}),
"[project]/node_modules/.pnpm/json-pointer@0.6.2/node_modules/json-pointer/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var each = __turbopack_context__.r("[project]/node_modules/.pnpm/foreach@2.0.6/node_modules/foreach/index.js [app-rsc] (ecmascript)");
module.exports = api;
/**
 * Convenience wrapper around the api.
 * Calls `.get` when called with an `object` and a `pointer`.
 * Calls `.set` when also called with `value`.
 * If only supplied `object`, returns a partially applied function, mapped to the object.
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 * @returns {*}
 */ function api(obj, pointer, value) {
    // .set()
    if (arguments.length === 3) {
        return api.set(obj, pointer, value);
    }
    // .get()
    if (arguments.length === 2) {
        return api.get(obj, pointer);
    }
    // Return a partially applied function on `obj`.
    var wrapped = api.bind(api, obj);
    // Support for oo style
    for(var name in api){
        if (api.hasOwnProperty(name)) {
            wrapped[name] = api[name].bind(wrapped, obj);
        }
    }
    return wrapped;
}
/**
 * Lookup a json pointer in an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @returns {*}
 */ api.get = function get(obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    for(var i = 0; i < refTokens.length; ++i){
        var tok = refTokens[i];
        if (!(typeof obj == 'object' && tok in obj)) {
            throw new Error('Invalid reference token: ' + tok);
        }
        obj = obj[tok];
    }
    return obj;
};
/**
 * Sets a value on an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 */ api.set = function set(obj, pointer, value) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer), nextTok = refTokens[0];
    if (refTokens.length === 0) {
        throw Error('Can not set the root object');
    }
    for(var i = 0; i < refTokens.length - 1; ++i){
        var tok = refTokens[i];
        if (typeof tok !== 'string' && typeof tok !== 'number') {
            tok = String(tok);
        }
        if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
            continue;
        }
        if (tok === '-' && Array.isArray(obj)) {
            tok = obj.length;
        }
        nextTok = refTokens[i + 1];
        if (!(tok in obj)) {
            if (nextTok.match(/^(\d+|-)$/)) {
                obj[tok] = [];
            } else {
                obj[tok] = {};
            }
        }
        obj = obj[tok];
    }
    if (nextTok === '-' && Array.isArray(obj)) {
        nextTok = obj.length;
    }
    obj[nextTok] = value;
    return this;
};
/**
 * Removes an attribute
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 */ api.remove = function(obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    var finalToken = refTokens[refTokens.length - 1];
    if (finalToken === undefined) {
        throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
    }
    var parent = api.get(obj, refTokens.slice(0, -1));
    if (Array.isArray(parent)) {
        var index = +finalToken;
        if (finalToken === '' && isNaN(index)) {
            throw new Error('Invalid array index: "' + finalToken + '"');
        }
        Array.prototype.splice.call(parent, index, 1);
    } else {
        delete parent[finalToken];
    }
};
/**
 * Returns a (pointer -> value) dictionary for an object
 *
 * @param obj
 * @param {function} descend
 * @returns {}
 */ api.dict = function dict(obj, descend) {
    var results = {};
    api.walk(obj, function(value, pointer) {
        results[pointer] = value;
    }, descend);
    return results;
};
/**
 * Iterates over an object
 * Iterator: function (value, pointer) {}
 *
 * @param obj
 * @param {function} iterator
 * @param {function} descend
 */ api.walk = function walk(obj, iterator, descend) {
    var refTokens = [];
    descend = descend || function(value) {
        var type = Object.prototype.toString.call(value);
        return type === '[object Object]' || type === '[object Array]';
    };
    (function next(cur) {
        each(cur, function(value, key) {
            refTokens.push(String(key));
            if (descend(value)) {
                next(value);
            } else {
                iterator(value, api.compile(refTokens));
            }
            refTokens.pop();
        });
    })(obj);
};
/**
 * Tests if an object has a value for a json pointer
 *
 * @param obj
 * @param pointer
 * @returns {boolean}
 */ api.has = function has(obj, pointer) {
    try {
        api.get(obj, pointer);
    } catch (e) {
        return false;
    }
    return true;
};
/**
 * Escapes a reference token
 *
 * @param str
 * @returns {string}
 */ api.escape = function escape(str) {
    return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
};
/**
 * Unescapes a reference token
 *
 * @param str
 * @returns {string}
 */ api.unescape = function unescape(str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
};
/**
 * Converts a json pointer into a array of reference tokens
 *
 * @param pointer
 * @returns {Array}
 */ api.parse = function parse(pointer) {
    if (pointer === '') {
        return [];
    }
    if (pointer.charAt(0) !== '/') {
        throw new Error('Invalid JSON pointer: ' + pointer);
    }
    return pointer.substring(1).split(/\//).map(api.unescape);
};
/**
 * Builds a json pointer from a array of reference tokens
 *
 * @param refTokens
 * @returns {string}
 */ api.compile = function compile(refTokens) {
    if (refTokens.length === 0) {
        return '';
    }
    return '/' + refTokens.map(api.escape).join('/');
};
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
const regexName = new RegExp('^' + nameRegexp + '$');
const getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while(match){
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for(let index = 0; index < len; index++){
            allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
    }
    return matches;
};
const isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === 'undefined');
};
exports.isExist = function(v) {
    return typeof v !== 'undefined';
};
exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
};
/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */ exports.merge = function(target, a, arrayMode) {
    if (a) {
        const keys = Object.keys(a); // will return an array of own properties
        const len = keys.length; //don't make it inline
        for(let i = 0; i < len; i++){
            if (arrayMode === 'strict') {
                target[keys[i]] = [
                    a[keys[i]]
                ];
            } else {
                target[keys[i]] = a[keys[i]];
            }
        }
    }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */ exports.getValue = function(v) {
    if (exports.isExist(v)) {
        return v;
    } else {
        return '';
    }
};
// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};
exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/validator.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const util = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js [app-rsc] (ecmascript)");
const defaultOptions = {
    allowBooleanAttributes: false,
    unpairedTags: []
};
//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function(xmlData, options) {
    options = Object.assign({}, defaultOptions, options);
    //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
    //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
    //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
    const tags = [];
    let tagFound = false;
    //indicates that the root tag has been closed (aka. depth 0 has been reached)
    let reachedRoot = false;
    if (xmlData[0] === '\ufeff') {
        // check for byte order mark (BOM)
        xmlData = xmlData.substr(1);
    }
    for(let i = 0; i < xmlData.length; i++){
        if (xmlData[i] === '<' && xmlData[i + 1] === '?') {
            i += 2;
            i = readPI(xmlData, i);
            if (i.err) return i;
        } else if (xmlData[i] === '<') {
            //starting of tag
            //read until you reach to '>' avoiding any '>' in attribute value
            let tagStartPos = i;
            i++;
            if (xmlData[i] === '!') {
                i = readCommentAndCDATA(xmlData, i);
                continue;
            } else {
                let closingTag = false;
                if (xmlData[i] === '/') {
                    //closing tag
                    closingTag = true;
                    i++;
                }
                //read tagname
                let tagName = '';
                for(; i < xmlData.length && xmlData[i] !== '>' && xmlData[i] !== ' ' && xmlData[i] !== '\t' && xmlData[i] !== '\n' && xmlData[i] !== '\r'; i++){
                    tagName += xmlData[i];
                }
                tagName = tagName.trim();
                //console.log(tagName);
                if (tagName[tagName.length - 1] === '/') {
                    //self closing tag without attributes
                    tagName = tagName.substring(0, tagName.length - 1);
                    //continue;
                    i--;
                }
                if (!validateTagName(tagName)) {
                    let msg;
                    if (tagName.trim().length === 0) {
                        msg = "Invalid space after '<'.";
                    } else {
                        msg = "Tag '" + tagName + "' is an invalid name.";
                    }
                    return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
                }
                const result = readAttributeStr(xmlData, i);
                if (result === false) {
                    return getErrorObject('InvalidAttr', "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
                }
                let attrStr = result.value;
                i = result.index;
                if (attrStr[attrStr.length - 1] === '/') {
                    //self closing tag
                    const attrStrStart = i - attrStr.length;
                    attrStr = attrStr.substring(0, attrStr.length - 1);
                    const isValid = validateAttributeString(attrStr, options);
                    if (isValid === true) {
                        tagFound = true;
                    //continue; //text may presents after self closing tag
                    } else {
                        //the result from the nested function returns the position of the error within the attribute
                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                        //this gives us the absolute index in the entire xml, which we can use to find the line at last
                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                    }
                } else if (closingTag) {
                    if (!result.tagClosed) {
                        return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
                    } else if (attrStr.trim().length > 0) {
                        return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                    } else if (tags.length === 0) {
                        return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
                    } else {
                        const otg = tags.pop();
                        if (tagName !== otg.tagName) {
                            let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                            return getErrorObject('InvalidTag', "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                        }
                        //when there are no more tags, we reached the root level.
                        if (tags.length == 0) {
                            reachedRoot = true;
                        }
                    }
                } else {
                    const isValid = validateAttributeString(attrStr, options);
                    if (isValid !== true) {
                        //the result from the nested function returns the position of the error within the attribute
                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
                        //this gives us the absolute index in the entire xml, which we can use to find the line at last
                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
                    }
                    //if the root level has been reached before ...
                    if (reachedRoot === true) {
                        return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
                    } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                    //don't push into stack
                    } else {
                        tags.push({
                            tagName,
                            tagStartPos
                        });
                    }
                    tagFound = true;
                }
                //skip tag text value
                //It may include comments and CDATA value
                for(i++; i < xmlData.length; i++){
                    if (xmlData[i] === '<') {
                        if (xmlData[i + 1] === '!') {
                            //comment or CADATA
                            i++;
                            i = readCommentAndCDATA(xmlData, i);
                            continue;
                        } else if (xmlData[i + 1] === '?') {
                            i = readPI(xmlData, ++i);
                            if (i.err) return i;
                        } else {
                            break;
                        }
                    } else if (xmlData[i] === '&') {
                        const afterAmp = validateAmpersand(xmlData, i);
                        if (afterAmp == -1) return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                        i = afterAmp;
                    } else {
                        if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                            return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
                        }
                    }
                } //end of reading tag text value
                if (xmlData[i] === '<') {
                    i--;
                }
            }
        } else {
            if (isWhiteSpace(xmlData[i])) {
                continue;
            }
            return getErrorObject('InvalidChar', "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
        }
    }
    if (!tagFound) {
        return getErrorObject('InvalidXml', 'Start tag expected.', 1);
    } else if (tags.length == 1) {
        return getErrorObject('InvalidTag', "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
        return getErrorObject('InvalidXml', "Invalid '" + JSON.stringify(tags.map((t)=>t.tagName), null, 4).replace(/\r?\n/g, '') + "' found.", {
            line: 1,
            col: 1
        });
    }
    return true;
};
function isWhiteSpace(char) {
    return char === ' ' || char === '\t' || char === '\n' || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */ function readPI(xmlData, i) {
    const start = i;
    for(; i < xmlData.length; i++){
        if (xmlData[i] == '?' || xmlData[i] == ' ') {
            //tagname
            const tagname = xmlData.substr(start, i - start);
            if (i > 5 && tagname === 'xml') {
                return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
            } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
                //check if valid attribut string
                i++;
                break;
            } else {
                continue;
            }
        }
    }
    return i;
}
function readCommentAndCDATA(xmlData, i) {
    if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
        //comment
        for(i += 3; i < xmlData.length; i++){
            if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
                i += 2;
                break;
            }
        }
    } else if (xmlData.length > i + 8 && xmlData[i + 1] === 'D' && xmlData[i + 2] === 'O' && xmlData[i + 3] === 'C' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'Y' && xmlData[i + 6] === 'P' && xmlData[i + 7] === 'E') {
        let angleBracketsCount = 1;
        for(i += 8; i < xmlData.length; i++){
            if (xmlData[i] === '<') {
                angleBracketsCount++;
            } else if (xmlData[i] === '>') {
                angleBracketsCount--;
                if (angleBracketsCount === 0) {
                    break;
                }
            }
        }
    } else if (xmlData.length > i + 9 && xmlData[i + 1] === '[' && xmlData[i + 2] === 'C' && xmlData[i + 3] === 'D' && xmlData[i + 4] === 'A' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'A' && xmlData[i + 7] === '[') {
        for(i += 8; i < xmlData.length; i++){
            if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
                i += 2;
                break;
            }
        }
    }
    return i;
}
const doubleQuote = '"';
const singleQuote = "'";
/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */ function readAttributeStr(xmlData, i) {
    let attrStr = '';
    let startChar = '';
    let tagClosed = false;
    for(; i < xmlData.length; i++){
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
            if (startChar === '') {
                startChar = xmlData[i];
            } else if (startChar !== xmlData[i]) {
            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
            } else {
                startChar = '';
            }
        } else if (xmlData[i] === '>') {
            if (startChar === '') {
                tagClosed = true;
                break;
            }
        }
        attrStr += xmlData[i];
    }
    if (startChar !== '') {
        return false;
    }
    return {
        value: attrStr,
        index: i,
        tagClosed: tagClosed
    };
}
/**
 * Select all the attributes whether valid or invalid.
 */ const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');
//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""
function validateAttributeString(attrStr, options) {
    //console.log("start:"+attrStr+":end");
    //if(attrStr.trim().length === 0) return true; //empty string
    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};
    for(let i = 0; i < matches.length; i++){
        if (matches[i][1].length === 0) {
            //nospace before attribute name: a="sd"b="saf"
            return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
            return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
            //independent attribute: ab
            return getErrorObject('InvalidAttr', "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
        }
        /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */ const attrName = matches[i][2];
        if (!validateAttrName(attrName)) {
            return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
            //check for duplicate attribute.
            attrNames[attrName] = 1;
        } else {
            return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
        }
    }
    return true;
}
function validateNumberAmpersand(xmlData, i) {
    let re = /\d/;
    if (xmlData[i] === 'x') {
        i++;
        re = /[\da-fA-F]/;
    }
    for(; i < xmlData.length; i++){
        if (xmlData[i] === ';') return i;
        if (!xmlData[i].match(re)) break;
    }
    return -1;
}
function validateAmpersand(xmlData, i) {
    // https://www.w3.org/TR/xml/#dt-charref
    i++;
    if (xmlData[i] === ';') return -1;
    if (xmlData[i] === '#') {
        i++;
        return validateNumberAmpersand(xmlData, i);
    }
    let count = 0;
    for(; i < xmlData.length; i++, count++){
        if (xmlData[i].match(/\w/) && count < 20) continue;
        if (xmlData[i] === ';') break;
        return -1;
    }
    return i;
}
function getErrorObject(code, message, lineNumber) {
    return {
        err: {
            code: code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
        }
    };
}
function validateAttrName(attrName) {
    return util.isName(attrName);
}
// const startsWithXML = /^xml/i;
function validateTagName(tagname) {
    return util.isName(tagname) /* && !tagname.match(startsWithXML) */ ;
}
//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
    };
}
//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
}
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false,
    allowBooleanAttributes: false,
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true,
    cdataPropName: false,
    numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
        return val;
    },
    attributeValueProcessor: function(attrName, val) {
        return val;
    },
    stopNodes: [],
    alwaysCreateTextNode: false,
    isArray: ()=>false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs) {
        return tagName;
    }
};
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};
exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class XmlNode {
    constructor(tagname){
        this.tagname = tagname;
        this.child = []; //nested tags, text, cdata, comments in order
        this[":@"] = {}; //attributes map
    }
    add(key, val) {
        // this.child.push( {name : key, val: val, isCdata: isCdata });
        if (key === "__proto__") key = "#__proto__";
        this.child.push({
            [key]: val
        });
    }
    addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({
                [node.tagname]: node.child,
                [":@"]: node[":@"]
            });
        } else {
            this.child.push({
                [node.tagname]: node.child
            });
        }
    }
}
;
module.exports = XmlNode;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const util = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js [app-rsc] (ecmascript)");
//TODO: handle comments
function readDocType(xmlData, i) {
    const entities = {};
    if (xmlData[i + 3] === 'O' && xmlData[i + 4] === 'C' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'Y' && xmlData[i + 7] === 'P' && xmlData[i + 8] === 'E') {
        i = i + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(; i < xmlData.length; i++){
            if (xmlData[i] === '<' && !comment) {
                if (hasBody && isEntity(xmlData, i)) {
                    i += 7;
                    let entityName, val;
                    [entityName, val, i] = readEntityExp(xmlData, i + 1);
                    if (val.indexOf("&") === -1) entities[validateEntityName(entityName)] = {
                        regx: RegExp(`&${entityName};`, "g"),
                        val: val
                    };
                } else if (hasBody && isElement(xmlData, i)) i += 8; //Not supported
                else if (hasBody && isAttlist(xmlData, i)) i += 8; //Not supported
                else if (hasBody && isNotation(xmlData, i)) i += 9; //Not supported
                else if ("TURBOPACK compile-time truthy", 1) comment = true;
                else //TURBOPACK unreachable
                ;
                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') {
                if (comment) {
                    if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                        comment = false;
                        angleBracketsCount--;
                    }
                } else {
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                    break;
                }
            } else if (xmlData[i] === '[') {
                hasBody = true;
            } else {
                exp += xmlData[i];
            }
        }
        if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
        }
    } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {
        entities,
        i
    };
}
function readEntityExp(xmlData, i) {
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >
    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">
    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    //read EntityName
    let entityName = "";
    for(; i < xmlData.length && xmlData[i] !== "'" && xmlData[i] !== '"'; i++){
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if (entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");
    //read Entity Value
    const startChar = xmlData[i++];
    let val = "";
    for(; i < xmlData.length && xmlData[i] !== startChar; i++){
        val += xmlData[i];
    }
    return [
        entityName,
        val,
        i
    ];
}
function isComment(xmlData, i) {
    if (xmlData[i + 1] === '!' && xmlData[i + 2] === '-' && xmlData[i + 3] === '-') return true;
    return false;
}
function isEntity(xmlData, i) {
    if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'E' && xmlData[i + 3] === 'N' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'I' && xmlData[i + 6] === 'T' && xmlData[i + 7] === 'Y') return true;
    return false;
}
function isElement(xmlData, i) {
    if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'E' && xmlData[i + 3] === 'L' && xmlData[i + 4] === 'E' && xmlData[i + 5] === 'M' && xmlData[i + 6] === 'E' && xmlData[i + 7] === 'N' && xmlData[i + 8] === 'T') return true;
    return false;
}
function isAttlist(xmlData, i) {
    if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'A' && xmlData[i + 3] === 'T' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'L' && xmlData[i + 6] === 'I' && xmlData[i + 7] === 'S' && xmlData[i + 8] === 'T') return true;
    return false;
}
function isNotation(xmlData, i) {
    if (xmlData[i + 1] === '!' && xmlData[i + 2] === 'N' && xmlData[i + 3] === 'O' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'A' && xmlData[i + 6] === 'T' && xmlData[i + 7] === 'I' && xmlData[i + 8] === 'O' && xmlData[i + 9] === 'N') return true;
    return false;
}
function validateEntityName(name) {
    if (util.isName(name)) return name;
    else throw new Error(`Invalid entity name ${name}`);
}
module.exports = readDocType;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/ignoreAttributes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === 'function') {
        return ignoreAttributes;
    }
    if (Array.isArray(ignoreAttributes)) {
        return (attrName)=>{
            for (const pattern of ignoreAttributes){
                if (typeof pattern === 'string' && attrName === pattern) {
                    return true;
                }
                if (pattern instanceof RegExp && pattern.test(attrName)) {
                    return true;
                }
            }
        };
    }
    return ()=>false;
}
module.exports = getIgnoreAttributesFn;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

///@ts-check
const util = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/util.js [app-rsc] (ecmascript)");
const xmlNode = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js [app-rsc] (ecmascript)");
const readDocType = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js [app-rsc] (ecmascript)");
const toNumber = __turbopack_context__.r("[project]/node_modules/.pnpm/strnum@1.1.2/node_modules/strnum/strnum.js [app-rsc] (ecmascript)");
const getIgnoreAttributesFn = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/ignoreAttributes.js [app-rsc] (ecmascript)");
// const regx =
//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
//   .replace(/NAME/g, util.nameRegexp);
//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");
class OrderedObjParser {
    constructor(options){
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
            "apos": {
                regex: /&(apos|#39|#x27);/g,
                val: "'"
            },
            "gt": {
                regex: /&(gt|#62|#x3E);/g,
                val: ">"
            },
            "lt": {
                regex: /&(lt|#60|#x3C);/g,
                val: "<"
            },
            "quot": {
                regex: /&(quot|#34|#x22);/g,
                val: "\""
            }
        };
        this.ampEntity = {
            regex: /&(amp|#38|#x26);/g,
            val: "&"
        };
        this.htmlEntities = {
            "space": {
                regex: /&(nbsp|#160);/g,
                val: " "
            },
            // "lt" : { regex: /&(lt|#60);/g, val: "<" },
            // "gt" : { regex: /&(gt|#62);/g, val: ">" },
            // "amp" : { regex: /&(amp|#38);/g, val: "&" },
            // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
            // "apos" : { regex: /&(apos|#39);/g, val: "'" },
            "cent": {
                regex: /&(cent|#162);/g,
                val: "¢"
            },
            "pound": {
                regex: /&(pound|#163);/g,
                val: "£"
            },
            "yen": {
                regex: /&(yen|#165);/g,
                val: "¥"
            },
            "euro": {
                regex: /&(euro|#8364);/g,
                val: "€"
            },
            "copyright": {
                regex: /&(copy|#169);/g,
                val: "©"
            },
            "reg": {
                regex: /&(reg|#174);/g,
                val: "®"
            },
            "inr": {
                regex: /&(inr|#8377);/g,
                val: "₹"
            },
            "num_dec": {
                regex: /&#([0-9]{1,7});/g,
                val: (_, str)=>String.fromCharCode(Number.parseInt(str, 10))
            },
            "num_hex": {
                regex: /&#x([0-9a-fA-F]{1,6});/g,
                val: (_, str)=>String.fromCharCode(Number.parseInt(str, 16))
            }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    }
}
function addExternalEntities(externalEntities) {
    const entKeys = Object.keys(externalEntities);
    for(let i = 0; i < entKeys.length; i++){
        const ent = entKeys[i];
        this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
        };
    }
}
/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */ function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
    if (val !== undefined) {
        if (this.options.trimValues && !dontTrim) {
            val = val.trim();
        }
        if (val.length > 0) {
            if (!escapeEntities) val = this.replaceEntitiesValue(val);
            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === undefined) {
                //don't parse
                return val;
            } else if (typeof newval !== typeof val || newval !== val) {
                //overwrite
                return newval;
            } else if (this.options.trimValues) {
                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
                const trimmedVal = val.trim();
                if (trimmedVal === val) {
                    return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
                } else {
                    return val;
                }
            }
        }
    }
}
function resolveNameSpace(tagname) {
    if (this.options.removeNSPrefix) {
        const tags = tagname.split(':');
        const prefix = tagname.charAt(0) === '/' ? '/' : '';
        if (tags[0] === 'xmlns') {
            return '';
        }
        if (tags.length === 2) {
            tagname = prefix + tags[1];
        }
    }
    return tagname;
}
//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');
function buildAttributesMap(attrStr, jPath, tagName) {
    if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {
        // attrStr = attrStr.replace(/\r?\n/g, ' ');
        //attrStr = attrStr || attrStr.trim();
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length; //don't make it inline
        const attrs = {};
        for(let i = 0; i < len; i++){
            const attrName = this.resolveNameSpace(matches[i][1]);
            if (this.ignoreAttributesFn(attrName, jPath)) {
                continue;
            }
            let oldVal = matches[i][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
                if (this.options.transformAttributeName) {
                    aName = this.options.transformAttributeName(aName);
                }
                if (aName === "__proto__") aName = "#__proto__";
                if (oldVal !== undefined) {
                    if (this.options.trimValues) {
                        oldVal = oldVal.trim();
                    }
                    oldVal = this.replaceEntitiesValue(oldVal);
                    const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                    if (newVal === null || newVal === undefined) {
                        //don't parse
                        attrs[aName] = oldVal;
                    } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                        //overwrite
                        attrs[aName] = newVal;
                    } else {
                        //parse
                        attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
                    }
                } else if (this.options.allowBooleanAttributes) {
                    attrs[aName] = true;
                }
            }
        }
        if (!Object.keys(attrs).length) {
            return;
        }
        if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
        }
        return attrs;
    }
}
const parseXml = function(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
    const xmlObj = new xmlNode('!xml');
    let currentNode = xmlObj;
    let textData = "";
    let jPath = "";
    for(let i = 0; i < xmlData.length; i++){
        const ch = xmlData[i];
        if (ch === '<') {
            // const nextIndex = i+1;
            // const _2ndChar = xmlData[nextIndex];
            if (xmlData[i + 1] === '/') {
                const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
                let tagName = xmlData.substring(i + 2, closeIndex).trim();
                if (this.options.removeNSPrefix) {
                    const colonIndex = tagName.indexOf(":");
                    if (colonIndex !== -1) {
                        tagName = tagName.substr(colonIndex + 1);
                    }
                }
                if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                }
                if (currentNode) {
                    textData = this.saveTextToParentTag(textData, currentNode, jPath);
                }
                //check if last tag of nested tag was unpaired tag
                const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
                if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                    throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
                }
                let propIndex = 0;
                if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                    propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.') - 1);
                    this.tagsNodeStack.pop();
                } else {
                    propIndex = jPath.lastIndexOf(".");
                }
                jPath = jPath.substring(0, propIndex);
                currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope
                textData = "";
                i = closeIndex;
            } else if (xmlData[i + 1] === '?') {
                let tagData = readTagExp(xmlData, i, false, "?>");
                if (!tagData) throw new Error("Pi Tag is not closed.");
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {} else {
                    const childNode = new xmlNode(tagData.tagName);
                    childNode.add(this.options.textNodeName, "");
                    if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                        childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                    }
                    this.addChild(currentNode, childNode, jPath);
                }
                i = tagData.closeIndex + 1;
            } else if (xmlData.substr(i + 1, 3) === '!--') {
                const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
                if (this.options.commentPropName) {
                    const comment = xmlData.substring(i + 4, endIndex - 2);
                    textData = this.saveTextToParentTag(textData, currentNode, jPath);
                    currentNode.add(this.options.commentPropName, [
                        {
                            [this.options.textNodeName]: comment
                        }
                    ]);
                }
                i = endIndex;
            } else if (xmlData.substr(i + 1, 2) === '!D') {
                const result = readDocType(xmlData, i);
                this.docTypeEntities = result.entities;
                i = result.i;
            } else if (xmlData.substr(i + 1, 2) === '![') {
                const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
                const tagExp = xmlData.substring(i + 9, closeIndex);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
                if (val == undefined) val = "";
                //cdata should be set even if it is 0 length string
                if (this.options.cdataPropName) {
                    currentNode.add(this.options.cdataPropName, [
                        {
                            [this.options.textNodeName]: tagExp
                        }
                    ]);
                } else {
                    currentNode.add(this.options.textNodeName, val);
                }
                i = closeIndex + 2;
            } else {
                let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
                let tagName = result.tagName;
                const rawTagName = result.rawTagName;
                let tagExp = result.tagExp;
                let attrExpPresent = result.attrExpPresent;
                let closeIndex = result.closeIndex;
                if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                }
                //save text as child node
                if (currentNode && textData) {
                    if (currentNode.tagname !== '!xml') {
                        //when nested tag is found
                        textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                    }
                }
                //check if last tag was unpaired tag
                const lastTag = currentNode;
                if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                    currentNode = this.tagsNodeStack.pop();
                    jPath = jPath.substring(0, jPath.lastIndexOf("."));
                }
                if (tagName !== xmlObj.tagname) {
                    jPath += jPath ? "." + tagName : tagName;
                }
                if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                    let tagContent = "";
                    //self-closing tag
                    if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                        if (tagName[tagName.length - 1] === "/") {
                            tagName = tagName.substr(0, tagName.length - 1);
                            jPath = jPath.substr(0, jPath.length - 1);
                            tagExp = tagName;
                        } else {
                            tagExp = tagExp.substr(0, tagExp.length - 1);
                        }
                        i = result.closeIndex;
                    } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                        i = result.closeIndex;
                    } else {
                        //read until closing tag is found
                        const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                        if (!result) throw new Error(`Unexpected end of ${rawTagName}`);
                        i = result.i;
                        tagContent = result.tagContent;
                    }
                    const childNode = new xmlNode(tagName);
                    if (tagName !== tagExp && attrExpPresent) {
                        childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                    }
                    if (tagContent) {
                        tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                    }
                    jPath = jPath.substr(0, jPath.lastIndexOf("."));
                    childNode.add(this.options.textNodeName, tagContent);
                    this.addChild(currentNode, childNode, jPath);
                } else {
                    //selfClosing tag
                    if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                        if (tagName[tagName.length - 1] === "/") {
                            tagName = tagName.substr(0, tagName.length - 1);
                            jPath = jPath.substr(0, jPath.length - 1);
                            tagExp = tagName;
                        } else {
                            tagExp = tagExp.substr(0, tagExp.length - 1);
                        }
                        if (this.options.transformTagName) {
                            tagName = this.options.transformTagName(tagName);
                        }
                        const childNode = new xmlNode(tagName);
                        if (tagName !== tagExp && attrExpPresent) {
                            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                        }
                        this.addChild(currentNode, childNode, jPath);
                        jPath = jPath.substr(0, jPath.lastIndexOf("."));
                    } else {
                        const childNode = new xmlNode(tagName);
                        this.tagsNodeStack.push(currentNode);
                        if (tagName !== tagExp && attrExpPresent) {
                            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                        }
                        this.addChild(currentNode, childNode, jPath);
                        currentNode = childNode;
                    }
                    textData = "";
                    i = closeIndex;
                }
            }
        } else {
            textData += xmlData[i];
        }
    }
    return xmlObj.child;
};
function addChild(currentNode, childNode, jPath) {
    const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
    if (result === false) {} else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
    } else {
        currentNode.addChild(childNode);
    }
}
const replaceEntitiesValue = function(val) {
    if (this.options.processEntities) {
        for(let entityName in this.docTypeEntities){
            const entity = this.docTypeEntities[entityName];
            val = val.replace(entity.regx, entity.val);
        }
        for(let entityName in this.lastEntities){
            const entity = this.lastEntities[entityName];
            val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
            for(let entityName in this.htmlEntities){
                const entity = this.htmlEntities[entityName];
                val = val.replace(entity.regex, entity.val);
            }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
    if (textData) {
        if (isLeafNode === undefined) isLeafNode = currentNode.child.length === 0;
        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
        if (textData !== undefined && textData !== "") currentNode.add(this.options.textNodeName, textData);
        textData = "";
    }
    return textData;
}
//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */ function isItStopNode(stopNodes, jPath, currentTagName) {
    const allNodesExp = "*." + currentTagName;
    for(const stopNodePath in stopNodes){
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
    }
    return false;
}
/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */ function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
    let attrBoundary;
    let tagExp = "";
    for(let index = i; index < xmlData.length; index++){
        let ch = xmlData[index];
        if (attrBoundary) {
            if (ch === attrBoundary) attrBoundary = ""; //reset
        } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
        } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
                if (xmlData[index + 1] === closingChar[1]) {
                    return {
                        data: tagExp,
                        index: index
                    };
                }
            } else {
                return {
                    data: tagExp,
                    index: index
                };
            }
        } else if (ch === '\t') {
            ch = " ";
        }
        tagExp += ch;
    }
}
function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);
    if (closingIndex === -1) {
        throw new Error(errMsg);
    } else {
        return closingIndex + str.length - 1;
    }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result) return;
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
    }
    return {
        tagName: tagName,
        tagExp: tagExp,
        closeIndex: closeIndex,
        attrExpPresent: attrExpPresent,
        rawTagName: rawTagName
    };
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */ function readStopNodeData(xmlData, tagName, i) {
    const startIndex = i;
    // Starting at 1 since we already have an open tag
    let openTagCount = 1;
    for(; i < xmlData.length; i++){
        if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "/") {
                const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
                let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
                if (closeTagName === tagName) {
                    openTagCount--;
                    if (openTagCount === 0) {
                        return {
                            tagContent: xmlData.substring(startIndex, i),
                            i: closeIndex
                        };
                    }
                }
                i = closeIndex;
            } else if (xmlData[i + 1] === '?') {
                const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
                i = closeIndex;
            } else if (xmlData.substr(i + 1, 3) === '!--') {
                const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
                i = closeIndex;
            } else if (xmlData.substr(i + 1, 2) === '![') {
                const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
                i = closeIndex;
            } else {
                const tagData = readTagExp(xmlData, i, '>');
                if (tagData) {
                    const openTagName = tagData && tagData.tagName;
                    if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                        openTagCount++;
                    }
                    i = tagData.closeIndex;
                }
            }
        }
    } //end for loop
}
function parseValue(val, shouldParse, options) {
    if (shouldParse && typeof val === 'string') {
        //console.log(options)
        const newval = val.trim();
        if (newval === 'true') return true;
        else if (newval === 'false') return false;
        else return toNumber(val, options);
    } else {
        if (util.isExist(val)) {
            return val;
        } else {
            return '';
        }
    }
}
module.exports = OrderedObjParser;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */ function prettify(node, options) {
    return compress(node, options);
}
/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */ function compress(arr, options, jPath) {
    let text;
    const compressedObj = {};
    for(let i = 0; i < arr.length; i++){
        const tagObj = arr[i];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === undefined) newJpath = property;
        else newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
            if (text === undefined) text = tagObj[property];
            else text += "" + tagObj[property];
        } else if (property === undefined) {
            continue;
        } else if (tagObj[property]) {
            let val = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val, options);
            if (tagObj[":@"]) {
                assignAttributes(val, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {
                val = val[options.textNodeName];
            } else if (Object.keys(val).length === 0) {
                if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
                else val = "";
            }
            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
                if (!Array.isArray(compressedObj[property])) {
                    compressedObj[property] = [
                        compressedObj[property]
                    ];
                }
                compressedObj[property].push(val);
            } else {
                //TODO: if a node is not an array, then check if it should be an array
                //also determine if it is a leaf node
                if (options.isArray(property, newJpath, isLeaf)) {
                    compressedObj[property] = [
                        val
                    ];
                } else {
                    compressedObj[property] = val;
                }
            }
        }
    }
    // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
    if (typeof text === "string") {
        if (text.length > 0) compressedObj[options.textNodeName] = text;
    } else if (text !== undefined) compressedObj[options.textNodeName] = text;
    return compressedObj;
}
function propName(obj) {
    const keys = Object.keys(obj);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        if (key !== ":@") return key;
    }
}
function assignAttributes(obj, attrMap, jpath, options) {
    if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length; //don't make it inline
        for(let i = 0; i < len; i++){
            const atrrName = keys[i];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
                obj[atrrName] = [
                    attrMap[atrrName]
                ];
            } else {
                obj[atrrName] = attrMap[atrrName];
            }
        }
    }
}
function isLeafTag(obj, options) {
    const { textNodeName } = options;
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
        return true;
    }
    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
    }
    return false;
}
exports.prettify = prettify;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { buildOptions } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js [app-rsc] (ecmascript)");
const OrderedObjParser = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js [app-rsc] (ecmascript)");
const { prettify } = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/node2json.js [app-rsc] (ecmascript)");
const validator = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/validator.js [app-rsc] (ecmascript)");
class XMLParser {
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */ parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {} else if (xmlData.toString) {
            xmlData = xmlData.toString();
        } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
            if (validationOption === true) validationOption = {}; //validate with default options
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
                throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }
    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */ addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
        } else {
            this.externalEntities[key] = value;
        }
    }
}
module.exports = XMLParser;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const EOL = "\n";
/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */ function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;
    for(let i = 0; i < arr.length; i++){
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if (tagName === undefined) continue;
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }
    return xmlStr;
}
function propName(obj) {
    const keys = Object.keys(obj);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
    }
}
function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for(let attr in attrMap){
            if (!attrMap.hasOwnProperty(attr)) continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}
function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for(let index in options.stopNodes){
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}
function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for(let i = 0; i < options.entities.length; i++){
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js [app-rsc] (ecmascript)");
const getIgnoreAttributesFn = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/ignoreAttributes.js [app-rsc] (ecmascript)");
const defaultOptions = {
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    cdataPropName: false,
    format: false,
    indentBy: '  ',
    suppressEmptyNode: false,
    suppressUnpairedNode: true,
    suppressBooleanAttributes: true,
    tagValueProcessor: function(key, a) {
        return a;
    },
    attributeValueProcessor: function(attrName, a) {
        return a;
    },
    preserveOrder: false,
    commentPropName: false,
    unpairedTags: [],
    entities: [
        {
            regex: new RegExp("&", "g"),
            val: "&amp;"
        },
        {
            regex: new RegExp(">", "g"),
            val: "&gt;"
        },
        {
            regex: new RegExp("<", "g"),
            val: "&lt;"
        },
        {
            regex: new RegExp("\'", "g"),
            val: "&apos;"
        },
        {
            regex: new RegExp("\"", "g"),
            val: "&quot;"
        }
    ],
    processEntities: true,
    stopNodes: [],
    // transformTagName: false,
    // transformAttributeName: false,
    oneListGroup: false
};
function Builder(options) {
    this.options = Object.assign({}, defaultOptions, options);
    if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
        this.isAttribute = function() {
            return false;
        };
    } else {
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
    }
    this.processTextOrObjNode = processTextOrObjNode;
    if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = '>\n';
        this.newLine = '\n';
    } else {
        this.indentate = function() {
            return '';
        };
        this.tagEndChar = '>';
        this.newLine = '';
    }
}
Builder.prototype.build = function(jObj) {
    if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
    } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
                [this.options.arrayNodeName]: jObj
            };
        }
        return this.j2x(jObj, 0, []).val;
    }
};
Builder.prototype.j2x = function(jObj, level, ajPath) {
    let attrStr = '';
    let val = '';
    const jPath = ajPath.join('.');
    for(let key in jObj){
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === 'undefined') {
            // supress undefined node only if it is not an attribute
            if (this.isAttribute(key)) {
                val += '';
            }
        } else if (jObj[key] === null) {
            // null attribute should be ignored by the attribute list, but should not cause the tag closing
            if (this.isAttribute(key)) {
                val += '';
            } else if (key === this.options.cdataPropName) {
                val += '';
            } else if (key[0] === '?') {
                val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
            } else {
                val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
            }
        // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
            val += this.buildTextValNode(jObj[key], key, '', level);
        } else if (typeof jObj[key] !== 'object') {
            //premitive type
            const attr = this.isAttribute(key);
            if (attr && !this.ignoreAttributesFn(attr, jPath)) {
                attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
            } else if (!attr) {
                //tag value
                if (key === this.options.textNodeName) {
                    let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
                    val += this.replaceEntitiesValue(newval);
                } else {
                    val += this.buildTextValNode(jObj[key], key, '', level);
                }
            }
        } else if (Array.isArray(jObj[key])) {
            //repeated nodes
            const arrLen = jObj[key].length;
            let listTagVal = "";
            let listTagAttr = "";
            for(let j = 0; j < arrLen; j++){
                const item = jObj[key][j];
                if (typeof item === 'undefined') {
                // supress undefined node
                } else if (item === null) {
                    if (key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
                    else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
                } else if (typeof item === 'object') {
                    if (this.options.oneListGroup) {
                        const result = this.j2x(item, level + 1, ajPath.concat(key));
                        listTagVal += result.val;
                        if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                            listTagAttr += result.attrStr;
                        }
                    } else {
                        listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
                    }
                } else {
                    if (this.options.oneListGroup) {
                        let textValue = this.options.tagValueProcessor(key, item);
                        textValue = this.replaceEntitiesValue(textValue);
                        listTagVal += textValue;
                    } else {
                        listTagVal += this.buildTextValNode(item, key, '', level);
                    }
                }
            }
            if (this.options.oneListGroup) {
                listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
            }
            val += listTagVal;
        } else {
            //nested node
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
                const Ks = Object.keys(jObj[key]);
                const L = Ks.length;
                for(let j = 0; j < L; j++){
                    attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
                }
            } else {
                val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
            }
        }
    }
    return {
        attrStr: attrStr,
        val: val
    };
};
Builder.prototype.buildAttrPairStr = function(attrName, val) {
    val = this.options.attributeValueProcessor(attrName, '' + val);
    val = this.replaceEntitiesValue(val);
    if (this.options.suppressBooleanAttributes && val === "true") {
        return ' ' + attrName;
    } else return ' ' + attrName + '="' + val + '"';
};
function processTextOrObjNode(object, key, level, ajPath) {
    const result = this.j2x(object, level + 1, ajPath.concat(key));
    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
    } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
    }
}
Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
    if (val === "") {
        if (key[0] === "?") return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;
        else {
            return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
    } else {
        let tagEndExp = '</' + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
        }
        // attrStr is an empty string in case the attribute came as undefined or null
        if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
            return this.indentate(level) + '<' + key + attrStr + piClosingChar + '>' + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
            return this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
    }
};
Builder.prototype.closeTag = function(key) {
    let closeTag = "";
    if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode) closeTag = "/";
    } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
    } else {
        closeTag = `></${key}`;
    }
    return closeTag;
};
function buildEmptyObjNode(val, key, attrStr, level) {
    if (val !== '') {
        return this.buildObjectNode(val, key, attrStr, level);
    } else {
        if (key[0] === "?") return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;
        else {
            return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
        // return this.buildTagStr(level,key, attrStr);
        }
    }
}
Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
    if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
    } else if (key[0] === "?") {
        return this.indentate(level) + '<' + key + attrStr + '?' + this.tagEndChar;
    } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === '') {
            return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
            return this.indentate(level) + '<' + key + attrStr + '>' + textValue + '</' + key + this.tagEndChar;
        }
    }
};
Builder.prototype.replaceEntitiesValue = function(textValue) {
    if (textValue && textValue.length > 0 && this.options.processEntities) {
        for(let i = 0; i < this.options.entities.length; i++){
            const entity = this.options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
};
function indentate(level) {
    return this.options.indentBy.repeat(level);
}
function isAttribute(name /*, options*/ ) {
    if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
        return name.substr(this.attrPrefixLen);
    } else {
        return false;
    }
}
module.exports = Builder;
}),
"[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/fxp.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const validator = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/validator.js [app-rsc] (ecmascript)");
const XMLParser = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js [app-rsc] (ecmascript)");
const XMLBuilder = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-xml-parser@4.5.3/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js [app-rsc] (ecmascript)");
module.exports = {
    XMLParser: XMLParser,
    XMLValidator: validator,
    XMLBuilder: XMLBuilder
};
}),
"[project]/node_modules/.pnpm/strnum@1.1.2/node_modules/strnum/strnum.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
// const octRegex = /^0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;
const consider = {
    hex: true,
    // oct: false,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
};
function toNumber(str, options = {}) {
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string") return str;
    let trimmedStr = str.trim();
    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (str === "0") return 0;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
    // }else if (options.oct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
        // +00.123 => [ , '+', '00', '.123', ..
        if (notation) {
            // console.log(notation)
            if (options.leadingZeros) {
                trimmedStr = (notation[1] || "") + notation[3];
            } else {
                if (notation[2] === "0" && notation[3][0] === ".") {} else {
                    return str;
                }
            }
            return options.eNotation ? Number(trimmedStr) : str;
        } else {
            return str;
        }
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    } else {
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        // +00.123 => [ , '+', '00', '.123', ..
        if (match) {
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else if (options.leadingZeros && leadingZeros === str) return 0; //00
            else {
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if (numStr.search(/[eE]/) !== -1) {
                    if (options.eNotation) return num;
                    else return str;
                } else if (trimmedStr.indexOf(".") !== -1) {
                    if (numStr === "0" && numTrimmedByZeros === "") return num; //0.0
                    else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if (sign && numStr === "-" + numTrimmedByZeros) return num;
                    else return str;
                }
                if (leadingZeros) {
                    return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;
                } else {
                    return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;
                }
            }
        } else {
            return str;
        }
    }
}
/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */ function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
    }
    return numStr;
}
function parse_int(numStr, base) {
    //polyfill
    if (parseInt) return parseInt(numStr, base);
    else if (Number.parseInt) return Number.parseInt(numStr, base);
    else if (window && window.parseInt) return window.parseInt(numStr, base);
    else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
module.exports = toNumber;
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/to-json.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDeepKeys",
    ()=>getDeepKeys,
    "toJSON",
    ()=>toJSON
]);
const nonJsonTypes = [
    "function",
    "symbol",
    "undefined"
];
const protectedProps = [
    "constructor",
    "prototype",
    "__proto__"
];
const objectPrototype = Object.getPrototypeOf({});
function toJSON() {
    // HACK: We have to cast the objects to `any` so we can use symbol indexers.
    // see https://github.com/Microsoft/TypeScript/issues/1863
    let pojo = {};
    let error = this;
    for (let key of getDeepKeys(error)){
        if (typeof key === "string") {
            let value = error[key];
            let type = typeof value;
            if (!nonJsonTypes.includes(type)) {
                pojo[key] = value;
            }
        }
    }
    return pojo;
}
function getDeepKeys(obj, omit = []) {
    let keys = [];
    // Crawl the prototype chain, finding all the string and symbol keys
    while(obj && obj !== objectPrototype){
        keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
        obj = Object.getPrototypeOf(obj);
    }
    // De-duplicate the list of keys
    let uniqueKeys = new Set(keys);
    // Remove any omitted keys
    for (let key of omit.concat(protectedProps)){
        uniqueKeys.delete(key);
    }
    return uniqueKeys;
} //# sourceMappingURL=to-json.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/isomorphic.node.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addInspectMethod",
    ()=>addInspectMethod,
    "format",
    ()=>format
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/util [external] (util, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/to-json.js [app-rsc] (ecmascript)");
;
;
// The `inspect()` method is actually a Symbol, not a string key.
// https://nodejs.org/api/util.html#util_util_inspect_custom
const inspectMethod = __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["inspect"].custom || Symbol.for("nodejs.util.inspect.custom");
const format = __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["format"];
function addInspectMethod(newError) {
    // @ts-expect-error - TypeScript doesn't support symbol indexers
    newError[inspectMethod] = inspect;
}
/**
 * Returns a representation of the error for Node's `util.inspect()` method.
 *
 * @see https://nodejs.org/api/util.html#util_custom_inspection_functions_on_objects
 */ function inspect() {
    // HACK: We have to cast the objects to `any` so we can use symbol indexers.
    // see https://github.com/Microsoft/TypeScript/issues/1863
    let pojo = {};
    let error = this;
    for (let key of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDeepKeys"])(error)){
        let value = error[key];
        pojo[key] = value;
    }
    // Don't include the `inspect()` method on the output object,
    // otherwise it will cause `util.inspect()` to go into an infinite loop
    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
    delete pojo[inspectMethod];
    return pojo;
} //# sourceMappingURL=isomorphic.node.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/stack.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isLazyStack",
    ()=>isLazyStack,
    "isWritableStack",
    ()=>isWritableStack,
    "joinStacks",
    ()=>joinStacks,
    "lazyJoinStacks",
    ()=>lazyJoinStacks
]);
const newline = /\r?\n/;
const onoCall = /\bono[ @]/;
function isLazyStack(stackProp) {
    return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
}
function isWritableStack(stackProp) {
    return Boolean(// If there is no stack property, then it's writable, since assigning it will create it
    !stackProp || stackProp.writable || typeof stackProp.set === "function");
}
function joinStacks(newError, originalError) {
    let newStack = popStack(newError.stack);
    let originalStack = originalError ? originalError.stack : undefined;
    if (newStack && originalStack) {
        return newStack + "\n\n" + originalStack;
    } else {
        return newStack || originalStack;
    }
}
function lazyJoinStacks(lazyStack, newError, originalError) {
    if (originalError) {
        Object.defineProperty(newError, "stack", {
            get: ()=>{
                let newStack = lazyStack.get.apply(newError);
                return joinStacks({
                    stack: newStack
                }, originalError);
            },
            enumerable: false,
            configurable: true
        });
    } else {
        lazyPopStack(newError, lazyStack);
    }
}
/**
 * Removes Ono from the stack, so that the stack starts at the original error location
 */ function popStack(stack) {
    if (stack) {
        let lines = stack.split(newline);
        // Find the Ono call(s) in the stack, and remove them
        let onoStart;
        for(let i = 0; i < lines.length; i++){
            let line = lines[i];
            if (onoCall.test(line)) {
                if (onoStart === undefined) {
                    // We found the first Ono call in the stack trace.
                    // There may be other subsequent Ono calls as well.
                    onoStart = i;
                }
            } else if (onoStart !== undefined) {
                // We found the first non-Ono call after one or more Ono calls.
                // So remove the Ono call lines from the stack trace
                lines.splice(onoStart, i - onoStart);
                break;
            }
        }
        if (lines.length > 0) {
            return lines.join("\n");
        }
    }
    // If we get here, then the stack doesn't contain a call to `ono`.
    // This may be due to minification or some optimization of the JS engine.
    // So just return the stack as-is.
    return stack;
}
/**
 * Calls `popStack` lazily, when the `Error.stack` property is accessed.
 */ function lazyPopStack(error, lazyStack) {
    Object.defineProperty(error, "stack", {
        get: ()=>popStack(lazyStack.get.apply(error)),
        enumerable: false,
        configurable: true
    });
} //# sourceMappingURL=stack.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/extend-error.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extendError",
    ()=>extendError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$isomorphic$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/isomorphic.node.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$stack$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/stack.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/to-json.js [app-rsc] (ecmascript)");
;
;
;
const protectedProps = [
    "name",
    "message",
    "stack"
];
function extendError(error, originalError, props) {
    let onoError = error;
    extendStack(onoError, originalError);
    // Copy properties from the original error
    if (originalError && typeof originalError === "object") {
        mergeErrors(onoError, originalError);
    }
    // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.
    // So replace it with one that outputs every property of the error.
    onoError.toJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toJSON"];
    // On Node.js, add support for the `util.inspect()` method
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$isomorphic$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addInspectMethod"]) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$isomorphic$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addInspectMethod"])(onoError);
    }
    // Finally, copy custom properties that were specified by the user.
    // These props OVERWRITE any previous props
    if (props && typeof props === "object") {
        Object.assign(onoError, props);
    }
    return onoError;
}
/**
 * Extend the error stack to include its cause
 */ function extendStack(newError, originalError) {
    let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$stack$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isLazyStack"])(stackProp)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$stack$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["lazyJoinStacks"])(stackProp, newError, originalError);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$stack$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isWritableStack"])(stackProp)) {
        newError.stack = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$stack$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["joinStacks"])(newError, originalError);
    }
}
/**
 * Merges properties of the original error with the new error.
 *
 * @param newError - The error object to extend
 * @param originalError - The original error object, if any
 */ function mergeErrors(newError, originalError) {
    // Get the original error's keys
    // NOTE: We specifically exclude properties that we have already set on the new error.
    // This is _especially_ important for the `stack` property, because this property has
    // a lazy getter in some environments
    let keys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getDeepKeys"])(originalError, protectedProps);
    // HACK: We have to cast the errors to `any` so we can use symbol indexers.
    // see https://github.com/Microsoft/TypeScript/issues/1863
    let _newError = newError;
    let _originalError = originalError;
    for (let key of keys){
        if (_newError[key] === undefined) {
            try {
                _newError[key] = _originalError[key];
            } catch (e) {
            // This property is read-only, so it can't be copied
            }
        }
    }
} //# sourceMappingURL=extend-error.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/normalize.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeArgs",
    ()=>normalizeArgs,
    "normalizeOptions",
    ()=>normalizeOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$isomorphic$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/isomorphic.node.js [app-rsc] (ecmascript)");
;
function normalizeOptions(options) {
    options = options || {};
    return {
        concatMessages: options.concatMessages === undefined ? true : Boolean(options.concatMessages),
        format: options.format === undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$isomorphic$2e$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["format"] : typeof options.format === "function" ? options.format : false
    };
}
function normalizeArgs(args, options) {
    let originalError;
    let props;
    let formatArgs;
    let message = "";
    // Determine which arguments were actually specified
    if (typeof args[0] === "string") {
        formatArgs = args;
    } else if (typeof args[1] === "string") {
        if (args[0] instanceof Error) {
            originalError = args[0];
        } else {
            props = args[0];
        }
        formatArgs = args.slice(1);
    } else {
        originalError = args[0];
        props = args[1];
        formatArgs = args.slice(2);
    }
    // If there are any format arguments, then format the error message
    if (formatArgs.length > 0) {
        if (options.format) {
            message = options.format.apply(undefined, formatArgs);
        } else {
            message = formatArgs.join(" ");
        }
    }
    if (options.concatMessages && originalError && originalError.message) {
        // The inner-error's message will be added to the new message
        message += (message ? " \n" : "") + originalError.message;
    }
    return {
        originalError,
        props,
        message
    };
} //# sourceMappingURL=normalize.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/constructor.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Ono",
    ()=>constructor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$extend$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/extend-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$normalize$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/normalize.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/to-json.js [app-rsc] (ecmascript)");
;
;
;
const constructor = Ono;
;
/**
 * Creates an `Ono` instance for a specifc error type.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function Ono(ErrorConstructor, options) {
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$normalize$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeOptions"])(options);
    function ono(...args) {
        let { originalError, props, message } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$normalize$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeArgs"])(args, options);
        // Create a new error of the specified type
        let newError = new ErrorConstructor(message);
        // Extend the error with the properties of the original error and the `props` object
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$extend$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extendError"])(newError, originalError, props);
    }
    ono[Symbol.species] = ErrorConstructor;
    return ono;
}
/**
 * Returns an object containing all properties of the given Error object,
 * which can be used with `JSON.stringify()`.
 */ Ono.toJSON = function toJSON(error) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$to$2d$json$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["toJSON"].call(error);
};
/**
 * Extends the given Error object with enhanced Ono functionality, such as nested stack traces,
 * additional properties, and improved support for `JSON.stringify()`.
 */ Ono.extend = function extend(error, originalError, props) {
    if (props || originalError instanceof Error) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$extend$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extendError"])(error, originalError, props);
    } else if (originalError) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$extend$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extendError"])(error, undefined, originalError);
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$extend$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extendError"])(error);
    }
}; //# sourceMappingURL=constructor.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/singleton.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ono",
    ()=>singleton
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/constructor.js [app-rsc] (ecmascript)");
;
const singleton = ono;
;
ono.error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](Error);
ono.eval = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](EvalError);
ono.range = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](RangeError);
ono.reference = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](ReferenceError);
ono.syntax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](SyntaxError);
ono.type = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](TypeError);
ono.uri = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"](URIError);
const onoMap = ono;
/**
 * Creates a new error with the specified message, properties, and/or inner error.
 * If an inner error is provided, then the new error will match its type, if possible.
 */ function ono(...args) {
    let originalError = args[0];
    // Is the first argument an Error-like object?
    if (typeof originalError === "object" && typeof originalError.name === "string") {
        // Try to find an Ono singleton method that matches this error type
        for (let typedOno of Object.values(onoMap)){
            if (typeof typedOno === "function" && typedOno.name === "ono") {
                let species = typedOno[Symbol.species];
                if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
                    // Create an error of the same type
                    return typedOno.apply(undefined, args);
                }
            }
        }
    }
    // By default, create a base Error object
    return ono.error.apply(undefined, args);
} //# sourceMappingURL=singleton.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/types.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/util [external] (util, cjs)"); //# sourceMappingURL=types.js.map
;
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* eslint-env commonjs */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/singleton.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/constructor.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/types.js [app-rsc] (ecmascript)");
;
;
;
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ono"];
// CommonJS default export hack
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Ono",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Ono"],
    "default",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"],
    "ono",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ono"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/singleton.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$constructor$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/constructor.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$jsdevtools$2b$ono$40$7$2e$1$2e$3$2f$node_modules$2f40$jsdevtools$2f$ono$2f$esm$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@jsdevtools+ono@7.1.3/node_modules/@jsdevtools/ono/esm/types.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@fumari+json-schema-to-typescript@1.1.3/node_modules/@fumari/json-schema-to-typescript/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_OPTIONS",
    ()=>DEFAULT_OPTIONS,
    "ValidationError",
    ()=>ValidationError,
    "compile",
    ()=>compile,
    "compileJsonFile",
    ()=>compileJsonFile,
    "compileYamlFile",
    ()=>compileYamlFile
]);
// src/resolver.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apidevtools$2b$json$2d$schema$2d$ref$2d$parser$40$11$2e$9$2e$3$2f$node_modules$2f40$apidevtools$2f$json$2d$schema$2d$ref$2d$parser$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@apidevtools+json-schema-ref-parser@11.9.3/node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js [app-rsc] (ecmascript)");
// src/index.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$yaml$40$4$2e$1$2e$0$2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs [app-rsc] (ecmascript)");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator)=>{
    return new Promise((resolve, reject)=>{
        var fulfilled = (value)=>{
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        };
        var rejected = (value)=>{
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        };
        var step = (x)=>x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
    });
};
// src/formatter.ts
function format(code, options) {
    return __async(this, null, function*() {
        if (!options.format) {
            return code;
        }
        const prettier = yield __turbopack_context__.A("[externals]/prettier/standalone [external] (prettier/standalone, esm_import, async loader)");
        return prettier.format(code, __spreadValues({
            parser: "typescript",
            plugins: [
                (yield __turbopack_context__.A("[externals]/prettier/plugins/estree [external] (prettier/plugins/estree, esm_import, async loader)")),
                (yield __turbopack_context__.A("[externals]/prettier/plugins/typescript [external] (prettier/plugins/typescript, esm_import, async loader)"))
            ]
        }, options.style));
    });
}
// src/types/AST.ts
function hasComment(ast) {
    return "comment" in ast && ast.comment != null && ast.comment !== "" || // Compare to true because ast.deprecated might be undefined
    "deprecated" in ast && ast.deprecated === true;
}
function hasStandaloneName(ast) {
    return "standaloneName" in ast && ast.standaloneName != null && ast.standaloneName !== "";
}
var T_ANY = {
    type: "ANY"
};
var T_NULL = {
    type: "NULL"
};
var T_ANY_ADDITIONAL_PROPERTIES = {
    keyName: "[k: string]",
    type: "ANY"
};
var T_UNKNOWN = {
    type: "UNKNOWN"
};
var T_UNKNOWN_ADDITIONAL_PROPERTIES = {
    keyName: "[k: string]",
    type: "UNKNOWN"
};
// src/types/JSONSchema.ts
var Parent = Symbol("Parent");
var Types = Symbol("Types");
var Intersection = Symbol("Intersection");
function getRootSchema(schema) {
    const parent = schema[Parent];
    if (!parent) {
        return schema;
    }
    return getRootSchema(parent);
}
function isBoolean(schema) {
    return schema === true || schema === false;
}
function isPrimitive(schema) {
    return !isPlainObject(schema);
}
function isCompound(schema) {
    return Array.isArray(schema.type) || "anyOf" in schema || "oneOf" in schema;
}
// src/utils.ts
function Try(fn, err) {
    try {
        return fn();
    } catch (e) {
        return err(e);
    }
}
var BLACKLISTED_KEYS = /* @__PURE__ */ new Set([
    "id",
    "$defs",
    "$id",
    "$schema",
    "title",
    "description",
    "default",
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "items",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "definitions",
    "properties",
    "patternProperties",
    "dependencies",
    "enum",
    "type",
    "allOf",
    "anyOf",
    "oneOf",
    "not"
]);
function traverseObjectKeys(obj, callback, processed) {
    Object.keys(obj).forEach((k)=>{
        if (obj[k] && typeof obj[k] === "object" && !Array.isArray(obj[k])) {
            traverse(obj[k], callback, processed, k);
        }
    });
}
function traverseArray(arr, callback, processed) {
    arr.forEach((s, k)=>traverse(s, callback, processed, k.toString()));
}
function traverseIntersection(schema, callback, processed) {
    if (typeof schema !== "object" || !schema) {
        return;
    }
    const r = schema;
    const intersection = r[Intersection];
    if (!intersection) {
        return;
    }
    if (Array.isArray(intersection.allOf)) {
        traverseArray(intersection.allOf, callback, processed);
    }
}
function traverse(schema, callback, processed = /* @__PURE__ */ new Set(), key) {
    if (processed.has(schema)) {
        return;
    }
    processed.add(schema);
    callback(schema, key != null ? key : null);
    if (schema.anyOf) {
        traverseArray(schema.anyOf, callback, processed);
    }
    if (schema.allOf) {
        traverseArray(schema.allOf, callback, processed);
    }
    if (schema.oneOf) {
        traverseArray(schema.oneOf, callback, processed);
    }
    if (schema.properties) {
        traverseObjectKeys(schema.properties, callback, processed);
    }
    if (schema.patternProperties) {
        traverseObjectKeys(schema.patternProperties, callback, processed);
    }
    if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
        traverse(schema.additionalProperties, callback, processed);
    }
    if (schema.items) {
        const { items } = schema;
        if (Array.isArray(items)) {
            traverseArray(items, callback, processed);
        } else {
            traverse(items, callback, processed);
        }
    }
    if (schema.additionalItems && typeof schema.additionalItems === "object") {
        traverse(schema.additionalItems, callback, processed);
    }
    if (schema.dependencies) {
        if (Array.isArray(schema.dependencies)) {
            traverseArray(schema.dependencies, callback, processed);
        } else {
            traverseObjectKeys(schema.dependencies, callback, processed);
        }
    }
    if (schema.definitions) {
        traverseObjectKeys(schema.definitions, callback, processed);
    }
    if (schema.$defs) {
        traverseObjectKeys(schema.$defs, callback, processed);
    }
    if (schema.not) {
        traverse(schema.not, callback, processed);
    }
    traverseIntersection(schema, callback, processed);
    Object.keys(schema).filter((key2)=>!BLACKLISTED_KEYS.has(key2)).forEach((key2)=>{
        const child = schema[key2];
        if (child && typeof child === "object") {
            traverseObjectKeys(child, callback, processed);
        }
    });
}
function toSafeString(str) {
    const value = str.normalize().replace(/[^a-zA-Z0-9_$]/g, " ").replace(/(^\w|\s+\w|_\w|\d\w)/g, (letter)=>{
        if (letter.startsWith("_")) return letter.slice(1).toUpperCase();
        return letter.trim().toUpperCase();
    }).replace(/\s+/g, "").replace(/^\d+/, "");
    return value;
}
function generateName(from, usedNames) {
    let name = toSafeString(from);
    if (!name) {
        name = "NoName";
    }
    if (usedNames.has(name)) {
        let counter = 1;
        let nameWithCounter = `${name}${counter}`;
        while(usedNames.has(nameWithCounter)){
            nameWithCounter = `${name}${counter}`;
            counter++;
        }
        name = nameWithCounter;
    }
    usedNames.add(name);
    return name;
}
function error(...messages) {
    console.error("[error]", ...messages);
}
function log(title, ...messages) {
    if (!process.env.VERBOSE) {
        return;
    }
    let lastMessage = null;
    if (messages.length > 1 && typeof messages[messages.length - 1] !== "string") {
        lastMessage = messages.splice(messages.length - 1, 1);
    }
    console.info(`[debug]`, title, ...messages);
    if (lastMessage) {
        console.dir(lastMessage, {
            depth: 6,
            maxArrayLength: 6
        });
    }
}
function escapeBlockComment(schema) {
    const replacer = "* /";
    if (schema === null || typeof schema !== "object") {
        return;
    }
    for (const key of Object.keys(schema)){
        if (key === "description" && typeof schema[key] === "string") {
            schema[key] = schema[key].replace(/\*\//g, replacer);
        }
    }
}
function maybeStripDefault(schema) {
    if (!("default" in schema)) {
        return schema;
    }
    switch(schema.type){
        case "array":
            if (Array.isArray(schema.default)) {
                return schema;
            }
            break;
        case "boolean":
            if (typeof schema.default === "boolean") {
                return schema;
            }
            break;
        case "integer":
        case "number":
            if (typeof schema.default === "number") {
                return schema;
            }
            break;
        case "string":
            if (typeof schema.default === "string") {
                return schema;
            }
            break;
        case "null":
            if (schema.default === null) {
                return schema;
            }
            break;
        case "object":
            if (isPlainObject(schema.default)) {
                return schema;
            }
            break;
    }
    delete schema.default;
    return schema;
}
function appendToDescription(existingDescription, ...values) {
    if (existingDescription) {
        return `${existingDescription}

${values.join("\n")}`;
    }
    return values.join("\n");
}
function isSchemaLike(schema) {
    if (!isPlainObject(schema) || !schema || typeof schema !== "object") {
        return false;
    }
    const parent = schema[Parent];
    if (parent === null) {
        return true;
    }
    const JSON_SCHEMA_KEYWORDS = [
        "$defs",
        "allOf",
        "anyOf",
        "definitions",
        "dependencies",
        "enum",
        "not",
        "oneOf",
        "patternProperties",
        "properties",
        "required"
    ];
    if (JSON_SCHEMA_KEYWORDS.some((_)=>parent[_] === schema)) {
        return false;
    }
    return true;
}
function omit(obj, ...keys) {
    const result = __spreadValues({}, obj);
    for (const key of keys){
        delete result[key];
    }
    return result;
}
function isPlainObject(value) {
    if (!value || typeof value !== "object") {
        return false;
    }
    const proto = Object.getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.toString.call(Ctor) === Function.prototype.toString.call(Object);
}
function deepMerge(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();
    if (isPlainObject(target) && isPlainObject(source)) {
        const _target = target;
        for(const key in source){
            if (isPlainObject(source[key])) {
                if (!(key in target) || typeof _target[key] !== "object") Object.assign(_target, {
                    [key]: {}
                });
                deepMerge(_target[key], source[key]);
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
            if (Array.isArray(source[key])) {
                if (!Array.isArray(_target[key])) _target[key] = [];
                const arr = _target[key];
                arr.push(source[key]);
            }
        }
    }
    return deepMerge(target, ...sources);
}
// src/generator.ts
function generate(ast, options = DEFAULT_OPTIONS) {
    return [
        options.bannerComment,
        declareNamedTypes(ast, options, ast.standaloneName),
        declareNamedInterfaces(ast, options, ast.standaloneName),
        declareEnums(ast, options)
    ].filter(Boolean).join("\n\n") + "\n";
}
function declareEnums(ast, options, processed = /* @__PURE__ */ new Set()) {
    if (processed.has(ast)) {
        return "";
    }
    processed.add(ast);
    let type = "";
    switch(ast.type){
        case "ENUM":
            return generateStandaloneEnum(ast, options) + "\n";
        case "ARRAY":
            return declareEnums(ast.params, options, processed);
        case "UNION":
        case "INTERSECTION":
            return ast.params.reduce((prev, ast2)=>prev + declareEnums(ast2, options, processed), "");
        case "TUPLE":
            type = ast.params.reduce((prev, ast2)=>prev + declareEnums(ast2, options, processed), "");
            if (ast.spreadParam) {
                type += declareEnums(ast.spreadParam, options, processed);
            }
            return type;
        case "INTERFACE":
            return getSuperTypesAndParams(ast).reduce((prev, ast2)=>prev + declareEnums(ast2, options, processed), "");
        default:
            return "";
    }
}
function declareNamedInterfaces(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {
    if (processed.has(ast)) {
        return "";
    }
    processed.add(ast);
    let type = "";
    switch(ast.type){
        case "ARRAY":
            type = declareNamedInterfaces(ast.params, options, rootASTName, processed);
            break;
        case "INTERFACE":
            type = [
                hasStandaloneName(ast) && (ast.standaloneName === rootASTName || options.declareExternallyReferenced) && generateStandaloneInterface(ast, options),
                getSuperTypesAndParams(ast).map((ast2)=>declareNamedInterfaces(ast2, options, rootASTName, processed)).filter(Boolean).join("\n")
            ].filter(Boolean).join("\n");
            break;
        case "INTERSECTION":
        case "TUPLE":
        case "UNION":
            type = ast.params.map((_)=>declareNamedInterfaces(_, options, rootASTName, processed)).filter(Boolean).join("\n");
            if (ast.type === "TUPLE" && ast.spreadParam) {
                type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);
            }
            break;
        default:
            type = "";
    }
    return type;
}
function declareNamedTypes(ast, options, rootASTName, processed = /* @__PURE__ */ new Set()) {
    if (processed.has(ast)) {
        return "";
    }
    processed.add(ast);
    switch(ast.type){
        case "ARRAY":
            return [
                declareNamedTypes(ast.params, options, rootASTName, processed),
                hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0
            ].filter(Boolean).join("\n");
        case "ENUM":
            return "";
        case "INTERFACE":
            return getSuperTypesAndParams(ast).map((ast2)=>(ast2.standaloneName === rootASTName || options.declareExternallyReferenced) && declareNamedTypes(ast2, options, rootASTName, processed)).filter(Boolean).join("\n");
        case "INTERSECTION":
        case "TUPLE":
        case "UNION":
            return [
                hasStandaloneName(ast) ? generateStandaloneType(ast, options) : void 0,
                ast.params.map((ast2)=>declareNamedTypes(ast2, options, rootASTName, processed)).filter(Boolean).join("\n"),
                "spreadParam" in ast && ast.spreadParam ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed) : void 0
            ].filter(Boolean).join("\n");
        default:
            if (hasStandaloneName(ast)) {
                return generateStandaloneType(ast, options);
            }
            return "";
    }
}
function generateType(ast, options) {
    const type = generateRawType(ast, options);
    if (options.strictIndexSignatures && ast.keyName === "[k: string]" && ast.type !== "UNKNOWN" && ast.type !== "ANY") {
        return `${type} | undefined`;
    }
    return type;
}
function generateRawType(ast, options) {
    log("generator", ast);
    if (hasStandaloneName(ast)) {
        return toSafeString(ast.standaloneName);
    }
    switch(ast.type){
        case "ANY":
            return "any";
        case "ARRAY":
            return (()=>{
                const type = generateType(ast.params, options);
                return type.endsWith('"') ? "(" + type + ")[]" : type + "[]";
            })();
        case "BOOLEAN":
            return "boolean";
        case "INTERFACE":
            return generateInterface(ast, options);
        case "INTERSECTION":
            return generateSetOperation(ast, options);
        case "LITERAL":
            return JSON.stringify(ast.params);
        case "NEVER":
            return "never";
        case "NUMBER":
            return "number";
        case "NULL":
            return "null";
        case "OBJECT":
            return "object";
        case "REFERENCE":
            return ast.params;
        case "STRING":
            return "string";
        case "TUPLE":
            return (()=>{
                const minItems = ast.minItems;
                const maxItems = ast.maxItems || -1;
                let spreadParam = ast.spreadParam;
                const astParams = [
                    ...ast.params
                ];
                if (minItems > 0 && minItems > astParams.length && ast.spreadParam === void 0) {
                    if (maxItems < 0) {
                        spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;
                    }
                }
                if (maxItems > astParams.length && ast.spreadParam === void 0) {
                    for(let i = astParams.length; i < maxItems; i += 1){
                        astParams.push(options.unknownAny ? T_UNKNOWN : T_ANY);
                    }
                }
                function addSpreadParam(params) {
                    if (spreadParam) {
                        const spread = "...(" + generateType(spreadParam, options) + ")[]";
                        params.push(spread);
                    }
                    return params;
                }
                function paramsToString(params) {
                    return "[" + params.join(", ") + "]";
                }
                const paramsList = astParams.map((param)=>generateType(param, options));
                if (paramsList.length > minItems) {
                    const cumulativeParamsList = paramsList.slice(0, minItems);
                    const typesToUnion = [];
                    if (cumulativeParamsList.length > 0) {
                        typesToUnion.push(paramsToString(cumulativeParamsList));
                    } else {
                        typesToUnion.push(paramsToString([]));
                    }
                    for(let i = minItems; i < paramsList.length; i += 1){
                        cumulativeParamsList.push(paramsList[i]);
                        if (i === paramsList.length - 1) {
                            addSpreadParam(cumulativeParamsList);
                        }
                        typesToUnion.push(paramsToString(cumulativeParamsList));
                    }
                    return typesToUnion.join("|");
                }
                return paramsToString(addSpreadParam(paramsList));
            })();
        case "UNION":
            return generateSetOperation(ast, options);
        case "UNKNOWN":
            return "unknown";
        case "CUSTOM_TYPE":
            return ast.params;
    }
}
function generateSetOperation(ast, options) {
    const members = ast.params.map((_)=>generateType(_, options));
    const separator = ast.type === "UNION" ? "|" : "&";
    return members.length === 1 ? members[0] : "(" + members.join(" " + separator + " ") + ")";
}
function generateInterface(ast, options) {
    return `{
` + ast.params.filter((_)=>!_.isPatternProperty && !_.isUnreachableDefinition).map(({ isRequired, keyName, ast: ast2 })=>[
            isRequired,
            keyName,
            ast2,
            generateType(ast2, options)
        ]).map(([isRequired, keyName, ast2, type])=>(hasComment(ast2) && !ast2.standaloneName ? generateComment(ast2.comment, ast2.deprecated) + "\n" : "") + escapeKeyName(keyName) + (isRequired ? "" : "?") + ": " + type).join("\n") + "\n}";
}
function generateComment(comment, deprecated) {
    const commentLines = [
        "/**"
    ];
    if (deprecated) {
        commentLines.push(" * @deprecated");
    }
    if (typeof comment !== "undefined") {
        commentLines.push(...comment.split("\n").map((_)=>" * " + _));
    }
    commentLines.push(" */");
    return commentLines.join("\n");
}
function generateStandaloneEnum(ast, options) {
    return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + "\n" : "") + "export " + (options.enableConstEnums ? "const " : "") + `enum ${toSafeString(ast.standaloneName)} {
` + ast.params.map(({ ast: ast2, keyName })=>keyName + " = " + generateType(ast2, options)).join(",\n") + "\n}";
}
function generateStandaloneInterface(ast, options) {
    return (hasComment(ast) ? generateComment(ast.comment, ast.deprecated) + "\n" : "") + `export interface ${toSafeString(ast.standaloneName)} ` + (ast.superTypes.length > 0 ? `extends ${ast.superTypes.map((superType)=>toSafeString(superType.standaloneName)).join(", ")} ` : "") + generateInterface(ast, options);
}
function generateStandaloneType(ast, options) {
    return (hasComment(ast) ? generateComment(ast.comment) + "\n" : "") + `export type ${toSafeString(ast.standaloneName)} = ${generateType(omit(ast, "standaloneName"), options)}`;
}
function escapeKeyName(keyName) {
    if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\w$]+$/.test(keyName)) {
        return keyName;
    }
    if (keyName === "[k: string]") {
        return keyName;
    }
    return JSON.stringify(keyName);
}
function getSuperTypesAndParams(ast) {
    return ast.params.map((param)=>param.ast).concat(ast.superTypes);
}
// src/typesOfSchema.ts
function typesOfSchema(schema) {
    if (schema.tsType) {
        return /* @__PURE__ */ new Set([
            "CUSTOM_TYPE"
        ]);
    }
    const matchedTypes = /* @__PURE__ */ new Set();
    for (const [schemaType, f] of Object.entries(matchers)){
        if (f(schema)) {
            matchedTypes.add(schemaType);
        }
    }
    if (!matchedTypes.size) {
        matchedTypes.add("UNNAMED_SCHEMA");
    }
    return matchedTypes;
}
var matchers = {
    ALL_OF (schema) {
        return "allOf" in schema;
    },
    ANY (schema) {
        if (Object.keys(schema).length === 0) {
            return true;
        }
        return schema.type === "any";
    },
    ANY_OF (schema) {
        return "anyOf" in schema;
    },
    BOOLEAN (schema) {
        if ("enum" in schema) {
            return false;
        }
        if (schema.type === "boolean") {
            return true;
        }
        if (!isCompound(schema) && typeof schema.default === "boolean") {
            return true;
        }
        return false;
    },
    CUSTOM_TYPE () {
        return false;
    },
    NAMED_ENUM (schema) {
        return "enum" in schema && "tsEnumNames" in schema;
    },
    NAMED_SCHEMA (schema) {
        return "$id" in schema && ("patternProperties" in schema || "properties" in schema);
    },
    NEVER (schema) {
        return schema === false;
    },
    NULL (schema) {
        return schema.type === "null";
    },
    NUMBER (schema) {
        if ("enum" in schema) {
            return false;
        }
        if (schema.type === "integer" || schema.type === "number") {
            return true;
        }
        if (!isCompound(schema) && typeof schema.default === "number") {
            return true;
        }
        return false;
    },
    OBJECT (schema) {
        return schema.type === "object" && !isPlainObject(schema.additionalProperties) && !schema.allOf && !schema.anyOf && !schema.oneOf && !schema.patternProperties && !schema.properties && !schema.required;
    },
    ONE_OF (schema) {
        return "oneOf" in schema;
    },
    REFERENCE (schema) {
        return "$ref" in schema;
    },
    STRING (schema) {
        if ("enum" in schema) {
            return false;
        }
        if (schema.type === "string") {
            return true;
        }
        if (!isCompound(schema) && typeof schema.default === "string") {
            return true;
        }
        return false;
    },
    TYPED_ARRAY (schema) {
        if (schema.type && schema.type !== "array") {
            return false;
        }
        return "items" in schema;
    },
    UNION (schema) {
        return Array.isArray(schema.type);
    },
    UNNAMED_ENUM (schema) {
        if ("tsEnumNames" in schema) {
            return false;
        }
        if (schema.type && schema.type !== "boolean" && schema.type !== "integer" && schema.type !== "number" && schema.type !== "string") {
            return false;
        }
        return "enum" in schema;
    },
    UNNAMED_SCHEMA () {
        return false;
    },
    UNTYPED_ARRAY (schema) {
        return schema.type === "array" && !("items" in schema);
    }
};
// src/applySchemaTyping.ts
function applySchemaTyping(schema) {
    var _a;
    const types = typesOfSchema(schema);
    Object.assign(schema, {
        [Types]: types
    });
    if (types.size === 1) {
        return;
    }
    const intersection = {
        [Parent]: schema,
        [Types]: /* @__PURE__ */ new Set([
            "ALL_OF"
        ]),
        $id: schema.$id,
        description: schema.description,
        name: schema.name,
        title: schema.title,
        allOf: (_a = schema.allOf) != null ? _a : [],
        required: [],
        additionalProperties: false
    };
    types.delete("ALL_OF");
    delete schema.allOf;
    delete schema.$id;
    delete schema.description;
    delete schema.name;
    delete schema.title;
    Object.assign(schema, {
        [Intersection]: intersection
    });
}
// src/normalizer.ts
var rules = /* @__PURE__ */ new Map();
function hasType(schema, type) {
    return schema.type === type || Array.isArray(schema.type) && schema.type.includes(type);
}
function isObjectType(schema) {
    return schema.properties !== void 0 || hasType(schema, "object") || hasType(schema, "any");
}
function isArrayType(schema) {
    return schema.items !== void 0 || hasType(schema, "array") || hasType(schema, "any");
}
function isEnumTypeWithoutTsEnumNames(schema) {
    return schema.type === "string" && schema.enum !== void 0 && schema.tsEnumNames === void 0;
}
function normalizeName(filename) {
    const name = filename.split("/").at(-1);
    if (!name) return filename;
    const dotIdx = name.lastIndexOf(".");
    if (dotIdx === -1) return name;
    return name.slice(0, dotIdx);
}
rules.set('Remove `type=["null"]` if `enum=[null]`', (schema)=>{
    if (Array.isArray(schema.enum) && schema.enum.some((e)=>e === null) && Array.isArray(schema.type) && schema.type.includes("null")) {
        schema.type = schema.type.filter((type)=>type !== "null");
    }
});
rules.set('Convert nullable to type: [..., "null"]', (schema)=>{
    if (schema.nullable && schema.type !== void 0) {
        if (!Array.isArray(schema.type)) {
            schema.type = [
                schema.type
            ];
        }
        schema.type.push("null");
        delete schema.nullable;
    }
});
rules.set("Destructure unary types", (schema)=>{
    if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
        schema.type = schema.type[0];
    }
});
rules.set("Add empty `required` property if none is defined", (schema)=>{
    if (isObjectType(schema) && !("required" in schema)) {
        schema.required = [];
    }
});
rules.set("Transform `required`=false to `required`=[]", (schema)=>{
    if (schema.required === false) {
        schema.required = [];
    }
});
rules.set("Default additionalProperties", (schema, _, options)=>{
    if (isObjectType(schema) && !("additionalProperties" in schema) && schema.patternProperties === void 0) {
        schema.additionalProperties = options.additionalProperties;
    }
});
rules.set("Transform id to $id", (schema, fileName)=>{
    if (!isSchemaLike(schema)) {
        return;
    }
    if (schema.id && schema.$id && schema.id !== schema.$id) {
        throw ReferenceError(`Schema must define either id or $id, not both. Given id=${schema.id}, $id=${schema.$id} in ${fileName}`);
    }
    if (schema.id) {
        schema.$id = schema.id;
        delete schema.id;
    }
});
rules.set("Add an $id to anything that needs it", (schema, fileName, _options, _key, dereferencedPaths)=>{
    if (!isSchemaLike(schema)) {
        return;
    }
    if (!schema.$id && !schema[Parent]) {
        schema.$id = toSafeString(normalizeName(fileName));
        return;
    }
    if (!dereferencedPaths) return;
    if (!isArrayType(schema) && !isObjectType(schema)) {
        return;
    }
    const dereferencedName = dereferencedPaths.get(schema);
    if (!schema.$id && !schema.title && dereferencedName) {
        schema.$id = toSafeString(normalizeName(dereferencedName));
    }
    if (dereferencedName) {
        dereferencedPaths.delete(schema);
    }
});
rules.set("Escape closing JSDoc comment", (schema)=>{
    escapeBlockComment(schema);
});
rules.set("Add JSDoc comments for minItems and maxItems", (schema)=>{
    if (!isArrayType(schema)) {
        return;
    }
    const commentsToAppend = [
        "minItems" in schema ? `@minItems ${schema.minItems}` : "",
        "maxItems" in schema ? `@maxItems ${schema.maxItems}` : ""
    ].filter(Boolean);
    if (commentsToAppend.length) {
        schema.description = appendToDescription(schema.description, ...commentsToAppend);
    }
});
rules.set("Optionally remove maxItems and minItems", (schema, _fileName, options)=>{
    if (!isArrayType(schema)) {
        return;
    }
    if ("minItems" in schema && options.ignoreMinAndMaxItems) {
        delete schema.minItems;
    }
    if ("maxItems" in schema && (options.ignoreMinAndMaxItems || options.maxItems === -1)) {
        delete schema.maxItems;
    }
});
rules.set("Normalize schema.minItems", (schema, _fileName, options)=>{
    if (options.ignoreMinAndMaxItems) {
        return;
    }
    if (!isArrayType(schema)) {
        return;
    }
    const { minItems } = schema;
    schema.minItems = typeof minItems === "number" ? minItems : 0;
});
rules.set("Remove maxItems if it is big enough to likely cause OOMs", (schema, _fileName, options)=>{
    if (options.ignoreMinAndMaxItems || options.maxItems === -1) {
        return;
    }
    if (!isArrayType(schema)) {
        return;
    }
    const { maxItems, minItems } = schema;
    if (maxItems !== void 0 && maxItems - minItems > options.maxItems) {
        delete schema.maxItems;
    }
});
rules.set("Normalize schema.items", (schema, _fileName, options)=>{
    if (options.ignoreMinAndMaxItems) {
        return;
    }
    const { maxItems, minItems } = schema;
    const hasMaxItems = typeof maxItems === "number" && maxItems >= 0;
    const hasMinItems = typeof minItems === "number" && minItems > 0;
    if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {
        const items = schema.items;
        const newItems = Array(maxItems || minItems || 0).fill(items);
        if (!hasMaxItems) {
            schema.additionalItems = items;
        }
        schema.items = newItems;
    }
    if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {
        schema.items = schema.items.slice(0, maxItems);
    }
    return schema;
});
rules.set("Remove extends, if it is empty", (schema)=>{
    if (!schema.hasOwnProperty("extends")) {
        return;
    }
    if (schema.extends == null || Array.isArray(schema.extends) && schema.extends.length === 0) {
        delete schema.extends;
    }
});
rules.set("Make extends always an array, if it is defined", (schema)=>{
    if (schema.extends == null) {
        return;
    }
    if (!Array.isArray(schema.extends)) {
        schema.extends = [
            schema.extends
        ];
    }
});
rules.set("Transform definitions to $defs", (schema, fileName)=>{
    if (schema.definitions && schema.$defs) {
        throw ReferenceError(`Schema must define either definitions or $defs, not both. Given id=${schema.id} in ${fileName}`);
    }
    if (schema.definitions) {
        schema.$defs = schema.definitions;
        delete schema.definitions;
    }
});
rules.set("Transform const to singleton enum", (schema)=>{
    if (schema.const !== void 0) {
        schema.enum = [
            schema.const
        ];
        delete schema.const;
    }
});
rules.set("Add tsEnumNames to enum types", (schema, _, options)=>{
    var _a;
    if (isEnumTypeWithoutTsEnumNames(schema) && options.inferStringEnumKeysFromValues) {
        schema.tsEnumNames = (_a = schema.enum) == null ? void 0 : _a.map(String);
    }
});
rules.set("Pre-calculate schema types and intersections", (schema)=>{
    if (schema !== null && typeof schema === "object") {
        applySchemaTyping(schema);
    }
});
function normalize(rootSchema, dereferencedPaths, filename, options) {
    rules.forEach((rule)=>traverse(rootSchema, (schema, key)=>rule(schema, filename, options, key, dereferencedPaths)));
    return rootSchema;
}
// src/optimizer.ts
function optimize(ast, options, processed = /* @__PURE__ */ new Set()) {
    if (processed.has(ast)) {
        return ast;
    }
    processed.add(ast);
    switch(ast.type){
        case "ARRAY":
            return Object.assign(ast, {
                params: optimize(ast.params, options, processed)
            });
        case "INTERFACE":
            return Object.assign(ast, {
                params: ast.params.map((_)=>Object.assign(_, {
                        ast: optimize(_.ast, options, processed)
                    }))
            });
        case "INTERSECTION":
        case "UNION":
            const optimizedAST = Object.assign(ast, {
                params: ast.params.map((_)=>optimize(_, options, processed))
            });
            if (optimizedAST.params.some((_)=>_.type === "ANY")) {
                log("optimizer", "[A, B, C, Any] -> Any", optimizedAST);
                return T_ANY;
            }
            if (optimizedAST.params.some((_)=>_.type === "UNKNOWN")) {
                log("optimizer", "[A, B, C, Unknown] -> Unknown", optimizedAST);
                return T_UNKNOWN;
            }
            if (optimizedAST.params.every((_)=>{
                const a = generateType(omitStandaloneName(_), options);
                const b = generateType(omitStandaloneName(optimizedAST.params[0]), options);
                return a === b;
            }) && optimizedAST.params.some((_)=>_.standaloneName !== void 0)) {
                log("optimizer", "[A (named), A] -> [A (named)]", optimizedAST);
                optimizedAST.params = optimizedAST.params.filter((_)=>_.standaloneName !== void 0);
            }
            const params = deduplicate(optimizedAST.params, (item)=>generateType(item, options));
            if (params.length !== optimizedAST.params.length) {
                log("optimizer", "[A, B, B] -> [A, B]", optimizedAST);
                optimizedAST.params = params;
            }
            return Object.assign(optimizedAST, {
                params: optimizedAST.params.map((_)=>optimize(_, options, processed))
            });
        default:
            return ast;
    }
}
function omitStandaloneName(ast) {
    switch(ast.type){
        case "ENUM":
            return ast;
        default:
            return __spreadProps(__spreadValues({}, ast), {
                standaloneName: void 0
            });
    }
}
function deduplicate(asts, hasher) {
    const out = [];
    const added = /* @__PURE__ */ new Set();
    for (const item of asts){
        const hash = hasher(item);
        if (added.has(hash)) continue;
        added.add(hash);
        out.push(item);
    }
    return out;
}
// src/parser.ts
function parse(schema, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {
    if (isPrimitive(schema)) {
        if (isBoolean(schema)) {
            return parseBooleanSchema(schema, keyName, options);
        }
        return parseLiteral(schema, keyName);
    }
    const intersection = schema[Intersection];
    const types = schema[Types];
    if (intersection) {
        const ast = parseAsTypeWithCache(intersection, "ALL_OF", options, keyName, processed, usedNames);
        types.forEach((type)=>{
            ast.params.push(parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames));
        });
        log("parser", "Types:", [
            ...types
        ], "Input:", schema, "Output:", ast);
        return ast;
    }
    if (types.size === 1) {
        const type = [
            ...types
        ][0];
        const ast = parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames);
        log("parser", "Type:", type, "Input:", schema, "Output:", ast);
        return ast;
    }
    throw new ReferenceError("Expected intersection schema. Please file an issue on GitHub.");
}
function parseAsTypeWithCache(schema, type, options, keyName, processed = /* @__PURE__ */ new Map(), usedNames = /* @__PURE__ */ new Set()) {
    let cachedTypeMap = processed.get(schema);
    if (!cachedTypeMap) {
        cachedTypeMap = /* @__PURE__ */ new Map();
        processed.set(schema, cachedTypeMap);
    }
    const cachedAST = cachedTypeMap.get(type);
    if (cachedAST) {
        return cachedAST;
    }
    const ast = {};
    cachedTypeMap.set(type, ast);
    return Object.assign(ast, parseNonLiteral(schema, type, options, keyName, processed, usedNames));
}
function parseBooleanSchema(schema, keyName, options) {
    if (schema) {
        return {
            keyName,
            type: options.unknownAny ? "UNKNOWN" : "ANY"
        };
    }
    return {
        keyName,
        type: "NEVER"
    };
}
function parseLiteral(schema, keyName) {
    return {
        keyName,
        params: schema,
        type: "LITERAL"
    };
}
function parseNonLiteral(schema, type, options, keyName, processed, usedNames) {
    const definitions = getDefinitions(getRootSchema(schema));
    const keyNameFromDefinition = Array.from(Object.keys(definitions)).find((k)=>definitions[k] === schema);
    switch(type){
        case "ALL_OF":
            {
                const hasNullable = schema.allOf.some((s)=>s.nullable && s.type === void 0);
                const params = schema.allOf.filter((s)=>!s.nullable || s.type !== void 0).map((_)=>parse(_, options, void 0, processed, usedNames));
                const baseAst = {
                    comment: schema.description,
                    deprecated: schema.deprecated,
                    keyName,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options)
                };
                if (!hasNullable) {
                    return __spreadProps(__spreadValues({}, baseAst), {
                        type: "INTERSECTION",
                        params
                    });
                }
                if (params.length === 0) {
                    return __spreadProps(__spreadValues({}, baseAst), {
                        type: "NULL"
                    });
                } else if (params.length === 1) {
                    return __spreadProps(__spreadValues({}, baseAst), {
                        type: "UNION",
                        params: [
                            params[0],
                            T_NULL
                        ]
                    });
                } else {
                    return __spreadProps(__spreadValues({}, baseAst), {
                        type: "UNION",
                        params: [
                            {
                                type: "INTERSECTION",
                                params
                            },
                            T_NULL
                        ]
                    });
                }
            }
        case "ANY":
            return __spreadProps(__spreadValues({}, options.unknownAny ? T_UNKNOWN : T_ANY), {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options)
            });
        case "ANY_OF":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                params: schema.anyOf.map((_)=>parse(_, options, void 0, processed, usedNames)),
                type: "UNION"
            };
        case "BOOLEAN":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "BOOLEAN"
            };
        case "CUSTOM_TYPE":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                params: schema.tsType,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "CUSTOM_TYPE"
            };
        case "NAMED_ENUM":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition != null ? keyNameFromDefinition : keyName, usedNames, options),
                params: schema.enum.map((_, n)=>({
                        ast: parseLiteral(_, void 0),
                        keyName: schema.tsEnumNames[n]
                    })),
                type: "ENUM"
            };
        case "NAMED_SCHEMA":
            return newInterface(schema, options, processed, usedNames, keyName);
        case "NEVER":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "NEVER"
            };
        case "NULL":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "NULL"
            };
        case "NUMBER":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "NUMBER"
            };
        case "OBJECT":
            return {
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "OBJECT",
                deprecated: schema.deprecated
            };
        case "ONE_OF":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                params: schema.oneOf.map((_)=>parse(_, options, void 0, processed, usedNames)),
                type: "UNION"
            };
        case "REFERENCE":
            throw Error("Refs should have been resolved by the resolver!");
        case "STRING":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                type: "STRING"
            };
        case "TYPED_ARRAY":
            if (Array.isArray(schema.items)) {
                const minItems = schema.minItems;
                const maxItems = schema.maxItems;
                const arrayType = {
                    comment: schema.description,
                    deprecated: schema.deprecated,
                    keyName,
                    maxItems,
                    minItems,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                    params: schema.items.map((_)=>parse(_, options, void 0, processed, usedNames)),
                    type: "TUPLE"
                };
                if (schema.additionalItems === true) {
                    arrayType.spreadParam = options.unknownAny ? T_UNKNOWN : T_ANY;
                } else if (schema.additionalItems) {
                    arrayType.spreadParam = parse(schema.additionalItems, options, void 0, processed, usedNames);
                }
                return arrayType;
            } else {
                return {
                    comment: schema.description,
                    deprecated: schema.deprecated,
                    keyName,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                    params: parse(schema.items, options, `{keyNameFromDefinition}Items`, processed, usedNames),
                    type: "ARRAY"
                };
            }
        case "UNION":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                params: schema.type.map((type2)=>{
                    const member = __spreadProps(__spreadValues({}, omit(schema, "$id", "description", "title")), {
                        type: type2
                    });
                    maybeStripDefault(member);
                    applySchemaTyping(member);
                    return parse(member, options, void 0, processed, usedNames);
                }),
                type: "UNION"
            };
        case "UNNAMED_ENUM":
            return {
                comment: schema.description,
                deprecated: schema.deprecated,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                params: schema.enum.map((_)=>parseLiteral(_, void 0)),
                type: "UNION"
            };
        case "UNNAMED_SCHEMA":
            return newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition);
        case "UNTYPED_ARRAY":
            {
                const minItems = schema.minItems;
                const maxItems = typeof schema.maxItems === "number" ? schema.maxItems : -1;
                const params = options.unknownAny ? T_UNKNOWN : T_ANY;
                if (minItems > 0 || maxItems >= 0) {
                    return {
                        comment: schema.description,
                        deprecated: schema.deprecated,
                        keyName,
                        maxItems: schema.maxItems,
                        minItems,
                        // create a tuple of length N
                        params: Array(Math.max(maxItems, minItems) || 0).fill(params),
                        // if there is no maximum, then add a spread item to collect the rest
                        spreadParam: maxItems >= 0 ? void 0 : params,
                        standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                        type: "TUPLE"
                    };
                }
                return {
                    comment: schema.description,
                    deprecated: schema.deprecated,
                    keyName,
                    params,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames, options),
                    type: "ARRAY"
                };
            }
    }
}
function standaloneName(schema, keyNameFromDefinition, usedNames, options) {
    var _a;
    const name = ((_a = options.customName) == null ? void 0 : _a.call(options, schema, keyNameFromDefinition)) || schema.title || schema.$id || keyNameFromDefinition;
    if (name) {
        return generateName(name, usedNames);
    }
}
function newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition) {
    const name = standaloneName(schema, keyNameFromDefinition, usedNames, options);
    return {
        comment: schema.description,
        deprecated: schema.deprecated,
        keyName,
        params: parseSchema(schema, options, processed, usedNames, name),
        standaloneName: name,
        superTypes: parseSuperTypes(schema, options, processed, usedNames),
        type: "INTERFACE"
    };
}
function parseSuperTypes(schema, options, processed, usedNames) {
    const superTypes = schema.extends;
    if (!superTypes) {
        return [];
    }
    return superTypes.map((_)=>parse(_, options, void 0, processed, usedNames));
}
function parseSchema(schema, options, processed, usedNames, parentSchemaName) {
    var _a, _b;
    let asts = Array.from(Object.entries((_a = schema.properties) != null ? _a : {})).map(([key, value])=>{
        var _a2;
        return {
            ast: parse(value, options, key, processed, usedNames),
            isPatternProperty: false,
            isRequired: ((_a2 = schema.required) != null ? _a2 : []).includes(key),
            isUnreachableDefinition: false,
            keyName: key
        };
    });
    let singlePatternProperty = false;
    if (schema.patternProperties) {
        singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;
        asts = asts.concat(Array.from(Object.entries(schema.patternProperties)).map(([key, value])=>{
            var _a2;
            const ast = parse(value, options, key, processed, usedNames);
            const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema definition
via the \`patternProperty\` "${key.replace("*/", "*\\/")}".`;
            ast.comment = ast.comment ? `${ast.comment}

${comment}` : comment;
            return {
                ast,
                isPatternProperty: !singlePatternProperty,
                isRequired: singlePatternProperty || ((_a2 = schema.required) != null ? _a2 : []).includes(key),
                isUnreachableDefinition: false,
                keyName: singlePatternProperty ? "[k: string]" : key
            };
        }));
    }
    if (options.unreachableDefinitions) {
        asts = asts.concat(Array.from(Object.entries((_b = schema.$defs) != null ? _b : {})).map(([key, value])=>{
            var _a2;
            const ast = parse(value, options, key, processed, usedNames);
            const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema
via the \`definition\` "${key}".`;
            ast.comment = ast.comment ? `${ast.comment}

${comment}` : comment;
            return {
                ast,
                isPatternProperty: false,
                isRequired: ((_a2 = schema.required) != null ? _a2 : []).includes(key),
                isUnreachableDefinition: true,
                keyName: key
            };
        }));
    }
    switch(schema.additionalProperties){
        case void 0:
        case true:
            if (singlePatternProperty) {
                return asts;
            }
            return asts.concat({
                ast: options.unknownAny ? T_UNKNOWN_ADDITIONAL_PROPERTIES : T_ANY_ADDITIONAL_PROPERTIES,
                isPatternProperty: false,
                isRequired: true,
                isUnreachableDefinition: false,
                keyName: "[k: string]"
            });
        case false:
            return asts;
        // pass "true" as the last param because in TS, properties
        // defined via index signatures are already optional
        default:
            return asts.concat({
                ast: parse(schema.additionalProperties, options, "[k: string]", processed, usedNames),
                isPatternProperty: false,
                isRequired: true,
                isUnreachableDefinition: false,
                keyName: "[k: string]"
            });
    }
}
var cacheList = [];
function getDefinitions(schema, isSchema = true, processed = /* @__PURE__ */ new Set()) {
    var _a;
    if (processed.has(schema)) {
        return {};
    }
    const cached = (_a = cacheList.findLast((item)=>item[0] === schema)) == null ? void 0 : _a[1];
    if (cached) return cached;
    let result = {};
    processed.add(schema);
    if (Array.isArray(schema)) {
        result = schema.reduce((prev, cur)=>__spreadValues(__spreadValues({}, prev), getDefinitions(cur, false, processed)), {});
    } else if (isPlainObject(schema)) {
        result = __spreadValues(__spreadValues({}, isSchema && hasDefinitions(schema) ? schema.$defs : {}), Object.keys(schema).reduce((prev, cur)=>__spreadValues(__spreadValues({}, prev), getDefinitions(schema[cur], false, processed)), {}));
    }
    cacheList.push([
        schema,
        result
    ]);
    if (cacheList.length > 100) cacheList.shift();
    return result;
}
function hasDefinitions(schema) {
    return "$defs" in schema;
}
;
function dereference(schema, cwd, options) {
    return __async(this, null, function*() {
        log("dereferencer", "Dereferencing input schema:", cwd, schema);
        const dereferencedPaths = /* @__PURE__ */ new WeakMap();
        const dereferencedSchema = yield __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$apidevtools$2b$json$2d$schema$2d$ref$2d$parser$40$11$2e$9$2e$3$2f$node_modules$2f40$apidevtools$2f$json$2d$schema$2d$ref$2d$parser$2f$dist$2f$lib$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].dereference(cwd, schema, __spreadProps(__spreadValues({}, options), {
            mutateInputSchema: false,
            dereference: __spreadProps(__spreadValues({}, options.dereference), {
                onDereference ($ref, schema2) {
                    dereferencedPaths.set(schema2, $ref);
                }
            })
        }));
        return {
            dereferencedPaths,
            dereferencedSchema
        };
    });
}
// src/validator.ts
var rules2 = /* @__PURE__ */ new Map();
rules2.set("Enum members and tsEnumNames must be of the same length", (schema)=>{
    if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {
        return false;
    }
});
rules2.set("tsEnumNames must be an array of strings", (schema)=>{
    if (schema.tsEnumNames && schema.tsEnumNames.some((_)=>typeof _ !== "string")) {
        return false;
    }
});
rules2.set("When both maxItems and minItems are present, maxItems >= minItems", (schema)=>{
    const { maxItems, minItems } = schema;
    if (typeof maxItems === "number" && typeof minItems === "number") {
        return maxItems >= minItems;
    }
});
rules2.set("When maxItems exists, maxItems >= 0", (schema)=>{
    const { maxItems } = schema;
    if (typeof maxItems === "number") {
        return maxItems >= 0;
    }
});
rules2.set("When minItems exists, minItems >= 0", (schema)=>{
    const { minItems } = schema;
    if (typeof minItems === "number") {
        return minItems >= 0;
    }
});
rules2.set("deprecated must be a boolean", (schema)=>{
    const typeOfDeprecated = typeof schema.deprecated;
    return typeOfDeprecated === "boolean" || typeOfDeprecated === "undefined";
});
function validate(schema, filename) {
    const errors = [];
    rules2.forEach((rule, ruleName)=>{
        traverse(schema, (schema2, key)=>{
            if (rule(schema2) === false) {
                errors.push(`Error at key "${key}" in file "${filename}": ${ruleName}`);
            }
            return schema2;
        });
    });
    return errors;
}
// src/linker.ts
function link(schema, parent = null) {
    if (!Array.isArray(schema) && !isPlainObject(schema)) {
        return schema;
    }
    if (schema.hasOwnProperty(Parent)) {
        return schema;
    }
    if (schema) Object.assign(schema, {
        [Parent]: parent
    });
    if (Array.isArray(schema)) {
        schema.forEach((child)=>link(child, schema));
    }
    for(const key in schema){
        link(schema[key], schema);
    }
    return schema;
}
// src/optionValidator.ts
function validateOptions({ maxItems }) {
    if (maxItems !== void 0 && maxItems < -1) {
        throw RangeError(`Expected options.maxItems to be >= -1, but was given ${maxItems}.`);
    }
}
;
var DEFAULT_OPTIONS = {
    $refOptions: {},
    additionalProperties: true,
    // TODO: default to empty schema (as per spec) instead
    bannerComment: `/* eslint-disable */
/**
* This file was automatically generated by json-schema-to-typescript.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run json-schema-to-typescript to regenerate this file.
*/`,
    cwd: process.cwd(),
    declareExternallyReferenced: true,
    enableConstEnums: true,
    inferStringEnumKeysFromValues: false,
    format: true,
    ignoreMinAndMaxItems: false,
    maxItems: 20,
    strictIndexSignatures: false,
    style: {
        bracketSpacing: false,
        printWidth: 120,
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: "none",
        useTabs: false
    },
    unreachableDefinitions: false,
    unknownAny: true
};
function compileJsonFile(file, name, options = DEFAULT_OPTIONS) {
    const schema = Try(()=>JSON.parse(getContent(file)), ()=>{
        throw new TypeError(`Error parsing JSON in "${name}"`);
    });
    return compile(schema, name, options);
}
function getContent(file) {
    return file.toString();
}
function compileYamlFile(file, name, options = DEFAULT_OPTIONS) {
    const schema = Try(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$yaml$40$4$2e$1$2e$0$2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].load(getContent(file)), ()=>{
        throw new TypeError(`Error parsing YML in "${name}"`);
    });
    return compile(schema, name, options);
}
function compile(_0, _1) {
    return __async(this, arguments, function*(schema, name, options = {}) {
        validateOptions(options);
        const _options = deepMerge({}, DEFAULT_OPTIONS, options);
        if (!_options.cwd.endsWith("/")) {
            _options.cwd += "/";
        }
        const { dereferencedSchema, dereferencedPaths } = _options.$refOptions !== false ? yield dereference(schema, _options.cwd, _options.$refOptions) : {
            dereferencedSchema: schema,
            dereferencedPaths: _options.schemaToId
        };
        const linked = link(dereferencedSchema);
        const errors = validate(linked, name);
        if (errors.length) {
            errors.forEach((_)=>error(_));
            throw new ValidationError();
        }
        const normalized = normalize(linked, dereferencedPaths, name, _options);
        const parsed = parse(normalized, _options);
        const optimized = optimize(parsed, _options);
        const generated = generate(optimized, _options);
        const formatted = yield format(generated, _options);
        return formatted;
    });
}
var ValidationError = class extends Error {
};
;
}),
"[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/array-helper.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    isArray: function(value) {
        if (Array.isArray) {
            return Array.isArray(value);
        }
        // fallback for older browsers like  IE 8
        return Object.prototype.toString.call(value) === '[object Array]';
    }
};
}),
"[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/options-helper.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var isArray = __turbopack_context__.r("[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/array-helper.js [app-rsc] (ecmascript)").isArray;
module.exports = {
    copyOptions: function(options) {
        var key, copy = {};
        for(key in options){
            if (options.hasOwnProperty(key)) {
                copy[key] = options[key];
            }
        }
        return copy;
    },
    ensureFlagExists: function(item, options) {
        if (!(item in options) || typeof options[item] !== 'boolean') {
            options[item] = false;
        }
    },
    ensureSpacesExists: function(options) {
        if (!('spaces' in options) || typeof options.spaces !== 'number' && typeof options.spaces !== 'string') {
            options.spaces = 0;
        }
    },
    ensureAlwaysArrayExists: function(options) {
        if (!('alwaysArray' in options) || typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray)) {
            options.alwaysArray = false;
        }
    },
    ensureKeyExists: function(key, options) {
        if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
            options[key + 'Key'] = options.compact ? '_' + key : key;
        }
    },
    checkFnExists: function(key, options) {
        return key + 'Fn' in options;
    }
};
}),
"[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/js2xml.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var helper = __turbopack_context__.r("[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/options-helper.js [app-rsc] (ecmascript)");
var isArray = __turbopack_context__.r("[project]/node_modules/.pnpm/xml-js@1.6.11/node_modules/xml-js/lib/array-helper.js [app-rsc] (ecmascript)").isArray;
var currentElement, currentElementName;
function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists('ignoreDeclaration', options);
    helper.ensureFlagExists('ignoreInstruction', options);
    helper.ensureFlagExists('ignoreAttributes', options);
    helper.ensureFlagExists('ignoreText', options);
    helper.ensureFlagExists('ignoreComment', options);
    helper.ensureFlagExists('ignoreCdata', options);
    helper.ensureFlagExists('ignoreDoctype', options);
    helper.ensureFlagExists('compact', options);
    helper.ensureFlagExists('indentText', options);
    helper.ensureFlagExists('indentCdata', options);
    helper.ensureFlagExists('indentAttributes', options);
    helper.ensureFlagExists('indentInstruction', options);
    helper.ensureFlagExists('fullTagEmptyElement', options);
    helper.ensureFlagExists('noQuotesForNativeAttributes', options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === 'number') {
        options.spaces = Array(options.spaces + 1).join(' ');
    }
    helper.ensureKeyExists('declaration', options);
    helper.ensureKeyExists('instruction', options);
    helper.ensureKeyExists('attributes', options);
    helper.ensureKeyExists('text', options);
    helper.ensureKeyExists('comment', options);
    helper.ensureKeyExists('cdata', options);
    helper.ensureKeyExists('doctype', options);
    helper.ensureKeyExists('type', options);
    helper.ensureKeyExists('name', options);
    helper.ensureKeyExists('elements', options);
    helper.checkFnExists('doctype', options);
    helper.checkFnExists('instruction', options);
    helper.checkFnExists('cdata', options);
    helper.checkFnExists('comment', options);
    helper.checkFnExists('text', options);
    helper.checkFnExists('instructionName', options);
    helper.checkFnExists('elementName', options);
    helper.checkFnExists('attributeName', options);
    helper.checkFnExists('attributeValue', options);
    helper.checkFnExists('attributes', options);
    helper.checkFnExists('fullTagEmptyElement', options);
    return options;
}
function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}
function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
        return '';
    }
    if ('attributesFn' in options) {
        attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for(key in attributes){
        if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
            quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
            attr = '' + attributes[key]; // ensure number and boolean are converted to String
            attr = attr.replace(/"/g, '&quot;');
            attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
            result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : ' ');
            result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
        }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
        result.push(writeIndentation(options, depth, false));
    }
    return result.join('');
}
function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = 'xml';
    return options.ignoreDeclaration ? '' : '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}
function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
        return '';
    }
    var key;
    for(key in instruction){
        if (instruction.hasOwnProperty(key)) {
            break;
        }
    }
    var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === 'object') {
        currentElement = instruction;
        currentElementName = instructionName;
        return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
    } else {
        var instructionValue = instruction[key] ? instruction[key] : '';
        if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
        return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
    }
}
function writeComment(comment, options) {
    return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}
function writeCdata(cdata, options) {
    return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}
function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}
function writeText(text, options) {
    if (options.ignoreText) return '';
    text = '' + text; // ensure Number and Boolean are converted to String
    text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}
function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) {
        for(i = 0; i < element.elements.length; ++i){
            switch(element.elements[i][options.typeKey]){
                case 'text':
                    if (options.indentText) {
                        return true;
                    }
                    break; // skip to next key
                case 'cdata':
                    if (options.indentCdata) {
                        return true;
                    }
                    break; // skip to next key
                case 'instruction':
                    if (options.indentInstruction) {
                        return true;
                    }
                    break; // skip to next key
                case 'doctype':
                case 'comment':
                case 'element':
                    return true;
                default:
                    return true;
            }
        }
    }
    return false;
}
function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push('<' + elementName);
    if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
        if ('fullTagEmptyElementFn' in options) {
            withClosingTag = options.fullTagEmptyElementFn(element.name, element);
        } else {
            withClosingTag = options.fullTagEmptyElement;
        }
    }
    if (withClosingTag) {
        xml.push('>');
        if (element[options.elementsKey] && element[options.elementsKey].length) {
            xml.push(writeElements(element[options.elementsKey], options, depth + 1));
            currentElement = element;
            currentElementName = element.name;
        }
        xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
        xml.push('</' + elementName + '>');
    } else {
        xml.push('/>');
    }
    return xml.join('');
}
function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
        var indent = writeIndentation(options, depth, firstLine && !xml);
        switch(element.type){
            case 'element':
                return xml + indent + writeElement(element, options, depth);
            case 'comment':
                return xml + indent + writeComment(element[options.commentKey], options);
            case 'doctype':
                return xml + indent + writeDoctype(element[options.doctypeKey], options);
            case 'cdata':
                return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
            case 'text':
                return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
            case 'instruction':
                var instruction = {};
                instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
                return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
        }
    }, '');
}
function hasContentCompact(element, options, anyContent) {
    var key;
    for(key in element){
        if (element.hasOwnProperty(key)) {
            switch(key){
                case options.parentKey:
                case options.attributesKey:
                    break; // skip to next key
                case options.textKey:
                    if (options.indentText || anyContent) {
                        return true;
                    }
                    break; // skip to next key
                case options.cdataKey:
                    if (options.indentCdata || anyContent) {
                        return true;
                    }
                    break; // skip to next key
                case options.instructionKey:
                    if (options.indentInstruction || anyContent) {
                        return true;
                    }
                    break; // skip to next key
                case options.doctypeKey:
                case options.commentKey:
                    return true;
                default:
                    return true;
            }
        }
    }
    return false;
}
function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
    if (typeof element === 'undefined' || element === null || element === '') {
        return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
    }
    var xml = [];
    if (name) {
        xml.push('<' + elementName);
        if (typeof element !== 'object') {
            xml.push('>' + writeText(element, options) + '</' + elementName + '>');
            return xml.join('');
        }
        if (element[options.attributesKey]) {
            xml.push(writeAttributes(element[options.attributesKey], options, depth));
        }
        var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
        if (!withClosingTag) {
            if ('fullTagEmptyElementFn' in options) {
                withClosingTag = options.fullTagEmptyElementFn(name, element);
            } else {
                withClosingTag = options.fullTagEmptyElement;
            }
        }
        if (withClosingTag) {
            xml.push('>');
        } else {
            xml.push('/>');
            return xml.join('');
        }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
        xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
    }
    return xml.join('');
}
function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for(key in element){
        if (element.hasOwnProperty(key)) {
            nodes = isArray(element[key]) ? element[key] : [
                element[key]
            ];
            for(i = 0; i < nodes.length; ++i){
                switch(key){
                    case options.declarationKey:
                        xml.push(writeDeclaration(nodes[i], options, depth));
                        break;
                    case options.instructionKey:
                        xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth));
                        break;
                    case options.attributesKey:
                    case options.parentKey:
                        break; // skip
                    case options.textKey:
                        xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options));
                        break;
                    case options.cdataKey:
                        xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options));
                        break;
                    case options.doctypeKey:
                        xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
                        break;
                    case options.commentKey:
                        xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
                        break;
                    default:
                        xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
                }
                firstLine = firstLine && !xml.length;
            }
        }
    }
    return xml.join('');
}
module.exports = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = '_root_';
    if (options.compact) {
        xml.push(writeElementsCompact(js, options, 0, true));
    } else {
        if (js[options.declarationKey]) {
            xml.push(writeDeclaration(js[options.declarationKey], options, 0));
        }
        if (js[options.elementsKey] && js[options.elementsKey].length) {
            xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
        }
    }
    return xml.join('');
};
}),
];

//# sourceMappingURL=node_modules__pnpm_92ffa4d9._.js.map